diff -X dontdiff -uprN rtems-base/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S
--- rtems-base/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S	2011-02-03 13:48:06.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/helenos/kernel/sparc64/src/sun4u/takemmu.S	2011-01-10 12:53:46.000000000 -0500
@@ -178,11 +178,11 @@ _take_mmu:
 	stxa %g0, [%g1] ASI_DMMU_DEMAP			
 	membar #Sync
 */
-#define SET_TLB_TAG(xVMA, r1, context) \
-	set xVMA | (context << TLB_TAG_ACCESS_CONTEXT_SHIFT), %r1
+#define SET_TLB_TAG(r1, context) \
+	set VMA | (context << TLB_TAG_ACCESS_CONTEXT_SHIFT), %r1
 
 	! write DTLB tag
-	SET_TLB_TAG(0x4000, g1, MEM_CONTEXT_KERNEL)
+	SET_TLB_TAG(g1, MEM_CONTEXT_KERNEL)
 	stxa %g1, [VA_DMMU_TAG_ACCESS] %asi			
 	membar #Sync
 
@@ -204,8 +204,8 @@ _take_mmu:
 	
 	! write DTLB data and install the kernel mapping
 	SET_TLB_DATA(g1, g2, TTE_L | TTE_W)	! use non-global mapping
-	stxa %g1, [%g0] ASI_DTLB_DATA_IN_REG
-  membar #Sync
+	stxa %g1, [%g0] ASI_DTLB_DATA_IN_REG		
+	membar #Sync
 
 	/*
 	 * Because we cannot use global mappings (because we want to have
@@ -271,7 +271,7 @@ _take_mmu:
 	flush %g5
 */
 	! write ITLB tag of context 0
-	SET_TLB_TAG(0x4000, g1, MEM_CONTEXT_KERNEL)
+	SET_TLB_TAG(g1, MEM_CONTEXT_KERNEL)
 	mov VA_DMMU_TAG_ACCESS, %g2
 	stxa %g1, [%g2] ASI_IMMU
 	flush %g5
@@ -280,18 +280,6 @@ _take_mmu:
 	SET_TLB_DATA(g1, g2, TTE_L)		! use non-global mapping
 	stxa %g1, [%g0] ASI_ITLB_DATA_IN_REG		
 	flush %g5
-
-  ! GAB: add more mappings for dmmu
-  SET_TLB_TAG(0x404000, g1, MEM_CONTEXT_KERNEL)
-  stxa %g1, [VA_DMMU_TAG_ACCESS] %asi
-  membar #Sync
-  set 0x400000, %g1
-  add %g1, %l5, %l5
-  SET_TLB_DATA(g1, g2, TTE_L | TTE_W)
-  stxa %g1, [%g0] ASI_DTLB_DATA_IN_REG
-  membar #Sync
-
-
 /*
 	! enter nucleus - using context 0
 	wrpr %g0, 1, %tl
diff -X dontdiff -uprN rtems-base/c/src/lib/libbsp/sparc64/shared/start/start.S rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/start/start.S
--- rtems-base/c/src/lib/libbsp/sparc64/shared/start/start.S	2011-02-03 12:53:24.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/start/start.S	2011-01-10 12:53:46.000000000 -0500
@@ -123,10 +123,6 @@ setstack:
 	set SYM(StackStart), %sp
 	add %sp, -STACK_BIAS, %sp
 
-  /* BSP-specific pre-bootcard initializations */
-  call SYM(_BSP_init)
-  nop
-
 	setx ofw_cif, %l0, %l1
  
 	call ofw_init		! initialize OpenFirmware
@@ -135,6 +131,10 @@ setstack:
   call bootstrap
   nop
 
+  /* BSP-specific pre-bootcard initializations */
+  call SYM(_BSP_init)
+  nop
+
   /* Set up ISR handler for interrupt enable/disable */
 	setx SYM(syscall), %l0, %o1
 	setx param_space, %l0, %o2
diff -X dontdiff -uprN rtems-base/c/src/lib/libbsp/sparc64/shared/startup/bsppredriverhook.c rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/bsppredriverhook.c
--- rtems-base/c/src/lib/libbsp/sparc64/shared/startup/bsppredriverhook.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/bsppredriverhook.c	2011-02-21 18:53:02.000000000 -0500
@@ -0,0 +1,21 @@
+/*
+ *  This is a bsp_predriver_hook routine for sparc64
+ *
+ *  COPYRIGHT (c) 1989-2007.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <bsp/bootcard.h>
+
+extern void sparc64_install_isr_entries(void);
+
+void bsp_predriver_hook( void )
+{
+  sparc64_install_isr_entries();
+}
diff -X dontdiff -uprN rtems-base/c/src/lib/libbsp/sparc64/shared/startup/bspstart.c rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/bspstart.c
--- rtems-base/c/src/lib/libbsp/sparc64/shared/startup/bspstart.c	2010-12-13 17:38:48.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/bspstart.c	2011-02-21 18:53:04.000000000 -0500
@@ -18,7 +18,6 @@
 
 #include <bsp.h>
 
-extern void sparc64_install_isr_entries(void);
 
 /*
  *  bsp_start
@@ -29,5 +28,4 @@ extern void sparc64_install_isr_entries(
 void bsp_start( void )
 {
 /*	bootstrap(); */
-	sparc64_install_isr_entries();
 }
diff -X dontdiff -uprN rtems-base/c/src/lib/libbsp/sparc64/shared/startup/linkcmds rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/linkcmds
--- rtems-base/c/src/lib/libbsp/sparc64/shared/startup/linkcmds	2011-02-03 13:39:18.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/shared/startup/linkcmds	2011-01-10 12:53:46.000000000 -0500
@@ -13,8 +13,8 @@
  * Declare some sizes.
  */
 RamBase = DEFINED(RamBase) ? RamBase : 0x0;
-RamSize = DEFINED(RamSize) ? RamSize : 6M; /* 3.5M */
-/*HeapSize = DEFINED(HeapSize) ? HeapSize : 1M;*/
+RamSize = DEFINED(RamSize) ? RamSize : 4M;
+HeapSize = DEFINED(HeapSize) ? HeapSize : 2M;
 StackSize = DEFINED(StackSize) ? StackSize : 256K;
 
 RAM_END = RamBase + RamSize;
@@ -25,7 +25,7 @@ ENTRY(start)
 
 MEMORY
         {
-	        ram : ORIGIN = 0x0, LENGTH = 8M
+	        ram : ORIGIN = 0x0, LENGTH = 256M
 	}
 
 
@@ -194,9 +194,7 @@ SECTIONS
     __end = .;
 
     . = RAM_END;
-    . += StackSize;
-
-/*    . = ALIGN (16);*/
+    . = ALIGN (16);
      PROVIDE (StackStart = .);
 
   } > ram
diff -X dontdiff -uprN rtems-base/c/src/lib/libbsp/sparc64/usiii/Makefile.am rtems-hwpq-dev/c/src/lib/libbsp/sparc64/usiii/Makefile.am
--- rtems-base/c/src/lib/libbsp/sparc64/usiii/Makefile.am	2010-12-13 17:38:48.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libbsp/sparc64/usiii/Makefile.am	2011-02-21 18:58:34.000000000 -0500
@@ -89,11 +89,11 @@ project_lib_DATA = start.$(OBJEXT)
 dist_project_lib_DATA += ../shared/startup/linkcmds
 
 startup_SOURCES = ../../shared/bspclean.c ../../shared/bsplibc.c \
-    ../../shared/bsppredriverhook.c ../../shared/bsppretaskinghook.c \
+    ../../shared/bspstart.c ../../shared/bsppretaskinghook.c \
     ../../shared/bsppost.c \
     ../../shared/bootcard.c ../../shared/sbrk.c \
     ../shared/startup/bspgetworkarea.c \
-    ../shared/startup/bspstart.c \
+    ../shared/startup/bsppredriverhook.c \
     ../shared/startup/setvec.c \
     ../../shared/gnatinstallhandler.c  \
     ../shared/helenos/boot/genarch/balloc.c \
diff -X dontdiff -uprN rtems-base/c/src/lib/libcpu/sparc64/shared/interrupts/installisrentries.c rtems-hwpq-dev/c/src/lib/libcpu/sparc64/shared/interrupts/installisrentries.c
--- rtems-base/c/src/lib/libcpu/sparc64/shared/interrupts/installisrentries.c	2010-12-13 17:38:48.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libcpu/sparc64/shared/interrupts/installisrentries.c	2011-03-19 14:48:16.000000000 -0400
@@ -17,7 +17,242 @@
 #include <rtems/score/sparc64.h>
 #include <rtems/bspIo.h>
 
+#include <rtems/score/chain.h>
+#include <rtems/score/chain.inl>
+#include <rtems/score/wkspace.h>
+
+// should be consistent with tests and hwpq-decoder
+#define QUEUE_SIZE (100)
+
+//#define GAB_DEBUG
+
+static Chain_Control queues[10];
+
+typedef struct {
+  Chain_Node Object;
+  uint32_t priority;
+  uint64_t pointer;
+} pq_node;
+
+/**
+ * sparc64_interrupt_1
+ * spill (overflow) event
+ *
+ * moves half of the hwds out to the software ds.
+ */
+void sparc64_interrupt_1(void) {
+  uint32_t level;
+  uint64_t context;
+  uint32_t queue_idx;
+  uint32_t operation;
+  uint64_t pointer;
+  uint64_t priority;
+  register int mask = (1<<1);
+  int i;
+  pq_node *new_node;
+  Chain_Node *iter;
+  Chain_Control *cc;
+
+  // acknowledge the interrupt (allows isr to schedule another at this level)
+  sparc64_clear_interrupt_bits(mask);
+
+  level = sparc_disable_interrupts();
+
+  // get the interrupted state
+  HWDS_GET_CONTEXT(context);
+
+  // parse context
+  queue_idx = (((uint32_t)(context>>32))&(~0))>>20;
+  operation = (((uint32_t)(context>>32))&~(~0 << (3 + 1)));
+
+  // TODO: currently not using the HWDS cache? :(
+
+  // TODO: should check exception conditions, since some operations can
+  // cause multiple exceptions.
+
+  switch (operation) {
+    case 2:
+      cc = &queues[queue_idx];
+      iter = _Chain_Last(cc);
+      // pop elements off tail of hwpq, merge into software pq
+      for (i = 0; i < QUEUE_SIZE/2; i++) {
+        HWDS_LAST_PRI(queue_idx,priority);
+        HWDS_SPILL(queue_idx, pointer); 
+#ifdef GAB_DEBUG
+        printk("spill: queue: %d\tnode: %x\tprio: %d\n",queue_idx,pointer,priority);
+#endif
+        if (!pointer) {
+          break;
+        }
+        // sort by ascending priority
+        while (!_Chain_Is_head(cc, iter) && 
+            priority < ((pq_node*)iter)->priority) 
+          iter = _Chain_Previous(iter);
+
+        // TODO: use a free list instead of workspace_allocate?
+        new_node = _Workspace_Allocate_or_fatal_error(sizeof(pq_node));
+        // priority >= iter->priority, insert priority node after iter
+        new_node->priority = priority;
+        new_node->pointer = pointer;
+        _Chain_Insert_unprotected(iter, (Chain_Node*)new_node);
+      }
+      break;
+
+    case 3: case 6: case 11:
+#ifdef GAB_DEBUG
+      printk("fill\tqueue: %d\n",queue_idx);
+#endif
+      cc = &queues[queue_idx];
+      iter = _Chain_First(cc);
+      i = 0;
+      
+      while (!_Chain_Is_tail(cc,iter)) {
+        ++i;
+        pq_node *p = iter;
+#ifdef GAB_DEBUG
+        printk("fill: queue: %d\tnode: %x\tprio: %d\n",
+            queue_idx,p->pointer,p->priority);
+#endif
+        Chain_Node *tmp = _Chain_Next(iter);
+        // have to re-insert q item. 
+        HWDS_FILL(queue_idx, p->priority, p->pointer); // maintain count
+        // TODO: check for exception condition?
+        iter = _Chain_Get_unprotected(cc);
+        _Workspace_Free((pq_node*)p);
+        iter = tmp;
+        if (i >= QUEUE_SIZE/2) break;
+      }
+      
+      break;
+
+    default:
+#ifdef GAB_DEBUG
+      printk("Unknown operation (RTEMS)\n");
+#endif
+      break;
+  }
+
+#ifdef GAB_DEBUG
+  // debug output
+  iter = _Chain_First(cc);
+  while(!_Chain_Is_tail(cc,iter)) {
+    pq_node *p = (pq_node*)iter;
+    printk("Chain: %X\t%d\t%x\n",p,p->priority,p->pointer);
+    iter = _Chain_Next(iter);
+  }
+#endif
+
+  sparc_enable_interrupts(level);
+}
+
+/**
+ * sparc64_interrupt_2
+ * fill (underflow) event
+ *
+ * refill hwds from software ds
+ */
+void sparc64_interrupt_2(void) {
+  register int mask = (1<<2);
+
+  uint32_t level;
+  uint64_t context;
+  uint32_t queue_idx;
+  uint32_t operation;
+  int i;
+
+  Chain_Node *iter;
+  Chain_Node *tmp;
+  Chain_Control *cc;
+
+
+  // get the interrupted state
+  HWDS_GET_CONTEXT(context);
+
+  queue_idx = (((uint32_t)(context>>32))&(~0))>>20;
+  operation = (((uint32_t)(context>>32))&~(~0 << (3 + 1)));
+
+  sparc64_clear_interrupt_bits(mask);
+}
+
+/**
+ * sparc64_interrupt_3
+ * miss extract event
+ *
+ * operation on software ds
+ */
+void sparc64_interrupt_3(void) {
+  register int mask = (1<<3);
+
+  uint32_t level;
+  uint64_t context;
+  uint32_t queue_idx;
+  uint32_t operation;
+  uint64_t pointer;
+  pq_node *new_node;
+  Chain_Node *iter;
+  Chain_Control *cc;
+
+  level = sparc_disable_interrupts();
+
+  // get the interrupted state
+  HWDS_GET_CONTEXT(context);
+
+  queue_idx = (((uint32_t)(context>>32))&(~0))>>20;
+  operation = (((uint32_t)(context>>32))&~(~0 << (3 + 1)));
+
+  HWDS_GET_PAYLOAD(pointer);
+
+#ifdef GAB_DEBUG
+  printk("Software extract: %x\n",pointer);
+#endif
+
+  // linear search, ugh
+  cc = &queues[queue_idx];
+  iter = _Chain_First(cc);
+  while(!_Chain_Is_tail(cc,iter)) {
+    pq_node *p = (pq_node*)iter;
+    if (p->pointer == pointer) {
+      if (_Chain_Is_first(iter))
+        _Chain_Get_first_unprotected(iter);
+      else
+        _Chain_Extract_unprotected(iter);
+      _Workspace_Free(iter);
+      break;
+    }
+    iter = _Chain_Next(iter);
+  }
+
+  HWDS_CHECK_UNDERFLOW(queue_idx);
+
+  sparc_enable_interrupts(level);
+
+  sparc64_clear_interrupt_bits(mask);
+}
+
 void sparc64_install_isr_entries( void )
 {
+  proc_ptr old;
+  int i;
+
+  _CPU_ISR_install_vector(
+    SPARC_SYNCHRONOUS_TRAP(0x41),
+    sparc64_interrupt_1,
+    &old
+   );
+  _CPU_ISR_install_vector(
+    SPARC_SYNCHRONOUS_TRAP(0x42),
+    sparc64_interrupt_2,
+    &old
+   );
+  _CPU_ISR_install_vector(
+    SPARC_SYNCHRONOUS_TRAP(0x43),
+    sparc64_interrupt_3,
+    &old
+   );
+
+  for (i = 0; i < 10; i++) {
+    _Chain_Initialize_empty(&queues[i]);
+  }
+
   return;
 }
diff -X dontdiff -uprN rtems-base/c/src/lib/libcpu/sparc64/shared/interrupts/pq.h rtems-hwpq-dev/c/src/lib/libcpu/sparc64/shared/interrupts/pq.h
--- rtems-base/c/src/lib/libcpu/sparc64/shared/interrupts/pq.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libcpu/sparc64/shared/interrupts/pq.h	2011-03-15 16:12:46.000000000 -0400
@@ -0,0 +1,126 @@
+/*
+ * pq.h
+ *
+ * A priority queue supporting:
+ *  enqueue
+ *  extract
+ *  first (peek)
+ * For modelling a HW PQ.  Additional options are included to support special
+ * queue structures.
+ */
+
+//#define GAB_DEBUG
+
+typedef struct pq_node {
+  int             priority;
+  uint64_t          payload;
+  struct pq_node *next;
+  struct pq_node *prev;
+} pq_node;
+
+typedef struct priority_queue {
+  pq_node *head;
+  int options;  // 0 for min, 1 for max, 2 for timer
+} priority_queue;
+
+void pq_print_node(pq_node *n) {
+  printf("%d\t%llu\t%p\t%p\n",n->priority,n->payload,n->next,n->prev);
+}
+
+void pq_print_queue(priority_queue *pq) {
+  pq_node* n = NULL;
+  if (!pq) return;
+  n = pq->head;
+  while(n) {
+    pq_print_node(n);
+    n = n->next;
+  }
+}
+
+pq_node* pq_first(priority_queue *pq) { 
+#ifdef GAB_DEBUG
+  printf("pq_first:\n");
+  pq_print_queue(pq);
+#endif
+  return pq->head;
+}
+
+pq_node* pq_extract(priority_queue *pq, uint64_t data)
+{
+  pq_node *node = pq->head;
+  while (node && node->payload != data) node = node->next;
+
+  if (node) {
+    if (node->prev) 
+      node->prev->next = node->next;
+    else 
+      pq->head = node->next;
+    if (node->next) {
+      node->next->prev = node->prev;
+    }
+  }
+#ifdef GAB_DEBUG
+  printf("pq_extract:\n");
+  pq_print_queue(pq);
+#endif
+  return node;
+}
+
+void pq_insert(priority_queue *pq, pq_node *node) 
+{
+  pq_node *iter = pq->head;
+  pq_node *prev = NULL;
+  node->next = NULL;
+  node->prev = NULL;
+  
+  if (!iter) {
+    pq->head = node;
+    goto out;
+  }
+
+  if ( pq->options == 0 || pq->options == 2 ) { /* min sort, timer chain */
+    while( iter ) {
+      if ( node->priority < iter->priority ) {
+        if (iter->prev)
+          iter->prev->next = node;
+        else
+          pq->head = node;
+        node->prev = iter->prev;
+        node->next = iter;
+        iter->prev = node;
+        goto out;
+      }
+      prev = iter;
+      iter = iter->next;
+    }
+  } else if (pq->options == 1) { /* max sort */
+    while( iter ) {
+      if ( node->priority > iter->priority ) {
+        if (iter->prev)
+          iter->prev->next = node;
+        else
+          pq->head = node;
+        node->prev = iter->prev;
+        node->next = iter;
+        iter->prev = node;
+        goto out;
+      }
+      prev = iter;
+      iter = iter->next;
+    }
+  } else {
+    printf("unrecognized options to pq: %d\n", pq->options);
+  }
+
+  /* end of list */
+  prev->next = node;
+  node->next = NULL;
+  node->prev = prev;
+out:
+#ifdef GAB_DEBUG
+  printf("pq_insert\n");
+  pq_print_queue(pq);
+#else
+  ;
+#endif
+}
diff -X dontdiff -uprN rtems-base/c/src/lib/libcpu/sparc64/shared/score/interrupt.S rtems-hwpq-dev/c/src/lib/libcpu/sparc64/shared/score/interrupt.S
--- rtems-base/c/src/lib/libcpu/sparc64/shared/score/interrupt.S	2010-12-13 17:38:48.000000000 -0500
+++ rtems-hwpq-dev/c/src/lib/libcpu/sparc64/shared/score/interrupt.S	2011-03-16 15:44:00.000000000 -0400
@@ -424,7 +424,7 @@ dispatchAgain:
    */
 
   simple_return:
-  flushw          ! get register windows to a 'clean' state 
+!  flushw          ! get register windows to a 'clean' state 
 
   ! **** DISABLE TRAPS ****
   wrpr    %g0, SPARC_PSTATE_PRIV_MASK, %pstate
diff -X dontdiff -uprN rtems-base/cpukit/score/cpu/sparc64/rtems/score/sparc64.h rtems-hwpq-dev/cpukit/score/cpu/sparc64/rtems/score/sparc64.h
--- rtems-base/cpukit/score/cpu/sparc64/rtems/score/sparc64.h	2011-01-10 12:22:39.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/cpu/sparc64/rtems/score/sparc64.h	2011-03-19 14:30:01.000000000 -0400
@@ -182,7 +182,9 @@ extern "C" {
  *  1   First
  *  2   Enqueue
  *  3   Extract
+ *  4   SetRange
  *
+ * The upper 12 bits specify the queue id.
  */
 
 #define HWDS_FIRST( _queue, _ptr ) \
@@ -220,28 +222,138 @@ extern "C" {
     ); \
   } while (0)
 
+// TODO: Create an interface / wrapper for this.
+#define HWDS_SETRANGE( _queue, _base_addr, _bounds ) \
+  do { \
+    __asm__ __volatile__ ( \
+      "sll  %0, 20, %%l0\n\t" \
+      "sll  %2, 4, %%l1\n\t" \
+      "or   %%l0, %%l1, %%l0\n\t" \
+      "or   %%l0, 4, %%l0\n\t" \
+      "impdep2  %1, %%l0, %%g0" \
+      : \
+      : "r" (_queue), "r" (_base_addr), "r" (_bounds)\
+      : "l0" \
+        ); \
+  } while (0)
+
+// get the HWDS context (last queue, operation)
+#define HWDS_GET_CONTEXT( _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "or   %%g0, 5, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %0" \
+        : "=r" (_ptr) \
+        : : "l0" \
+        ); \
+  } while (0)
+
+// get the tail of the queue.
+#define HWDS_EXTRACT_LAST( _queue, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %1, 20, %%l0\n\t" \
+        "or   %%l0, 6, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %0" \
+        : "=r" (_ptr) \
+        : "r" (_queue) : "l0" ); \
+  } while (0)  
+
+// 7 and 8 are reserved for spill_at and fill_at
+// These currently don't actually do any spill or fill, but indicate
+// to the HWDS that spilling/filling is happening.
+#define HWDS_SPILL( _queue, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %1, 20, %%l0\n\t" \
+        "or   %%l0, 7, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %0" \
+        : "=r" (_ptr) \
+        : "r" (_queue) : "l0" ); \
+  } while (0)  
+
+#define HWDS_FILL( _queue, _pri, _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %0, 20, %%l0\n\t" \
+        "sll  %1, 4, %%l1\n\t" \
+        "or   %%l0, %%l1, %%l0\n\t" \
+        "or   %%l0, 8, %%l0\n\t" \
+        "impdep2  %2, %%l0, %%g0" \
+        : \
+        : "r" (_queue), "r" (_pri), "r" (_ptr) \
+        : "l0" ); \
+  } while (0)  
+
+// get the priority value of the tail
+#define HWDS_LAST_PRI( _queue, _val ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %1, 20, %%l0\n\t" \
+        "or   %%l0, 9, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %0" \
+        : "=r" (_val) \
+        : "r" (_queue) : "l0" ); \
+  } while (0)
+
+#define HWDS_GET_PAYLOAD( _ptr ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "or   %%g0, 10, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %0" \
+        : "=r" (_ptr) \
+        : : "l0" \
+        ); \
+  } while (0)
+
+// this is a hack to check for an underfill condition
+// it is called after a software extraction
+#define HWDS_CHECK_UNDERFLOW( _queue ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "sll  %0, 20, %%l0\n\t" \
+        "or   %%l0, 11, %%l0\n\t" \
+        "impdep2  %%g0, %%l0, %%g0" \
+        : : "r" (_queue) : "l0" ); \
+  } while (0)
+
+
+// these macros support generic HWDS operations and can save on 
+// loop-based operations by avoiding the setup for the queue id and operation.
+#define HWDS_REGOP( _value, _queueOp ) \
+  do { \
+    __asm__ __volatile__ ( \
+        "impdep2  %0, %1, %%g0" \
+        : \
+        : "r" (_value), "r" (_queueOp) \
+        : \
+        ); \
+  } while (0)
+
+
 // TODO: Implement HWDS_FIND
 #define HWDS_FIND( _queue, _ptr, _result ) \
   do { \
-    __asm__ __volatile__ { \
+    __asm__ __volatile__ ( \
       "nop" \
       : \
       : \
       : \
-    }; \
+        ); \
   } while (0)
 
 // TODO: Implement HWDS_NEXT
 #define HWDS_NEXT( _queue, _ptr, _result ) \
   do { \
-    __asm__ __volatile__ { \
+    __asm__ __volatile__ ( \
       "nop" \
       : \
       : \
       : \
-    }; \
+        ); \
   } while (0)
 
+/**************************** DEPRECATED *********************************/
 // probably could do some type checking.
 #define HWDS1_FIRST( _ptr ) \
   do { \
diff -X dontdiff -uprN rtems-base/cpukit/score/include/rtems/score/scheduler.h rtems-hwpq-dev/cpukit/score/include/rtems/score/scheduler.h
--- rtems-base/cpukit/score/include/rtems/score/scheduler.h	2010-12-13 17:40:29.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/include/rtems/score/scheduler.h	2011-01-10 15:26:20.000000000 -0500
@@ -24,6 +24,8 @@
 #include <rtems/score/prioritybitmap.h>
 #include <rtems/score/rbtree.h>
 
+//#define USING_HWPQ
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -X dontdiff -uprN rtems-base/cpukit/score/inline/rtems/score/scheduleredf.inl rtems-hwpq-dev/cpukit/score/inline/rtems/score/scheduleredf.inl
--- rtems-base/cpukit/score/inline/rtems/score/scheduleredf.inl	2010-12-12 18:52:39.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/inline/rtems/score/scheduleredf.inl	2011-01-10 12:53:39.000000000 -0500
@@ -102,6 +102,9 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     return;
   }
 
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, sched->deadline.value, the_thread);
+#else
   /* first add the_thread to red-black tree */
   tmp_node = _RBTree_Insert_unprotected(
                &the_scheduler->Ready_queues.edf->edf_rbtree, 
@@ -182,6 +185,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
       tmp_sched->last_duplicate,
       &the_thread->Object.Node
   );
+#endif
 }
 
 /*
@@ -216,9 +220,13 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     return;
   }
 
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, sched->deadline.value, the_thread);
+#else
   /* TODO: re-write periodic tasks enqueue with lifo to break deadline ties? */
   _Scheduler_edf_Ready_queue_enqueue(the_thread);
   return;
+#endif
 }
 
 /*
@@ -256,6 +264,9 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     return;
   }
 
+#if defined(USING_HWPQ)
+  HWDS_EXTRACT( 1, the_thread );
+#else
   if ( !(_RBTree_Is_node_off_rbtree( &sched->deadline )) ) {
     _RBTree_Extract_unprotected(
         &the_scheduler->Ready_queues.edf->edf_rbtree,
@@ -307,6 +318,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_edf
     _Chain_Initialize_empty( &the_scheduler->Ready_queues.edf->deadline_queue );
   else
     _Chain_Extract_unprotected( &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -325,10 +337,17 @@ RTEMS_INLINE_ROUTINE Thread_Control *_Sc
   Scheduler_Control       *the_scheduler
 )
 {
+#if defined(USING_HWPQ)
+  Thread_Control *t = NULL;
+  HWDS_FIRST( 1, t );
+  if (t)
+    return t;
+#else
   /* when there are periodic jobs to run, schedule them first */
   if ( !_Chain_Is_empty(&the_scheduler->Ready_queues.edf->deadline_queue ) )
     return (Thread_Control *) 
       _Chain_First(&the_scheduler->Ready_queues.edf->deadline_queue);
+#endif
 
   /* otherwise schedule aperiodic jobs as background tasks */
 
diff -X dontdiff -uprN rtems-base/cpukit/score/inline/rtems/score/schedulerpriority.inl rtems-hwpq-dev/cpukit/score/inline/rtems/score/schedulerpriority.inl
--- rtems-base/cpukit/score/inline/rtems/score/schedulerpriority.inl	2010-12-13 17:38:47.000000000 -0500
+++ rtems-hwpq-dev/cpukit/score/inline/rtems/score/schedulerpriority.inl	2011-01-10 12:53:39.000000000 -0500
@@ -64,10 +64,14 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control                  *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, the_thread->current_priority, the_thread );
+#else
   _Priority_bit_map_Add( &the_thread->scheduler.priority->Priority_map );
   
   _Chain_Append_unprotected( the_thread->scheduler.priority->ready_chain, 
       &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -89,10 +93,14 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control                   *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  HWDS_ENQUEUE( 1, the_thread->current_priority, the_thread );
+#else
   _Priority_bit_map_Add( &the_thread->scheduler.priority->Priority_map );
 
   _Chain_Prepend_unprotected( the_thread->scheduler.priority->ready_chain, 
       &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -113,6 +121,9 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control        *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  HWDS_EXTRACT( 1, the_thread);
+#else
   Chain_Control         *ready  = the_thread->scheduler.priority->ready_chain;
 
   if ( _Chain_Has_only_one_node( ready ) ) {
@@ -120,6 +131,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
     _Priority_bit_map_Remove( &the_thread->scheduler.priority->Priority_map );
   } else
     _Chain_Extract_unprotected( &the_thread->Object.Node );
+#endif
 }
 
 /*
@@ -138,12 +150,18 @@ RTEMS_INLINE_ROUTINE Thread_Control *_Sc
   Chain_Control       *the_ready_queue
 )
 {
+#if defined(USING_HWPQ)
+  Thread_Control *t = NULL;
+  HWDS_FIRST(1, t);
+  return t;
+#else
   Priority_Control index = _Priority_bit_map_Get_highest();
 
   if ( !_Chain_Is_empty( &the_ready_queue[ index ] ) )
     return (Thread_Control *) _Chain_First( &the_ready_queue[ index ] );
 
   return NULL;
+#endif
 }
 
 /*
@@ -164,6 +182,10 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
   Thread_Control            *the_thread
 )
 {
+#if defined(USING_HWPQ)
+  _Scheduler_priority_Ready_queue_extract(the_thread);
+  _Scheduler_priority_Ready_queue_enqueue(the_thread);
+#else
   if ( !_Chain_Has_only_one_node(
         the_thread->scheduler.priority->ready_chain
         ) ) {
@@ -172,6 +194,7 @@ RTEMS_INLINE_ROUTINE void _Scheduler_pri
     _Chain_Append_unprotected( the_thread->scheduler.priority->ready_chain, 
       &the_thread->Object.Node );
   }
+#endif
 }
 
 /*
diff -X dontdiff -uprN rtems-base/testsuites/configure.ac rtems-hwpq-dev/testsuites/configure.ac
--- rtems-base/testsuites/configure.ac	2011-02-01 12:13:41.000000000 -0500
+++ rtems-hwpq-dev/testsuites/configure.ac	2011-01-10 12:53:36.000000000 -0500
@@ -29,10 +29,8 @@ RTEMS_CHECK_CPUOPTS([RTEMS_NETWORKING])
 case $enable_tests in
 yes | samples )
   AC_CONFIG_SUBDIRS(samples)
-#  AC_CONFIG_SUBDIRS(gabtests)
+  AC_CONFIG_SUBDIRS(gabtests)
   AC_CONFIG_SUBDIRS(mibench)
-  AC_CONFIG_SUBDIRS(heapbench)
-  AC_CONFIG_SUBDIRS(disbench)
   ;;
 esac
 
diff -X dontdiff -uprN rtems-base/testsuites/gabtests/dijkstra00/system.h rtems-hwpq-dev/testsuites/gabtests/dijkstra00/system.h
--- rtems-base/testsuites/gabtests/dijkstra00/system.h	2010-12-31 12:47:21.000000000 -0500
+++ rtems-hwpq-dev/testsuites/gabtests/dijkstra00/system.h	2011-01-10 12:53:38.000000000 -0500
@@ -92,7 +92,7 @@ rtems_task Tasks_Periodic(
 
 /* system */
 #define CONFIGURE_MICROSECONDS_PER_TICK 1000
-//#define CONFIGURE_SCHEDULER_EDF
+#define CONFIGURE_SCHEDULER_EDF
 
 //#define CONFIGURE_STACK_CHECKER_ENABLED
 
diff -X dontdiff -uprN rtems-base/testsuites/gabtests/dijkstra01/dijkstra.c rtems-hwpq-dev/testsuites/gabtests/dijkstra01/dijkstra.c
--- rtems-base/testsuites/gabtests/dijkstra01/dijkstra.c	2011-01-04 10:56:13.000000000 -0500
+++ rtems-hwpq-dev/testsuites/gabtests/dijkstra01/dijkstra.c	2011-01-10 12:53:38.000000000 -0500
@@ -44,16 +44,16 @@ static int iCost, iDist;
 
 static void print_path (NODE *rgnNodes, int chNode)
 {
-   /* Recursion is bad. for now print the path backwards*/
+  /* Recursion is bad. for now print the path backwards*/
   while(chNode != NONE) {
     printf(" %d", chNode);
     chNode = rgnNodes[chNode].iPrev;
   }
 #if 0
   if (rgnNodes[chNode].iPrev != NONE)
-    {
-      print_path(rgnNodes, rgnNodes[chNode].iPrev);
-    }
+  {
+    print_path(rgnNodes, rgnNodes[chNode].iPrev);
+  }
   printf (" %d", chNode);
   fflush(stdout);
 #endif
@@ -66,25 +66,36 @@ static void enqueue (int iNode, int iDis
   QITEM *qLast = qHead;
 
   if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      MAGIC_BREAKPOINT;
-      while(1);
-    }
+  {
+    fprintf(stderr, "Out of memory.\n");
+    MAGIC_BREAKPOINT;
+    while(1);
+  }
   qNew->iNode = iNode;
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
   qNew->qNext = NULL;
 
+  // GAB: instead of tail-queueing, sort entries as a 
+  // priority queue by the iDist.
   if (!qLast)
-    {
-      qHead = qNew;
-    }
+  {
+    qHead = qNew;
+  }
+  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
+  {
+    qHead = qNew;
+    qNew->qNext = qLast;
+  }
   else
-    {
-      while (qLast->qNext) qLast = qLast->qNext;
-      qLast->qNext = qNew;
+  {
+    // already handled head case, find the Q element to insert qNew after.
+    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
+      qLast = qLast->qNext;
     }
+    qNew->qNext = qLast->qNext;
+    qLast->qNext = qNew;
+  }
   g_qCount++;
   //               ASSERT(g_qCount);
 }
@@ -95,15 +106,15 @@ static void dequeue (int *piNode, int *p
   QITEM *qKill = qHead;
 
   if (qHead)
-    {
-      //                 ASSERT(g_qCount);
-      *piNode = qHead->iNode;
-      *piDist = qHead->iDist;
-      *piPrev = qHead->iPrev;
-      qHead = qHead->qNext;
-      free(qKill);
-      g_qCount--;
-    }
+  {
+    //                 ASSERT(g_qCount);
+    *piNode = qHead->iNode;
+    *piDist = qHead->iDist;
+    *piPrev = qHead->iPrev;
+    qHead = qHead->qNext;
+    free(qKill);
+    g_qCount--;
+  }
 }
 
 
@@ -117,42 +128,42 @@ static int dijkstra(int chStart, int chE
   int i = 0;
 
   for (ch = 0; ch < NUM_NODES; ch++)
-    {
-      rgnNodes[ch].iDist = NONE;
-      rgnNodes[ch].iPrev = NONE;
-    }
+  {
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+  }
   if (chStart == chEnd)
-    {
-      printf("Shortest path is 0 in cost. Just stay where you are.\n");
-    }
+  {
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+  }
   else
-    {
-      rgnNodes[chStart].iDist = 0;
-      rgnNodes[chStart].iPrev = NONE;
-
-      enqueue (chStart, 0, NONE);
-     while (qcount() > 0)
-	{
-	  dequeue (&iNode, &iDist, &iPrev);
-	  for (i = 0; i < NUM_NODES; i++)
-	    {
-	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
-		{
-		  if ((NONE == rgnNodes[i].iDist) ||
-		      (rgnNodes[i].iDist > (iCost + iDist)))
-		    {
-		      rgnNodes[i].iDist = iDist + iCost;
-		      rgnNodes[i].iPrev = iNode;
-		      enqueue (i, iDist + iCost, iNode);
-		    }
-		}
-	    }
-	}
-      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
-      printf("Path is: ");
-      print_path(rgnNodes, chEnd);
-      printf("\n");
-    }
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
+
+    enqueue (chStart, 0, NONE);
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+          }
+        }
+      }
+    }
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+  }
   return 0;
 }
 
@@ -176,7 +187,7 @@ int dijkstra_setup( ) {
     for (j=0;j<NUM_NODES;j++) {
       /* make it more sparce */
       fscanf(fp,"%d",&k);
-			AdjMatrix[i][j]= k;
+      AdjMatrix[i][j]= k;
     }
   }
 
@@ -185,7 +196,7 @@ int dijkstra_setup( ) {
 
 rtems_task Tasks_Dijkstra(
     rtems_task_argument argument
-)
+    )
 {
   uint32_t          i = 0;
   uint32_t          j = NUM_NODES/2;
@@ -202,8 +213,8 @@ rtems_task Tasks_Dijkstra(
   /* finds 10 shortest paths between nodes */
   for ( ; i<20; ++i,++j) {
     printf("Computing at %d, %d\n",i,j);
-			j = (j % NUM_NODES);
-      dijkstra(i,j);
+    j = (j % NUM_NODES);
+    dijkstra(i,j);
   }
   printf("Done\n");
 
@@ -211,13 +222,13 @@ rtems_task Tasks_Dijkstra(
   status = rtems_semaphore_obtain( tasks_complete_sem, 
       RTEMS_DEFAULT_OPTIONS, 0 );
   directive_failed( status, "rtems_semaphore_obtain" );
-    tasks_completed++;
-      printf("Done\n");
+  tasks_completed++;
+  printf("Done\n");
 
-    if ( NUM_APERIODIC_TASKS == tasks_completed ) {
-      MAGIC_BREAKPOINT;
-      rtems_test_exit( 0 );
-    }
+  if ( NUM_APERIODIC_TASKS == tasks_completed ) {
+    MAGIC_BREAKPOINT;
+    rtems_test_exit( 0 );
+  }
   status = rtems_semaphore_release( tasks_complete_sem );
   directive_failed( status, "rtems_semaphore_release" );
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/configure.ac rtems-hwpq-dev/testsuites/mibench/configure.ac
--- rtems-base/testsuites/mibench/configure.ac	2011-01-30 19:12:15.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/configure.ac	2011-02-13 13:15:14.000000000 -0500
@@ -4,7 +4,7 @@
 
 AC_PREREQ(2.60)
 AC_INIT([rtems-c-src-tests-mibench],[_RTEMS_VERSION],[http://www.rtems.org/bugzilla])
-AC_CONFIG_SRCDIR([crc])
+AC_CONFIG_SRCDIR([sha_small])
 RTEMS_TOP([../..],[..])
 
 RTEMS_CANONICAL_TARGET_CPU
@@ -60,29 +60,20 @@ AM_CONDITIONAL(LIBCHIP,[test "$RTEMS_BSP
 
 # Explicitly list all Makefiles here
 AC_CONFIG_FILES([Makefile
-basicmath_large/Makefile
-basicmath_small/Makefile
-bitcount_large/Makefile
-bitcount_small/Makefile
-crc/Makefile
-dijkstra/Makefile
-fft_large/Makefile
-fft_small/Makefile
-fftinv_large/Makefile
-fftinv_small/Makefile
-patricia_small/Makefile
-qsort_small/Makefile
-rijndael_small/Makefile
 sha_small/Makefile
-stringsearch_large/Makefile
-stringsearch_small/Makefile
+sha_large/Makefile
 susan_smoothing/Makefile
-susan_corners/Makefile
-susan_edges/Makefile
+crc/Makefile
+dijkstra/Makefile
+dijkstra_large_sort_HWPQ/Makefile
+dijkstra_large_sort_OSPQ/Makefile
+dijkstra_small_sort_HWPQ/Makefile
+dijkstra_small_sort_HWPQ_spill/Makefile
+dijkstra_small_sort_OSPQ/Makefile
+dijkstra_small_sort/Makefile
+dijkstra_large_sort/Makefile
+dijkstra_small_heap/Makefile
+dijkstra_large_heap/Makefile
+dijkstra_small_3_heap/Makefile
 ])
-#dijkstra_small_sort/Makefile
-#dijkstra_large_sort/Makefile
-#dijkstra_small_sort_HWPQ/Makefile
-#dijkstra_large_sort_HWPQ/Makefile
-
 AC_OUTPUT
diff -X dontdiff -uprN rtems-base/testsuites/mibench/crc/init.c rtems-hwpq-dev/testsuites/mibench/crc/init.c
--- rtems-base/testsuites/mibench/crc/init.c	2011-02-01 15:29:43.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/crc/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -35,7 +35,7 @@ rtems_task Init(
 {
   
 
-  char in_file[20] = "/small.pcm";
+  char in_file[20] = "/image.img";
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
diff -X dontdiff -uprN rtems-base/testsuites/mibench/crc/LICENSE rtems-hwpq-dev/testsuites/mibench/crc/LICENSE
--- rtems-base/testsuites/mibench/crc/LICENSE	2011-01-30 18:55:11.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/crc/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-From http://www.snippets.org/.
-
-This code is FREE with no restrictions.
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra/init.c
--- rtems-base/testsuites/mibench/dijkstra/init.c	2010-12-14 10:11:41.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -199,11 +199,13 @@ rtems_task Init(
     }
   }
 
+  asm volatile("break_start_opal:");
   /* finds 10 shortest paths between nodes */
   for (i=0,j=NUM_NODES/2;i<20;i++,j++) {
 			j=j%NUM_NODES;
       dijkstra(i,j);
   }
+  MAGIC_BREAKPOINT;
 
   printf( "*** end of dijkstra benchmark ***\n" );
   exit( 0 );
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra/LICENSE rtems-hwpq-dev/testsuites/mibench/dijkstra/LICENSE
--- rtems-base/testsuites/mibench/dijkstra/LICENSE	2011-01-30 18:55:22.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,5 +0,0 @@
-Matt hacked this together.
-
-It is GPL'ed.
-
-
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_heap/clean_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/clean_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_large_heap/clean_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/clean_fs.sh	2011-01-12 11:04:58.000000000 -0500
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+rm FileSystemImage FileSystemImage.c FileSystemImage.h
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_heap/generate_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/generate_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_large_heap/generate_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/generate_fs.sh	2011-01-12 11:04:58.000000000 -0500
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# generate filesystem
+cd files
+tar -cvf ../FileSystemImage --exclude CVS --exclude .cvsignore --exclude .svn .
+cd ..
+rtems-bin2c FileSystemImage FileSystemImage
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_heap/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/init.c
--- rtems-base/testsuites/mibench/dijkstra_large_heap/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/init.c	2011-01-12 11:09:33.000000000 -0500
@@ -0,0 +1,265 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is called from init_exec and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+#include <stdio.h>
+
+//#define GAB_PRINT
+
+#define NUM_NODES                          100
+#define NONE                               9999
+
+struct _NODE
+{
+  int iNode;
+  int iDist;
+  int iPrev;
+  int hIndex;
+  int hFlag;
+};
+typedef struct _NODE NODE;
+
+/*
+ * Heap implementation for dijkstra
+ */
+#define HEAP_PARENT(i) (i>>1)
+#define HEAP_FIRST (1)
+#define HEAP_LEFT(i) (i<<1)
+#define HEAP_RIGHT(i) (HEAP_LEFT(i)+1)
+
+NODE* the_heap[NUM_NODES+1];
+int heap_current_size;
+
+static inline void swap_entries(int a, int b) {
+  NODE *tmp = the_heap[a];
+  int tmpIndex = the_heap[a]->hIndex;
+  the_heap[a]->hIndex = the_heap[b]->hIndex;
+  the_heap[b]->hIndex = tmpIndex;
+  the_heap[a] = the_heap[b];
+  the_heap[b] = tmp;
+}
+
+static void bubble_up( int i )
+{
+  while ( i > 1 && the_heap[i]->iDist < the_heap[HEAP_PARENT(i)]->iDist ) {
+    swap_entries (i, HEAP_PARENT(i));
+    i = HEAP_PARENT(i);
+  }
+}
+
+static void bubble_down( int i ) {
+  int j = 0;
+
+  do {
+    j = i;
+    if ( HEAP_LEFT(j) <= heap_current_size ) {
+      if (the_heap[HEAP_LEFT(j)]->iDist < the_heap[i]->iDist)
+        i = HEAP_LEFT(j);
+    }
+    if ( HEAP_RIGHT(j) <= heap_current_size ) {
+      if (the_heap[HEAP_RIGHT(j)]->iDist < the_heap[i]->iDist) 
+        i = HEAP_RIGHT(j);
+    }
+    swap_entries(i,j);
+  } while (i != j);
+}
+
+void heap_initialize( void ) {
+  heap_current_size = 0;
+}
+
+void heap_insert( NODE *n ) {
+  ++heap_current_size;
+  the_heap[heap_current_size] = n;
+  n->hIndex = heap_current_size;
+  bubble_up(heap_current_size);
+}
+
+void heap_remove( int i ) {
+  if (i < 1 || i > heap_current_size) return;
+  swap_entries(i, heap_current_size);
+  --heap_current_size;
+  bubble_down(i);
+}
+
+NODE *heap_min( ) {
+  if (heap_current_size) {
+    return the_heap[1];
+  }
+  return NULL;
+}
+
+NODE *heap_pop_min( ) {
+  NODE *n = heap_min();
+  heap_remove(1);
+  return n;
+}
+
+int AdjMatrix[NUM_NODES][NUM_NODES];
+
+int g_qCount = 0;
+NODE rgnNodes[NUM_NODES];
+int ch;
+int iPrev, iNode;
+int iCost, iDist;
+
+void print_path (NODE *rgnNodes, int chNode)
+{
+#if defined(GAB_PRINT)
+  if (rgnNodes[chNode].iPrev != NONE)
+    {
+      print_path(rgnNodes, rgnNodes[chNode].iPrev);
+    }
+  printf (" %d", chNode);
+  fflush(stdout);
+#endif
+}
+
+void enqueue (int iNode, int iDist, int iPrev)
+{
+  int i = 0;
+  NODE *hNew = &rgnNodes[iNode];
+
+  if (hNew->hFlag) {
+    heap_remove( hNew->hIndex );
+    g_qCount--;
+  }
+
+  hNew->iDist = iDist;
+  hNew->iPrev = iPrev;
+  hNew->hFlag = 1;
+  heap_insert( hNew );
+  g_qCount++;
+  //               ASSERT(g_qCount);
+}
+
+void dequeue (int *piNode, int *piDist, int *piPrev)
+{
+  NODE *hKill = NULL;
+
+  hKill = heap_min();
+
+  if (hKill)
+    {
+      //                 ASSERT(g_qCount);
+      *piNode = hKill->iNode;
+      *piDist = hKill->iDist;
+      *piPrev = hKill->iPrev;
+      heap_remove(hKill->hIndex);
+      hKill->hFlag = 0;
+      hKill->hIndex = 0;
+      g_qCount--;
+    } 
+}
+
+int qcount (void)
+{
+  return(g_qCount);
+}
+
+int dijkstra(int chStart, int chEnd)
+{
+  int i;
+  heap_initialize();
+  for (ch = 0; ch < NUM_NODES; ch++)
+    {
+      rgnNodes[ch].iNode = ch;
+      rgnNodes[ch].iDist = NONE;
+      rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].hIndex = 0;
+      rgnNodes[ch].hFlag = 0;
+    }
+
+  if (chStart == chEnd)
+    {
+#if defined(GAB_PRINT)
+      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+    }
+  else
+    {
+      rgnNodes[chStart].iDist = 0;
+      rgnNodes[chStart].iPrev = NONE;
+
+      enqueue (chStart, 0, NONE);
+
+     while (qcount() > 0)
+	{
+	  dequeue (&iNode, &iDist, &iPrev);
+	  for (i = 0; i < NUM_NODES; i++)
+	    {
+	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
+		{
+		  if ((NONE == rgnNodes[i].iDist) ||
+		      (rgnNodes[i].iDist > (iCost + iDist)))
+		    {
+		      rgnNodes[i].iDist = iDist + iCost;
+		      rgnNodes[i].iPrev = iNode;
+		      enqueue (i, iDist + iCost, iNode);
+		    }
+		}
+	    }
+	}
+#if defined(GAB_PRINT)
+      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+      printf("Path is: ");
+      print_path(rgnNodes, chEnd);
+      printf("\n");
+#endif
+    }
+}
+
+
+rtems_task Init(
+  rtems_task_argument ignored
+)
+{
+  char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
+
+  printf("Unpacking tar filesystem\nThis may take awhile...\n");
+  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
+    printf("Can't unpack tar filesystem\n");
+    exit(1);
+  }
+
+  printf( "\n\n*** dijkstra benchmark ***\n" );
+
+  /* open the adjacency matrix file */
+  fp = fopen (in_file,"r");
+
+  /* make a fully connected matrix */
+  for (i=0;i<NUM_NODES;i++) {
+    for (j=0;j<NUM_NODES;j++) {
+      /* make it more sparce */
+      fscanf(fp,"%d",&k);
+			AdjMatrix[i][j]= k;
+    }
+  }
+
+  asm volatile("break_start_opal:");
+  /* finds 10 shortest paths between nodes */
+  for (i=0,j=NUM_NODES/2;i<100;i++,j++) {
+			j=j%NUM_NODES;
+      dijkstra(i,j);
+  }
+  MAGIC_BREAKPOINT;
+
+  printf( "*** end of dijkstra benchmark ***\n" );
+  exit( 0 );
+}
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_heap/Makefile.am rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/Makefile.am
--- rtems-base/testsuites/mibench/dijkstra_large_heap/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/Makefile.am	2011-01-12 11:05:12.000000000 -0500
@@ -0,0 +1,26 @@
+##
+##  $Id$
+##
+
+MANAGERS = io semaphore
+
+rtems_tests_PROGRAMS = dijkstra_large_heap
+dijkstra_large_heap_SOURCES = init.c FileSystemImage.c
+
+#dist_rtems_tests_DATA = dijkstra_large_heap.scn
+#dist_rtems_tests_DATA += dijkstra_large_heap.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+dijkstra_large_heap_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+LINK_OBJS = $(dijkstra_large_heap_OBJECTS) $(dijkstra_large_heap_LDADD)
+LINK_LIBS = $(dijkstra_large_heap_LDLIBS)
+
+dijkstra_large_heap$(EXEEXT): $(dijkstra_large_heap_OBJECTS) $(dijkstra_large_heap_DEPENDENCIES)
+	@rm -f dijkstra_large_heap$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_heap/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/system.h
--- rtems-base/testsuites/mibench/dijkstra_large_heap/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_heap/system.h	2011-01-12 11:04:58.000000000 -0500
@@ -0,0 +1,51 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <rtems.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* fs includes */
+#include "FileSystemImage.h"
+#include <rtems/untar.h>
+
+/* functions */
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+#include <bsp.h> /* for device driver prototypes */
+
+/* drivers */
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+/* filesystem */
+#define CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM
+#define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
+#define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
+
+//#define CONFIGURE_STACK_CHECKER_ENABLED
+
+/* tasks */
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+//#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+
+#include <rtems/confdefs.h>
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/init.c
--- rtems-base/testsuites/mibench/dijkstra_large_sort/init.c	2011-01-06 14:09:15.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/init.c	2011-01-11 16:16:03.000000000 -0500
@@ -17,29 +17,23 @@
 #include "system.h"
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  struct _NODE *qNext;
+  struct _NODE *qPrev;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
+typedef struct _NODE NODE;
 
+NODE *qHead = NULL;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -47,35 +41,45 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
-
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
+  int i = 0;
+  NODE *qLast = NULL;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    if (qNew->qNext) {
+      qNew->qNext->qPrev = qNew->qPrev;
+    }
+    if (qNew->qPrev) {
+      qNew->qPrev->qNext = qNew->qNext;
+    } else {
+      qHead = qNew->qNext;
     }
-  qNew->iNode = iNode;
+    g_qCount--;
+  }
+  
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
   qNew->qNext = NULL;
+  qNew->qPrev = NULL;
+  qNew->qFlag = 1;
 
+  qLast = qHead;
   // GAB: instead of tail-queueing, sort entries as a 
   // priority queue by the iDist.
   if (!qLast)
@@ -86,6 +90,7 @@ void enqueue (int iNode, int iDist, int 
   {
     qHead = qNew;
     qNew->qNext = qLast;
+    qLast->qPrev = qNew;
   }
   else
   {
@@ -94,30 +99,36 @@ void enqueue (int iNode, int iDist, int 
       qLast = qLast->qNext;
     }
     qNew->qNext = qLast->qNext;
+    qNew->qPrev = qLast;
+    if (qNew->qNext)
+      qNew->qNext->qPrev = qNew;
     qLast->qNext = qNew;
   }
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = qHead;
+  NODE *qKill = qHead;
 
-    if (qHead)
+  if (qHead)
     {
       //                 ASSERT(g_qCount);
       *piNode = qHead->iNode;
       *piDist = qHead->iDist;
       *piPrev = qHead->iPrev;
       qHead = qHead->qNext;
-      free(qKill);
+      if (qHead)
+        qHead->qPrev = NULL;
+      qKill->qNext = NULL;
+      qKill->qPrev = NULL;
+      qKill->qFlag = 0;
+//      free(qKill);
       g_qCount--;
     }
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -125,18 +136,22 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i;
   for (ch = 0; ch < NUM_NODES; ch++)
     {
+      rgnNodes[ch].iNode = ch;
       rgnNodes[ch].iDist = NONE;
       rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].qPrev = NULL;
+      rgnNodes[ch].qNext = NULL;
+      rgnNodes[ch].qFlag = 0;
     }
 
   if (chStart == chEnd)
     {
+#if defined(GAB_PRINT)
       printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
     }
   else
     {
@@ -162,23 +177,22 @@ int dijkstra(int chStart, int chEnd)
 		}
 	    }
 	}
-
+#if defined(GAB_PRINT)
       printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
       printf("Path is: ");
       print_path(rgnNodes, chEnd);
       printf("\n");
+#endif
     }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -186,18 +200,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/system.h
--- rtems-base/testsuites/mibench/dijkstra_large_sort/system.h	2011-01-10 13:12:25.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort/system.h	2011-01-11 16:15:51.000000000 -0500
@@ -31,7 +31,8 @@ rtems_task Init(
 #include <bsp.h> /* for device driver prototypes */
 
 /* drivers */
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
 
 /* filesystem */
@@ -42,8 +43,9 @@ rtems_task Init(
 //#define CONFIGURE_STACK_CHECKER_ENABLED
 
 /* tasks */
-#define CONFIGURE_MAXIMUM_TASKS             4
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
-#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+//#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
 
 #include <rtems/confdefs.h>
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c
--- rtems-base/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c	2011-01-10 11:55:50.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_HWPQ/init.c	2011-01-11 16:43:00.000000000 -0500
@@ -17,29 +17,19 @@
 #include "system.h"
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
-
+typedef struct _NODE NODE;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -47,65 +37,40 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    HWDS_EXTRACT ( 4, qNew );
+    g_qCount--;
+  }
 
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
-    }
-  qNew->iNode = iNode;
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
-  qNew->qNext = NULL;
-
+  qNew->qFlag = 1;
   HWDS_ENQUEUE ( 4, iDist, qNew );
-  /*
-  // GAB: instead of tail-queueing, sort entries as a 
-  // priority queue by the iDist.
-  if (!qLast)
-  {
-    qHead = qNew;
-  }
-  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
-  {
-    qHead = qNew;
-    qNew->qNext = qLast;
-  }
-  else
-  {
-    // already handled head case, find the Q element to insert qNew after.
-    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
-      qLast = qLast->qNext;
-    }
-    qNew->qNext = qLast->qNext;
-    qLast->qNext = qNew;
-  }*/
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = NULL;// = qHead;
+  NODE *qKill = NULL;
 
   HWDS_FIRST( 4, qKill );
 
@@ -116,23 +81,11 @@ void dequeue (int *piNode, int *piDist, 
       *piDist = qKill->iDist;
       *piPrev = qKill->iPrev;
       HWDS_EXTRACT ( 4, qKill );
-      free(qKill);
-      g_qCount--;
-    }
-/*
-  if (qHead)
-    {
-      //                 ASSERT(g_qCount);
-      *piNode = qHead->iNode;
-      *piDist = qHead->iDist;
-      *piPrev = qHead->iPrev;
-      qHead = qHead->qNext;
-      free(qKill);
+      qKill->qFlag = 0;
       g_qCount--;
-    }*/
+    } 
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -140,60 +93,61 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i = 0;
   for (ch = 0; ch < NUM_NODES; ch++)
-    {
-      rgnNodes[ch].iDist = NONE;
-      rgnNodes[ch].iPrev = NONE;
-    }
+  {
+    rgnNodes[ch].iNode = ch;
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+    rgnNodes[ch].qFlag = 0;
+  }
 
   if (chStart == chEnd)
-    {
-      printf("Shortest path is 0 in cost. Just stay where you are.\n");
-    }
+  {
+#if defined(GAB_PRINT)
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+  }
   else
-    {
-      rgnNodes[chStart].iDist = 0;
-      rgnNodes[chStart].iPrev = NONE;
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
 
-      enqueue (chStart, 0, NONE);
+    enqueue (chStart, 0, NONE);
 
-     while (qcount() > 0)
-	{
-	  dequeue (&iNode, &iDist, &iPrev);
-	  for (i = 0; i < NUM_NODES; i++)
-	    {
-	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
-		{
-		  if ((NONE == rgnNodes[i].iDist) ||
-		      (rgnNodes[i].iDist > (iCost + iDist)))
-		    {
-		      rgnNodes[i].iDist = iDist + iCost;
-		      rgnNodes[i].iPrev = iNode;
-		      enqueue (i, iDist + iCost, iNode);
-		    }
-		}
-	    }
-	}
-
-      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
-      printf("Path is: ");
-      print_path(rgnNodes, chEnd);
-      printf("\n");
-    }
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+          }
+        }
+      }
+    }
+#if defined(GAB_PRINT)
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+#endif
+  }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -201,18 +155,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/clean_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/clean_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/clean_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/clean_fs.sh	2011-01-10 12:53:37.000000000 -0500
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+rm FileSystemImage FileSystemImage.c FileSystemImage.h
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/generate_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/generate_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/generate_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/generate_fs.sh	2011-01-10 12:53:37.000000000 -0500
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# generate filesystem
+cd files
+tar -cvf ../FileSystemImage --exclude CVS --exclude .cvsignore --exclude .svn .
+cd ..
+rtems-bin2c FileSystemImage FileSystemImage
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/init.c
--- rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/init.c	2011-01-10 12:53:37.000000000 -0500
@@ -0,0 +1,224 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is called from init_exec and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+#include <stdio.h>
+
+#define NUM_NODES                          100
+#define NONE                               9999
+
+struct _NODE
+{
+  int iDist;
+  int iPrev;
+};
+typedef struct _NODE NODE;
+
+struct _QITEM
+{
+  int iNode;
+  int iDist;
+  int iPrev;
+  struct _QITEM *qNext;
+};
+typedef struct _QITEM QITEM;
+
+QITEM *qHead = NULL;
+
+
+
+
+int AdjMatrix[NUM_NODES][NUM_NODES];
+
+int g_qCount = 0;
+NODE rgnNodes[NUM_NODES];
+int ch;
+int iPrev, iNode;
+int i, iCost, iDist;
+
+
+void print_path (NODE *rgnNodes, int chNode)
+{
+  if (rgnNodes[chNode].iPrev != NONE)
+    {
+      print_path(rgnNodes, rgnNodes[chNode].iPrev);
+    }
+  printf (" %d", chNode);
+  fflush(stdout);
+}
+
+
+void enqueue (int iNode, int iDist, int iPrev)
+{
+  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
+  QITEM *qLast = qHead;
+
+  if (!qNew)
+    {
+      fprintf(stderr, "Out of memory.\n");
+      exit(1);
+    }
+  qNew->iNode = iNode;
+  qNew->iDist = iDist;
+  qNew->iPrev = iPrev;
+  qNew->qNext = NULL;
+
+  // GAB: instead of tail-queueing, sort entries as a 
+  // priority queue by the iDist.
+  if (!qLast)
+  {
+    qHead = qNew;
+  }
+  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
+  {
+    qHead = qNew;
+    qNew->qNext = qLast;
+  }
+  else
+  {
+    // already handled head case, find the Q element to insert qNew after.
+    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
+      qLast = qLast->qNext;
+    }
+    qNew->qNext = qLast->qNext;
+    qLast->qNext = qNew;
+  }
+  g_qCount++;
+  //               ASSERT(g_qCount);
+}
+
+
+void dequeue (int *piNode, int *piDist, int *piPrev)
+{
+  QITEM *qKill = qHead;
+
+  if (qHead)
+    {
+      //                 ASSERT(g_qCount);
+      *piNode = qHead->iNode;
+      *piDist = qHead->iDist;
+      *piPrev = qHead->iPrev;
+      qHead = qHead->qNext;
+      free(qKill);
+      g_qCount--;
+    }
+}
+
+
+int qcount (void)
+{
+  return(g_qCount);
+}
+
+int dijkstra(int chStart, int chEnd)
+{
+
+
+
+  for (ch = 0; ch < NUM_NODES; ch++)
+    {
+      rgnNodes[ch].iDist = NONE;
+      rgnNodes[ch].iPrev = NONE;
+    }
+
+  if (chStart == chEnd)
+    {
+      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+    }
+  else
+    {
+      rgnNodes[chStart].iDist = 0;
+      rgnNodes[chStart].iPrev = NONE;
+
+      enqueue (chStart, 0, NONE);
+
+     while (qcount() > 0)
+	{
+	  dequeue (&iNode, &iDist, &iPrev);
+	  for (i = 0; i < NUM_NODES; i++)
+	    {
+	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
+		{
+		  if ((NONE == rgnNodes[i].iDist) ||
+		      (rgnNodes[i].iDist > (iCost + iDist)))
+		    {
+		      rgnNodes[i].iDist = iDist + iCost;
+		      rgnNodes[i].iPrev = iNode;
+		      enqueue (i, iDist + iCost, iNode);
+		    }
+		}
+	    }
+	}
+
+      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+      printf("Path is: ");
+      print_path(rgnNodes, chEnd);
+      printf("\n");
+    }
+}
+
+
+
+rtems_task Init(
+  rtems_task_argument ignored
+)
+{
+
+
+  char in_file[20] = "/input.dat";
+
+  printf("Unpacking tar filesystem\nThis may take awhile...\n");
+  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
+    printf("Can't unpack tar filesystem\n");
+    exit(1);
+  }
+
+  //FILE * fp= fopen(in_file,"w");
+  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
+  //fclose(fp);
+
+  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
+
+
+  printf( "\n\n*** dijkstra benchmark ***\n" );
+
+  int i,j,k;
+  FILE *fp;
+
+  /* open the adjacency matrix file */
+  fp = fopen (in_file,"r");
+
+  /* make a fully connected matrix */
+  for (i=0;i<NUM_NODES;i++) {
+    for (j=0;j<NUM_NODES;j++) {
+      /* make it more sparce */
+      fscanf(fp,"%d",&k);
+			AdjMatrix[i][j]= k;
+    }
+  }
+
+  asm volatile("break_start_opal:");
+  /* finds 10 shortest paths between nodes */
+  for (i=0,j=NUM_NODES/2;i<100;i++,j++) {
+			j=j%NUM_NODES;
+      dijkstra(i,j);
+  }
+  MAGIC_BREAKPOINT;
+
+  printf( "*** end of dijkstra benchmark ***\n" );
+  exit( 0 );
+}
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/Makefile.am rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/Makefile.am
--- rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/Makefile.am	2011-01-10 12:53:37.000000000 -0500
@@ -0,0 +1,26 @@
+##
+##  $Id$
+##
+
+MANAGERS = io semaphore
+
+rtems_tests_PROGRAMS = dijkstra_large_sort_OSPQ
+dijkstra_large_sort_OSPQ_SOURCES = init.c FileSystemImage.c
+
+#dist_rtems_tests_DATA = dijkstra_large_sort_OSPQ.scn
+#dist_rtems_tests_DATA += dijkstra_large_sort_OSPQ.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+dijkstra_large_sort_OSPQ_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+LINK_OBJS = $(dijkstra_large_sort_OSPQ_OBJECTS) $(dijkstra_large_sort_OSPQ_LDADD)
+LINK_LIBS = $(dijkstra_large_sort_OSPQ_LDLIBS)
+
+dijkstra_large_sort_OSPQ$(EXEEXT): $(dijkstra_large_sort_OSPQ_OBJECTS) $(dijkstra_large_sort_OSPQ_DEPENDENCIES)
+	@rm -f dijkstra_large_sort_OSPQ$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/system.h
--- rtems-base/testsuites/mibench/dijkstra_large_sort_OSPQ/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_large_sort_OSPQ/system.h	2011-01-10 13:11:37.000000000 -0500
@@ -0,0 +1,49 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <rtems.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* fs includes */
+#include "FileSystemImage.h"
+#include <rtems/untar.h>
+
+/* functions */
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+#include <bsp.h> /* for device driver prototypes */
+
+/* drivers */
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+/* filesystem */
+#define CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM
+#define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
+#define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
+
+//#define CONFIGURE_STACK_CHECKER_ENABLED
+
+/* tasks */
+#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+
+#include <rtems/confdefs.h>
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_3_heap/clean_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/clean_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_3_heap/clean_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/clean_fs.sh	2011-01-12 11:25:35.000000000 -0500
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+rm FileSystemImage FileSystemImage.c FileSystemImage.h
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_3_heap/dijkstra.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/dijkstra.c
--- rtems-base/testsuites/mibench/dijkstra_small_3_heap/dijkstra.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/dijkstra.c	2011-01-12 11:46:22.000000000 -0500
@@ -0,0 +1,285 @@
+#include "system.h"
+#include <stdio.h>
+
+//#define GAB_PRINT
+
+#define NUM_NODES                          100
+#define NONE                               9999
+
+struct _NODE
+{
+  int iNode;
+  int iDist;
+  int iPrev;
+  int hIndex;
+  int hFlag;
+};
+typedef struct _NODE NODE;
+
+/*
+ * Heap implementation for dijkstra
+ */
+#define HEAP_PARENT(i) (i>>1)
+#define HEAP_FIRST (1)
+#define HEAP_LEFT(i) (i<<1)
+#define HEAP_RIGHT(i) (HEAP_LEFT(i)+1)
+
+static NODE* the_heap[NUM_NODES+1];
+static int heap_current_size;
+
+static inline void swap_entries(int a, int b) {
+  NODE *tmp = the_heap[a];
+  int tmpIndex = the_heap[a]->hIndex;
+  the_heap[a]->hIndex = the_heap[b]->hIndex;
+  the_heap[b]->hIndex = tmpIndex;
+  the_heap[a] = the_heap[b];
+  the_heap[b] = tmp;
+}
+
+static void bubble_up( int i )
+{
+  while ( i > 1 && the_heap[i]->iDist < the_heap[HEAP_PARENT(i)]->iDist ) {
+    swap_entries (i, HEAP_PARENT(i));
+    i = HEAP_PARENT(i);
+  }
+}
+
+static void bubble_down( int i ) {
+  int j = 0;
+
+  do {
+    j = i;
+    if ( HEAP_LEFT(j) <= heap_current_size ) {
+      if (the_heap[HEAP_LEFT(j)]->iDist < the_heap[i]->iDist)
+        i = HEAP_LEFT(j);
+    }
+    if ( HEAP_RIGHT(j) <= heap_current_size ) {
+      if (the_heap[HEAP_RIGHT(j)]->iDist < the_heap[i]->iDist) 
+        i = HEAP_RIGHT(j);
+    }
+    swap_entries(i,j);
+  } while (i != j);
+}
+
+void heap_initialize( void ) {
+  heap_current_size = 0;
+}
+
+void heap_insert( NODE *n ) {
+  ++heap_current_size;
+  the_heap[heap_current_size] = n;
+  n->hIndex = heap_current_size;
+  bubble_up(heap_current_size);
+}
+
+void heap_remove( int i ) {
+  if (i < 1 || i > heap_current_size) return;
+  swap_entries(i, heap_current_size);
+  --heap_current_size;
+  bubble_down(i);
+}
+
+NODE *heap_min( ) {
+  if (heap_current_size) {
+    return the_heap[1];
+  }
+  return NULL;
+}
+
+NODE *heap_pop_min( ) {
+  NODE *n = heap_min();
+  heap_remove(1);
+  return n;
+}
+
+static int AdjMatrix[NUM_NODES][NUM_NODES];
+
+static int g_qCount = 0;
+static NODE rgnNodes[NUM_NODES];
+static int ch;
+static int iPrev, iNode;
+static int iCost, iDist;
+
+void print_path (NODE *rgnNodes, int chNode)
+{
+#if defined(GAB_PRINT)
+  if (rgnNodes[chNode].iPrev != NONE)
+    {
+      print_path(rgnNodes, rgnNodes[chNode].iPrev);
+    }
+  printf (" %d", chNode);
+  fflush(stdout);
+#endif
+}
+
+void enqueue (int iNode, int iDist, int iPrev)
+{
+  int i = 0;
+  NODE *hNew = &rgnNodes[iNode];
+
+  if (hNew->hFlag) {
+    heap_remove( hNew->hIndex );
+    g_qCount--;
+  }
+
+  hNew->iDist = iDist;
+  hNew->iPrev = iPrev;
+  hNew->hFlag = 1;
+  heap_insert( hNew );
+  g_qCount++;
+  //               ASSERT(g_qCount);
+}
+
+void dequeue (int *piNode, int *piDist, int *piPrev)
+{
+  NODE *hKill = NULL;
+
+  hKill = heap_min();
+
+  if (hKill)
+    {
+      //                 ASSERT(g_qCount);
+      *piNode = hKill->iNode;
+      *piDist = hKill->iDist;
+      *piPrev = hKill->iPrev;
+      heap_remove(hKill->hIndex);
+      hKill->hFlag = 0;
+      hKill->hIndex = 0;
+      g_qCount--;
+    } 
+}
+
+int qcount (void)
+{
+  return(g_qCount);
+}
+
+int dijkstra(int chStart, int chEnd)
+{
+  int i;
+  heap_initialize();
+  for (ch = 0; ch < NUM_NODES; ch++)
+    {
+      rgnNodes[ch].iNode = ch;
+      rgnNodes[ch].iDist = NONE;
+      rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].hIndex = 0;
+      rgnNodes[ch].hFlag = 0;
+    }
+
+  if (chStart == chEnd)
+    {
+#if defined(GAB_PRINT)
+      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+    }
+  else
+    {
+      rgnNodes[chStart].iDist = 0;
+      rgnNodes[chStart].iPrev = NONE;
+
+      enqueue (chStart, 0, NONE);
+
+     while (qcount() > 0)
+	{
+	  dequeue (&iNode, &iDist, &iPrev);
+	  for (i = 0; i < NUM_NODES; i++)
+	    {
+	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
+		{
+		  if ((NONE == rgnNodes[i].iDist) ||
+		      (rgnNodes[i].iDist > (iCost + iDist)))
+		    {
+		      rgnNodes[i].iDist = iDist + iCost;
+		      rgnNodes[i].iPrev = iNode;
+		      enqueue (i, iDist + iCost, iNode);
+		    }
+		}
+	    }
+	}
+#if defined(GAB_PRINT)
+      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+      printf("Path is: ");
+      print_path(rgnNodes, chEnd);
+      printf("\n");
+#endif
+    }
+}
+
+int dijkstra_setup( )
+/*rtems_task Init(
+  rtems_task_argument ignored
+)*/
+{
+  char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
+
+  printf("Unpacking tar filesystem\nThis may take awhile...\n");
+  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
+    printf("Can't unpack tar filesystem\n");
+    exit(1);
+  }
+
+  /* open the adjacency matrix file */
+  fp = fopen (in_file,"r");
+
+  /* make a fully connected matrix */
+  for (i=0;i<NUM_NODES;i++) {
+    for (j=0;j<NUM_NODES;j++) {
+      /* make it more sparce */
+      fscanf(fp,"%d",&k);
+			AdjMatrix[i][j]= k;
+    }
+  }
+
+  return 0;
+}
+
+rtems_task Tasks_Dijkstra(
+    rtems_task_argument argument
+)
+{
+  uint32_t          i = 0;
+  uint32_t          j = NUM_NODES/2;
+  rtems_status_code status;
+
+  /* Barrier: tasks will be released by the init function */
+  status = rtems_semaphore_obtain( tasks_complete_sem, 
+      RTEMS_DEFAULT_OPTIONS, 0 );
+
+  //rtems_task_wake_after( Phases[ argument ] );
+
+  /* active computing */
+  /* TODO: condition behavior on parameters */
+  /* finds 10 shortest paths between nodes */
+  for ( ; i<20; ++i,++j) {
+    printf("Computing at %d, %d\n",i,j);
+			j = (j % NUM_NODES);
+      dijkstra(i,j);
+  }
+  printf("Done\n");
+
+  /* finish */
+  status = rtems_semaphore_obtain( tasks_complete_sem, 
+      RTEMS_DEFAULT_OPTIONS, 0 );
+  directive_failed( status, "rtems_semaphore_obtain" );
+    tasks_completed++;
+      printf("Done\n");
+
+    if ( 3 == tasks_completed ) {
+      MAGIC_BREAKPOINT;
+      rtems_test_exit( 0 );
+    }
+  status = rtems_semaphore_release( tasks_complete_sem );
+  directive_failed( status, "rtems_semaphore_release" );
+
+  /* Should block forever */
+  status = rtems_semaphore_obtain( final_barrier, RTEMS_DEFAULT_OPTIONS, 0 );
+  directive_failed( status, "rtems_semaphore_obtain" );
+
+  /* Shouldn't reach this */
+  printf( "Killing task %d\n", argument);
+  status = rtems_task_delete(RTEMS_SELF);
+  directive_failed(status, "rtems_task_delete of RTEMS_SELF");
+}
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_3_heap/generate_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/generate_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_3_heap/generate_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/generate_fs.sh	2011-01-12 11:25:35.000000000 -0500
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# generate filesystem
+cd files
+tar -cvf ../FileSystemImage --exclude CVS --exclude .cvsignore --exclude .svn .
+cd ..
+rtems-bin2c FileSystemImage FileSystemImage
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_3_heap/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_3_heap/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/init.c	2011-01-12 11:41:19.000000000 -0500
@@ -0,0 +1,103 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is called from init_exec and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+#include <stdio.h>
+
+uint32_t  tasks_completed;
+rtems_id  tasks_complete_sem;
+rtems_id  final_barrier;
+
+rtems_task Init(
+  rtems_task_argument ignored
+)
+{
+  int               err = 0;
+  uint32_t          index;
+  rtems_status_code status;
+
+  /* initialize globals */
+  tasks_completed = 0;
+
+  Task_name[1] = rtems_build_name( 'D', 'T', '0', '1' );
+  Task_name[2] = rtems_build_name( 'D', 'T', '0', '1' );
+  Task_name[3] = rtems_build_name( 'D', 'T', '0', '1' );
+
+
+  /* setup dijkstra problem space */
+  err = dijkstra_setup();
+  if ( err ) {
+    printf("Unable to setup dijkstra problem space\n");
+    while(1);
+  }
+
+  /* Create semaphores (barriers) */
+  status = rtems_semaphore_create(
+      rtems_build_name( 'S', 'E', 'M', '0' ),  /* name = SEM0 */
+      0,                                       /* locked */
+      RTEMS_BINARY_SEMAPHORE | RTEMS_FIFO,     /* mutex w/desired discipline */
+      0,                                       /* IGNORED */
+      &tasks_complete_sem
+    );
+  directive_failed( status, "rtems_semaphore_create" );
+
+  status = rtems_semaphore_create(
+      rtems_build_name( 'S', 'E', 'M', '1' ),  /* name = SEM1 */
+      0,                                       /* locked */
+      RTEMS_SIMPLE_BINARY_SEMAPHORE,           /* mutex w/desired discipline */
+      0,                                       /* IGNORED */
+      &final_barrier
+    );
+  directive_failed( status, "rtems_semaphore_create" );
+
+  /* Create task(s) */
+  for (index = 1; index <= 3; index++) {
+    status = rtems_task_create( Task_name[index], 5, RTEMS_MINIMUM_STACK_SIZE*3,
+        RTEMS_DEFAULT_MODES, RTEMS_DEFAULT_ATTRIBUTES, &Task_id[ index ]
+        );
+    directive_failed( status, "rtems_task_create loop" );
+  }
+  
+  /* Start dijkstra tasks */
+  for ( index = 1; index <= 3; index++ ){
+    status = rtems_task_start( Task_id[ index ], Tasks_Dijkstra, index );
+    directive_failed( status, "rtems_task_start loop" );
+  }
+
+  /* sleep while holding semaphore: is 10 ticks enough for 
+   * created/started tasks to finish initializing? */
+  rtems_task_wake_after( 10 );
+
+  /* protected by semaphore */
+  asm volatile("break_start_opal:");
+
+  /* release all of the waiting tasks */
+  status = rtems_semaphore_flush( tasks_complete_sem );
+  directive_failed( status, "rtems_semaphore_flush" );
+
+  status = rtems_semaphore_release( tasks_complete_sem );
+  directive_failed( status, "rtems_semaphore_release" );
+  
+  /* Should block forever */
+  status = rtems_semaphore_obtain( final_barrier, RTEMS_DEFAULT_OPTIONS, 0 );
+  directive_failed( status, "rtems_semaphore_obtain" );
+
+  puts("Init killing self\n");
+
+  status = rtems_task_delete( RTEMS_SELF );
+  directive_failed( status, "rtems_task_delete of RTEMS_SELF" );
+}
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_3_heap/Makefile.am rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/Makefile.am
--- rtems-base/testsuites/mibench/dijkstra_small_3_heap/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/Makefile.am	2011-01-12 11:44:29.000000000 -0500
@@ -0,0 +1,28 @@
+#
+##  $Id$
+##
+
+MANAGERS = all
+
+rtems_tests_PROGRAMS = dijkstra_small_3_heap
+dijkstra_small_3_heap_SOURCES = init.c dijkstra.c FileSystemImage.c
+
+#dist_rtems_tests_DATA = dijkstra_small_3_heap.scn
+#dist_rtems_tests_DATA += dijkstra_small_3_heap.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+dijkstra_small_3_heap_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+AM_CPPFLAGS += -I$(top_srcdir)/../support/include
+
+LINK_OBJS = $(dijkstra_small_3_heap_OBJECTS) $(dijkstra_small_3_heap_LDADD)
+LINK_LIBS = $(dijkstra_small_3_heap_LDLIBS)
+
+dijkstra_small_3_heap$(EXEEXT): $(dijkstra_small_3_heap_OBJECTS) $(dijkstra_small_3_heap_DEPENDENCIES)
+	@rm -f dijkstra_small_3_heap$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_3_heap/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/system.h
--- rtems-base/testsuites/mibench/dijkstra_small_3_heap/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_3_heap/system.h	2011-01-12 11:48:26.000000000 -0500
@@ -0,0 +1,67 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <tmacros.h>
+#include <rtems.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* fs includes */
+#include "FileSystemImage.h"
+#include <rtems/untar.h>
+
+/* functions */
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+rtems_task Tasks_Dijkstra(
+    rtems_task_argument argument
+);
+
+int dijkstra_setup( void );
+
+/* configuration information */
+#include <bsp.h> /* for device driver prototypes */
+
+/* drivers */
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+/* filesystem */
+#define CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM
+#define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
+#define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
+
+#define CONFIGURE_MAXIMUM_SEMAPHORES        2
+
+/* tasks */
+#define CONFIGURE_INIT_TASK_PRIORITY          250
+#define CONFIGURE_INIT_TASK_INITIAL_MODES     RTEMS_DEFAULT_MODES
+#define CONFIGURE_MAXIMUM_TASKS             5
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+//#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+
+/* system */
+#define CONFIGURE_MICROSECONDS_PER_TICK 1000
+//#define CONFIGURE_SCHEDULER_EDF
+
+#include <rtems/confdefs.h>
+TEST_EXTERN rtems_id   Task_id[ 4 ];     /* array of task ids */
+TEST_EXTERN rtems_name Task_name[ 4 ];   /* array of task names */
+extern uint32_t   tasks_completed;
+extern rtems_id   tasks_complete_sem;
+extern rtems_id   final_barrier;
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_heap/clean_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/clean_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_heap/clean_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/clean_fs.sh	2011-01-11 12:51:30.000000000 -0500
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+rm FileSystemImage FileSystemImage.c FileSystemImage.h
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_heap/generate_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/generate_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_heap/generate_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/generate_fs.sh	2011-01-11 12:51:30.000000000 -0500
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# generate filesystem
+cd files
+tar -cvf ../FileSystemImage --exclude CVS --exclude .cvsignore --exclude .svn .
+cd ..
+rtems-bin2c FileSystemImage FileSystemImage
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_heap/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_heap/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/init.c	2011-01-11 19:23:16.000000000 -0500
@@ -0,0 +1,265 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is called from init_exec and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+#include <stdio.h>
+
+//#define GAB_PRINT
+
+#define NUM_NODES                          100
+#define NONE                               9999
+
+struct _NODE
+{
+  int iNode;
+  int iDist;
+  int iPrev;
+  int hIndex;
+  int hFlag;
+};
+typedef struct _NODE NODE;
+
+/*
+ * Heap implementation for dijkstra
+ */
+#define HEAP_PARENT(i) (i>>1)
+#define HEAP_FIRST (1)
+#define HEAP_LEFT(i) (i<<1)
+#define HEAP_RIGHT(i) (HEAP_LEFT(i)+1)
+
+NODE* the_heap[NUM_NODES+1];
+int heap_current_size;
+
+static inline void swap_entries(int a, int b) {
+  NODE *tmp = the_heap[a];
+  int tmpIndex = the_heap[a]->hIndex;
+  the_heap[a]->hIndex = the_heap[b]->hIndex;
+  the_heap[b]->hIndex = tmpIndex;
+  the_heap[a] = the_heap[b];
+  the_heap[b] = tmp;
+}
+
+static void bubble_up( int i )
+{
+  while ( i > 1 && the_heap[i]->iDist < the_heap[HEAP_PARENT(i)]->iDist ) {
+    swap_entries (i, HEAP_PARENT(i));
+    i = HEAP_PARENT(i);
+  }
+}
+
+static void bubble_down( int i ) {
+  int j = 0;
+
+  do {
+    j = i;
+    if ( HEAP_LEFT(j) <= heap_current_size ) {
+      if (the_heap[HEAP_LEFT(j)]->iDist < the_heap[i]->iDist)
+        i = HEAP_LEFT(j);
+    }
+    if ( HEAP_RIGHT(j) <= heap_current_size ) {
+      if (the_heap[HEAP_RIGHT(j)]->iDist < the_heap[i]->iDist) 
+        i = HEAP_RIGHT(j);
+    }
+    swap_entries(i,j);
+  } while (i != j);
+}
+
+void heap_initialize( void ) {
+  heap_current_size = 0;
+}
+
+void heap_insert( NODE *n ) {
+  ++heap_current_size;
+  the_heap[heap_current_size] = n;
+  n->hIndex = heap_current_size;
+  bubble_up(heap_current_size);
+}
+
+void heap_remove( int i ) {
+  if (i < 1 || i > heap_current_size) return;
+  swap_entries(i, heap_current_size);
+  --heap_current_size;
+  bubble_down(i);
+}
+
+NODE *heap_min( ) {
+  if (heap_current_size) {
+    return the_heap[1];
+  }
+  return NULL;
+}
+
+NODE *heap_pop_min( ) {
+  NODE *n = heap_min();
+  heap_remove(1);
+  return n;
+}
+
+int AdjMatrix[NUM_NODES][NUM_NODES];
+
+int g_qCount = 0;
+NODE rgnNodes[NUM_NODES];
+int ch;
+int iPrev, iNode;
+int iCost, iDist;
+
+void print_path (NODE *rgnNodes, int chNode)
+{
+#if defined(GAB_PRINT)
+  if (rgnNodes[chNode].iPrev != NONE)
+    {
+      print_path(rgnNodes, rgnNodes[chNode].iPrev);
+    }
+  printf (" %d", chNode);
+  fflush(stdout);
+#endif
+}
+
+void enqueue (int iNode, int iDist, int iPrev)
+{
+  int i = 0;
+  NODE *hNew = &rgnNodes[iNode];
+
+  if (hNew->hFlag) {
+    heap_remove( hNew->hIndex );
+    g_qCount--;
+  }
+
+  hNew->iDist = iDist;
+  hNew->iPrev = iPrev;
+  hNew->hFlag = 1;
+  heap_insert( hNew );
+  g_qCount++;
+  //               ASSERT(g_qCount);
+}
+
+void dequeue (int *piNode, int *piDist, int *piPrev)
+{
+  NODE *hKill = NULL;
+
+  hKill = heap_min();
+
+  if (hKill)
+    {
+      //                 ASSERT(g_qCount);
+      *piNode = hKill->iNode;
+      *piDist = hKill->iDist;
+      *piPrev = hKill->iPrev;
+      heap_remove(hKill->hIndex);
+      hKill->hFlag = 0;
+      hKill->hIndex = 0;
+      g_qCount--;
+    } 
+}
+
+int qcount (void)
+{
+  return(g_qCount);
+}
+
+int dijkstra(int chStart, int chEnd)
+{
+  int i;
+  heap_initialize();
+  for (ch = 0; ch < NUM_NODES; ch++)
+    {
+      rgnNodes[ch].iNode = ch;
+      rgnNodes[ch].iDist = NONE;
+      rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].hIndex = 0;
+      rgnNodes[ch].hFlag = 0;
+    }
+
+  if (chStart == chEnd)
+    {
+#if defined(GAB_PRINT)
+      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+    }
+  else
+    {
+      rgnNodes[chStart].iDist = 0;
+      rgnNodes[chStart].iPrev = NONE;
+
+      enqueue (chStart, 0, NONE);
+
+     while (qcount() > 0)
+	{
+	  dequeue (&iNode, &iDist, &iPrev);
+	  for (i = 0; i < NUM_NODES; i++)
+	    {
+	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
+		{
+		  if ((NONE == rgnNodes[i].iDist) ||
+		      (rgnNodes[i].iDist > (iCost + iDist)))
+		    {
+		      rgnNodes[i].iDist = iDist + iCost;
+		      rgnNodes[i].iPrev = iNode;
+		      enqueue (i, iDist + iCost, iNode);
+		    }
+		}
+	    }
+	}
+#if defined(GAB_PRINT)
+      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+      printf("Path is: ");
+      print_path(rgnNodes, chEnd);
+      printf("\n");
+#endif
+    }
+}
+
+
+rtems_task Init(
+  rtems_task_argument ignored
+)
+{
+  char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
+
+  printf("Unpacking tar filesystem\nThis may take awhile...\n");
+  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
+    printf("Can't unpack tar filesystem\n");
+    exit(1);
+  }
+
+  printf( "\n\n*** dijkstra benchmark ***\n" );
+
+  /* open the adjacency matrix file */
+  fp = fopen (in_file,"r");
+
+  /* make a fully connected matrix */
+  for (i=0;i<NUM_NODES;i++) {
+    for (j=0;j<NUM_NODES;j++) {
+      /* make it more sparce */
+      fscanf(fp,"%d",&k);
+			AdjMatrix[i][j]= k;
+    }
+  }
+
+  asm volatile("break_start_opal:");
+  /* finds 10 shortest paths between nodes */
+  for (i=0,j=NUM_NODES/2;i<20;i++,j++) {
+			j=j%NUM_NODES;
+      dijkstra(i,j);
+  }
+  MAGIC_BREAKPOINT;
+
+  printf( "*** end of dijkstra benchmark ***\n" );
+  exit( 0 );
+}
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_heap/Makefile.am rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/Makefile.am
--- rtems-base/testsuites/mibench/dijkstra_small_heap/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/Makefile.am	2011-01-11 12:52:22.000000000 -0500
@@ -0,0 +1,26 @@
+##
+##  $Id$
+##
+
+MANAGERS = io semaphore
+
+rtems_tests_PROGRAMS = dijkstra_small_heap
+dijkstra_small_heap_SOURCES = init.c FileSystemImage.c
+
+#dist_rtems_tests_DATA = dijkstra_small_heap.scn
+#dist_rtems_tests_DATA += dijkstra_small_heap.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+dijkstra_small_heap_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+LINK_OBJS = $(dijkstra_small_heap_OBJECTS) $(dijkstra_small_heap_LDADD)
+LINK_LIBS = $(dijkstra_small_heap_LDLIBS)
+
+dijkstra_small_heap$(EXEEXT): $(dijkstra_small_heap_OBJECTS) $(dijkstra_small_heap_DEPENDENCIES)
+	@rm -f dijkstra_small_heap$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_heap/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/system.h
--- rtems-base/testsuites/mibench/dijkstra_small_heap/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_heap/system.h	2011-01-11 12:51:30.000000000 -0500
@@ -0,0 +1,51 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <rtems.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* fs includes */
+#include "FileSystemImage.h"
+#include <rtems/untar.h>
+
+/* functions */
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+#include <bsp.h> /* for device driver prototypes */
+
+/* drivers */
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+/* filesystem */
+#define CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM
+#define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
+#define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
+
+//#define CONFIGURE_STACK_CHECKER_ENABLED
+
+/* tasks */
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+//#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+
+#include <rtems/confdefs.h>
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_sort/init.c	2011-01-10 14:06:33.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort/init.c	2011-01-11 12:33:04.000000000 -0500
@@ -15,32 +15,25 @@
 
 #define CONFIGURE_INIT
 #include "system.h"
-
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  struct _NODE *qNext;
+  struct _NODE *qPrev;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
+typedef struct _NODE NODE;
 
+NODE *qHead = NULL;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -48,35 +41,45 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
-
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
+  int i = 0;
+  NODE *qLast = NULL;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    if (qNew->qNext) {
+      qNew->qNext->qPrev = qNew->qPrev;
+    }
+    if (qNew->qPrev) {
+      qNew->qPrev->qNext = qNew->qNext;
+    } else {
+      qHead = qNew->qNext;
     }
-  qNew->iNode = iNode;
+    g_qCount--;
+  }
+  
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
   qNew->qNext = NULL;
+  qNew->qPrev = NULL;
+  qNew->qFlag = 1;
 
+  qLast = qHead;
   // GAB: instead of tail-queueing, sort entries as a 
   // priority queue by the iDist.
   if (!qLast)
@@ -87,6 +90,7 @@ void enqueue (int iNode, int iDist, int 
   {
     qHead = qNew;
     qNew->qNext = qLast;
+    qLast->qPrev = qNew;
   }
   else
   {
@@ -95,30 +99,36 @@ void enqueue (int iNode, int iDist, int 
       qLast = qLast->qNext;
     }
     qNew->qNext = qLast->qNext;
+    qNew->qPrev = qLast;
+    if (qNew->qNext)
+      qNew->qNext->qPrev = qNew;
     qLast->qNext = qNew;
   }
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = qHead;
+  NODE *qKill = qHead;
 
-    if (qHead)
+  if (qHead)
     {
       //                 ASSERT(g_qCount);
       *piNode = qHead->iNode;
       *piDist = qHead->iDist;
       *piPrev = qHead->iPrev;
       qHead = qHead->qNext;
-      free(qKill);
+      if (qHead)
+        qHead->qPrev = NULL;
+      qKill->qNext = NULL;
+      qKill->qPrev = NULL;
+      qKill->qFlag = 0;
+//      free(qKill);
       g_qCount--;
     }
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -126,18 +136,22 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i;
   for (ch = 0; ch < NUM_NODES; ch++)
     {
+      rgnNodes[ch].iNode = ch;
       rgnNodes[ch].iDist = NONE;
       rgnNodes[ch].iPrev = NONE;
+      rgnNodes[ch].qPrev = NULL;
+      rgnNodes[ch].qNext = NULL;
+      rgnNodes[ch].qFlag = 0;
     }
 
   if (chStart == chEnd)
     {
-//      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#if defined(GAB_PRINT)
+      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
     }
   else
     {
@@ -163,24 +177,22 @@ int dijkstra(int chStart, int chEnd)
 		}
 	    }
 	}
-/*
+#if defined(GAB_PRINT)
       printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
       printf("Path is: ");
       print_path(rgnNodes, chEnd);
       printf("\n");
-*/
+#endif
     }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -188,18 +200,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c	2011-01-10 11:55:37.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/init.c	2011-02-13 13:16:36.000000000 -0500
@@ -17,29 +17,19 @@
 #include "system.h"
 #include <stdio.h>
 
+//#define GAB_PRINT
+
 #define NUM_NODES                          100
 #define NONE                               9999
 
 struct _NODE
 {
-  int iDist;
-  int iPrev;
-};
-typedef struct _NODE NODE;
-
-struct _QITEM
-{
   int iNode;
   int iDist;
   int iPrev;
-  struct _QITEM *qNext;
+  int qFlag;
 };
-typedef struct _QITEM QITEM;
-
-QITEM *qHead = NULL;
-
-
-
+typedef struct _NODE NODE;
 
 int AdjMatrix[NUM_NODES][NUM_NODES];
 
@@ -47,65 +37,40 @@ int g_qCount = 0;
 NODE rgnNodes[NUM_NODES];
 int ch;
 int iPrev, iNode;
-int i, iCost, iDist;
-
+int iCost, iDist;
 
 void print_path (NODE *rgnNodes, int chNode)
 {
+#if defined(GAB_PRINT)
   if (rgnNodes[chNode].iPrev != NONE)
     {
       print_path(rgnNodes, rgnNodes[chNode].iPrev);
     }
   printf (" %d", chNode);
   fflush(stdout);
+#endif
 }
 
-
 void enqueue (int iNode, int iDist, int iPrev)
 {
-  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
-  QITEM *qLast = qHead;
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    HWDS_EXTRACT ( 4, qNew );
+    g_qCount--;
+  }
 
-  if (!qNew)
-    {
-      fprintf(stderr, "Out of memory.\n");
-      exit(1);
-    }
-  qNew->iNode = iNode;
   qNew->iDist = iDist;
   qNew->iPrev = iPrev;
-  qNew->qNext = NULL;
-
+  qNew->qFlag = 1;
   HWDS_ENQUEUE ( 4, iDist, qNew );
-  /*
-  // GAB: instead of tail-queueing, sort entries as a 
-  // priority queue by the iDist.
-  if (!qLast)
-  {
-    qHead = qNew;
-  }
-  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
-  {
-    qHead = qNew;
-    qNew->qNext = qLast;
-  }
-  else
-  {
-    // already handled head case, find the Q element to insert qNew after.
-    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
-      qLast = qLast->qNext;
-    }
-    qNew->qNext = qLast->qNext;
-    qLast->qNext = qNew;
-  }*/
   g_qCount++;
   //               ASSERT(g_qCount);
 }
 
-
 void dequeue (int *piNode, int *piDist, int *piPrev)
 {
-  QITEM *qKill = NULL;// = qHead;
+  NODE *qKill = NULL;
 
   HWDS_FIRST( 4, qKill );
 
@@ -116,23 +81,11 @@ void dequeue (int *piNode, int *piDist, 
       *piDist = qKill->iDist;
       *piPrev = qKill->iPrev;
       HWDS_EXTRACT ( 4, qKill );
-      free(qKill);
-      g_qCount--;
-    }
-/*
-  if (qHead)
-    {
-      //                 ASSERT(g_qCount);
-      *piNode = qHead->iNode;
-      *piDist = qHead->iDist;
-      *piPrev = qHead->iPrev;
-      qHead = qHead->qNext;
-      free(qKill);
+      qKill->qFlag = 0;
       g_qCount--;
-    }*/
+    } 
 }
 
-
 int qcount (void)
 {
   return(g_qCount);
@@ -140,60 +93,61 @@ int qcount (void)
 
 int dijkstra(int chStart, int chEnd)
 {
-
-
-
+  int i = 0;
   for (ch = 0; ch < NUM_NODES; ch++)
-    {
-      rgnNodes[ch].iDist = NONE;
-      rgnNodes[ch].iPrev = NONE;
-    }
+  {
+    rgnNodes[ch].iNode = ch;
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+    rgnNodes[ch].qFlag = 0;
+  }
 
   if (chStart == chEnd)
-    {
-      printf("Shortest path is 0 in cost. Just stay where you are.\n");
-    }
+  {
+#if defined(GAB_PRINT)
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+  }
   else
-    {
-      rgnNodes[chStart].iDist = 0;
-      rgnNodes[chStart].iPrev = NONE;
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
 
-      enqueue (chStart, 0, NONE);
+    enqueue (chStart, 0, NONE);
 
-     while (qcount() > 0)
-	{
-	  dequeue (&iNode, &iDist, &iPrev);
-	  for (i = 0; i < NUM_NODES; i++)
-	    {
-	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
-		{
-		  if ((NONE == rgnNodes[i].iDist) ||
-		      (rgnNodes[i].iDist > (iCost + iDist)))
-		    {
-		      rgnNodes[i].iDist = iDist + iCost;
-		      rgnNodes[i].iPrev = iNode;
-		      enqueue (i, iDist + iCost, iNode);
-		    }
-		}
-	    }
-	}
-
-      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
-      printf("Path is: ");
-      print_path(rgnNodes, chEnd);
-      printf("\n");
-    }
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+          }
+        }
+      }
+    }
+#if defined(GAB_PRINT)
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+#endif
+  }
 }
 
-
-
 rtems_task Init(
   rtems_task_argument ignored
 )
 {
-
-
   char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
 
   printf("Unpacking tar filesystem\nThis may take awhile...\n");
   if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
@@ -201,18 +155,8 @@ rtems_task Init(
     exit(1);
   }
 
-  //FILE * fp= fopen(in_file,"w");
-  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
-  //fclose(fp);
-
-  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
-
-
   printf( "\n\n*** dijkstra benchmark ***\n" );
 
-  int i,j,k;
-  FILE *fp;
-
   /* open the adjacency matrix file */
   fp = fopen (in_file,"r");
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h	2011-01-10 13:12:25.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ/system.h	2011-01-11 12:05:47.000000000 -0500
@@ -31,7 +31,8 @@ rtems_task Init(
 #include <bsp.h> /* for device driver prototypes */
 
 /* drivers */
-#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
 #define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
 
 /* filesystem */
@@ -42,7 +43,8 @@ rtems_task Init(
 //#define CONFIGURE_STACK_CHECKER_ENABLED
 
 /* tasks */
-#define CONFIGURE_MAXIMUM_TASKS             4
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
 #define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/clean_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/clean_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/clean_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/clean_fs.sh	2011-02-13 13:14:08.000000000 -0500
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+rm FileSystemImage FileSystemImage.c FileSystemImage.h
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/generate_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/generate_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/generate_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/generate_fs.sh	2011-02-13 13:14:08.000000000 -0500
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# generate filesystem
+cd files
+tar -cvf ../FileSystemImage --exclude CVS --exclude .cvsignore --exclude .svn .
+cd ..
+rtems-bin2c FileSystemImage FileSystemImage
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/init.c	2011-03-19 14:43:50.000000000 -0400
@@ -0,0 +1,205 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is called from init_exec and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+#include <stdio.h>
+
+#define GAB_PRINT
+
+#define NUM_NODES                          100
+#define NONE                               9999
+
+struct _NODE
+{
+  int iNode;
+  int iDist;
+  int iPrev;
+  int qFlag;
+};
+typedef struct _NODE NODE;
+
+int AdjMatrix[NUM_NODES][NUM_NODES];
+
+int g_qCount = 0;
+NODE rgnNodes[NUM_NODES];
+int ch;
+int iPrev, iNode;
+int iCost, iDist;
+
+void print_path (NODE *rgnNodes, int chNode)
+{
+#if defined(GAB_PRINT)
+  if (rgnNodes[chNode].iPrev != NONE)
+    {
+      print_path(rgnNodes, rgnNodes[chNode].iPrev);
+    }
+  printf (" %d", chNode);
+  fflush(stdout);
+#endif
+}
+
+void enqueue (int iNode, int iDist, int iPrev)
+{
+  NODE *qNew = &rgnNodes[iNode];
+
+  if (qNew->qFlag) {
+    HWDS_EXTRACT ( 4, qNew );
+    g_qCount--;
+  }
+
+  qNew->iDist = iDist;
+  qNew->iPrev = iPrev;
+  qNew->qFlag = 1;
+  HWDS_ENQUEUE ( 4, iDist, qNew );
+  g_qCount++;
+  //               ASSERT(g_qCount);
+}
+
+void dequeue (int *piNode, int *piDist, int *piPrev)
+{
+  NODE *qKill = NULL;
+
+  HWDS_FIRST( 4, qKill );
+
+  if (qKill)
+    {
+      //                 ASSERT(g_qCount);
+      *piNode = qKill->iNode;
+      *piDist = qKill->iDist;
+      *piPrev = qKill->iPrev;
+      HWDS_EXTRACT ( 4, qKill );
+      qKill->qFlag = 0;
+      g_qCount--;
+    } 
+}
+
+int qcount (void)
+{
+  return(g_qCount);
+}
+
+int dijkstra(int chStart, int chEnd)
+{
+  int i = 0;
+  for (ch = 0; ch < NUM_NODES; ch++)
+  {
+    rgnNodes[ch].iNode = ch;
+    rgnNodes[ch].iDist = NONE;
+    rgnNodes[ch].iPrev = NONE;
+    rgnNodes[ch].qFlag = 0;
+  }
+
+  if (chStart == chEnd)
+  {
+#if defined(GAB_PRINT)
+    printf("Shortest path is 0 in cost. Just stay where you are.\n");
+#endif
+  }
+  else
+  {
+    rgnNodes[chStart].iDist = 0;
+    rgnNodes[chStart].iPrev = NONE;
+
+    enqueue (chStart, 0, NONE);
+
+    while (qcount() > 0)
+    {
+      dequeue (&iNode, &iDist, &iPrev);
+      for (i = 0; i < NUM_NODES; i++)
+      {
+        if ((iCost = AdjMatrix[iNode][i]) != NONE)
+        {
+          if ((NONE == rgnNodes[i].iDist) ||
+              (rgnNodes[i].iDist > (iCost + iDist)))
+          {
+            rgnNodes[i].iDist = iDist + iCost;
+            rgnNodes[i].iPrev = iNode;
+            enqueue (i, iDist + iCost, iNode);
+        /*    if (qcount() == NUM_NODES-1) {
+              ///FIXME: These are not quite right. For now, spill by hand?
+              //HWDS_SPILL( 4 );
+              //HWDS_FILL( 4 );
+              int j = 0;
+              int qop = (4<<20)|7;
+              for( j = 0; j < qcount(); j++) {
+                HWDS_REGOP(j, qop);
+              }
+              qop = (4<<20)|8;
+              for( j = 0; j < qcount(); j++) {
+                HWDS_REGOP(j, qop);
+              }
+            }
+            */
+          }
+        }
+      }
+    }
+#if defined(GAB_PRINT)
+    printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+    printf("Path is: ");
+    print_path(rgnNodes, chEnd);
+    printf("\n");
+#endif
+  }
+}
+
+rtems_task Init(
+  rtems_task_argument ignored
+)
+{
+  char in_file[20] = "/input.dat";
+  int i,j,k;
+  FILE *fp;
+  char *spill_base = NULL;
+
+  printf("Unpacking tar filesystem\nThis may take awhile...\n");
+  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
+    printf("Can't unpack tar filesystem\n");
+    exit(1);
+  }
+
+  printf( "\n\n*** dijkstra benchmark ***\n" );
+
+  /* open the adjacency matrix file */
+  fp = fopen (in_file,"r");
+
+  /* make a fully connected matrix */
+  for (i=0;i<NUM_NODES;i++) {
+    for (j=0;j<NUM_NODES;j++) {
+      /* make it more sparce */
+      fscanf(fp,"%d",&k);
+			AdjMatrix[i][j]= k;
+    }
+  }
+
+  /* allocate space for spill region, based on the queue capacity. */
+  /* for now just estimate the size needed as 64 bits for a pointer and
+   * 32 bits for an integer (priority) per element in the queue */
+  spill_base = malloc(NUM_NODES * (8+4));
+
+  asm volatile("break_start_opal:");
+  HWDS_SETRANGE( 4, spill_base, NUM_NODES * (8+4) );
+  /* finds 10 shortest paths between nodes */
+  for (i=0,j=NUM_NODES/2;i<20;i++,j++) {
+			j=j%NUM_NODES;
+      dijkstra(i,j);
+  }
+  MAGIC_BREAKPOINT;
+
+  printf( "*** end of dijkstra benchmark ***\n" );
+  exit( 0 );
+}
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/Makefile.am rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/Makefile.am
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/Makefile.am	2011-02-13 13:17:33.000000000 -0500
@@ -0,0 +1,26 @@
+##
+##  $Id$
+##
+
+MANAGERS = io semaphore
+
+rtems_tests_PROGRAMS = dijkstra_small_sort_HWPQ_spill
+dijkstra_small_sort_HWPQ_spill_SOURCES = init.c FileSystemImage.c
+
+#dist_rtems_tests_DATA = dijkstra_small_sort_HWPQ_spill.scn
+#dist_rtems_tests_DATA += dijkstra_small_sort_HWPQ_spill.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+dijkstra_small_sort_HWPQ_spill_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+LINK_OBJS = $(dijkstra_small_sort_HWPQ_spill_OBJECTS) $(dijkstra_small_sort_HWPQ_spill_LDADD)
+LINK_LIBS = $(dijkstra_small_sort_HWPQ_spill_LDLIBS)
+
+dijkstra_small_sort_HWPQ_spill$(EXEEXT): $(dijkstra_small_sort_HWPQ_spill_OBJECTS) $(dijkstra_small_sort_HWPQ_spill_DEPENDENCIES)
+	@rm -f dijkstra_small_sort_HWPQ_spill$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/system.h
--- rtems-base/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_HWPQ_spill/system.h	2011-02-13 13:14:08.000000000 -0500
@@ -0,0 +1,51 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <rtems.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* fs includes */
+#include "FileSystemImage.h"
+#include <rtems/untar.h>
+
+/* functions */
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+#include <bsp.h> /* for device driver prototypes */
+
+/* drivers */
+//#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+/* filesystem */
+#define CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM
+#define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
+#define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
+
+//#define CONFIGURE_STACK_CHECKER_ENABLED
+
+/* tasks */
+//#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_MAXIMUM_TASKS             1
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+
+#include <rtems/confdefs.h>
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/clean_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/clean_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/clean_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/clean_fs.sh	2011-01-10 12:53:36.000000000 -0500
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+rm FileSystemImage FileSystemImage.c FileSystemImage.h
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/generate_fs.sh rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/generate_fs.sh
--- rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/generate_fs.sh	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/generate_fs.sh	2011-01-10 12:53:36.000000000 -0500
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+# generate filesystem
+cd files
+tar -cvf ../FileSystemImage --exclude CVS --exclude .cvsignore --exclude .svn .
+cd ..
+rtems-bin2c FileSystemImage FileSystemImage
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/init.c rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/init.c
--- rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/init.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/init.c	2011-01-10 14:07:28.000000000 -0500
@@ -0,0 +1,226 @@
+/*  Init
+ *
+ *  This routine is the initialization task for this test program.
+ *  It is called from init_exec and has the responsibility for creating
+ *  and starting the tasks that make up the test.  If the time of day
+ *  clock is required for the test, it should also be set to a known
+ *  value by this function.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  $Id$
+ */
+
+#define CONFIGURE_INIT
+#include "system.h"
+
+#include <stdio.h>
+
+#define NUM_NODES                          100
+#define NONE                               9999
+
+struct _NODE
+{
+  int iDist;
+  int iPrev;
+};
+typedef struct _NODE NODE;
+
+struct _QITEM
+{
+  int iNode;
+  int iDist;
+  int iPrev;
+  struct _QITEM *qNext;
+};
+typedef struct _QITEM QITEM;
+
+QITEM *qHead = NULL;
+
+
+
+
+int AdjMatrix[NUM_NODES][NUM_NODES];
+
+int g_qCount = 0;
+NODE rgnNodes[NUM_NODES];
+int ch;
+int iPrev, iNode;
+int i, iCost, iDist;
+
+
+void print_path (NODE *rgnNodes, int chNode)
+{
+  if (rgnNodes[chNode].iPrev != NONE)
+    {
+      print_path(rgnNodes, rgnNodes[chNode].iPrev);
+    }
+  printf (" %d", chNode);
+  fflush(stdout);
+}
+
+
+void enqueue (int iNode, int iDist, int iPrev)
+{
+  QITEM *qNew = (QITEM *) malloc(sizeof(QITEM));
+  QITEM *qLast = qHead;
+
+  if (!qNew)
+    {
+      fprintf(stderr, "Out of memory.\n");
+      exit(1);
+    }
+  qNew->iNode = iNode;
+  qNew->iDist = iDist;
+  qNew->iPrev = iPrev;
+  qNew->qNext = NULL;
+
+  // GAB: instead of tail-queueing, sort entries as a 
+  // priority queue by the iDist.
+  if (!qLast)
+  {
+    qHead = qNew;
+  }
+  else if (qLast->iDist > qNew->iDist) // new case to handle head's priority
+  {
+    qHead = qNew;
+    qNew->qNext = qLast;
+  }
+  else
+  {
+    // already handled head case, find the Q element to insert qNew after.
+    while (qLast->qNext && qLast->qNext->iDist <= qNew->iDist) {
+      qLast = qLast->qNext;
+    }
+    qNew->qNext = qLast->qNext;
+    qLast->qNext = qNew;
+  }
+  g_qCount++;
+  //               ASSERT(g_qCount);
+}
+
+
+void dequeue (int *piNode, int *piDist, int *piPrev)
+{
+  QITEM *qKill = qHead;
+
+  if (qHead)
+    {
+      //                 ASSERT(g_qCount);
+      *piNode = qHead->iNode;
+      *piDist = qHead->iDist;
+      *piPrev = qHead->iPrev;
+      qHead = qHead->qNext;
+      free(qKill);
+      g_qCount--;
+    }
+}
+
+
+int qcount (void)
+{
+  return(g_qCount);
+}
+
+int dijkstra(int chStart, int chEnd)
+{
+
+
+
+  for (ch = 0; ch < NUM_NODES; ch++)
+    {
+      rgnNodes[ch].iDist = NONE;
+      rgnNodes[ch].iPrev = NONE;
+    }
+
+  if (chStart == chEnd)
+    {
+//      printf("Shortest path is 0 in cost. Just stay where you are.\n");
+    }
+  else
+    {
+      rgnNodes[chStart].iDist = 0;
+      rgnNodes[chStart].iPrev = NONE;
+
+      enqueue (chStart, 0, NONE);
+
+     while (qcount() > 0)
+	{
+	  dequeue (&iNode, &iDist, &iPrev);
+	  for (i = 0; i < NUM_NODES; i++)
+	    {
+	      if ((iCost = AdjMatrix[iNode][i]) != NONE)
+		{
+		  if ((NONE == rgnNodes[i].iDist) ||
+		      (rgnNodes[i].iDist > (iCost + iDist)))
+		    {
+		      rgnNodes[i].iDist = iDist + iCost;
+		      rgnNodes[i].iPrev = iNode;
+		      enqueue (i, iDist + iCost, iNode);
+		    }
+		}
+	    }
+	}
+/*
+      printf("Shortest path is %d in cost. ", rgnNodes[chEnd].iDist);
+      printf("Path is: ");
+      print_path(rgnNodes, chEnd);
+      printf("\n");
+*/
+    }
+}
+
+
+
+rtems_task Init(
+  rtems_task_argument ignored
+)
+{
+
+
+  char in_file[20] = "/input.dat";
+
+  printf("Unpacking tar filesystem\nThis may take awhile...\n");
+  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
+    printf("Can't unpack tar filesystem\n");
+    exit(1);
+  }
+
+  //FILE * fp= fopen(in_file,"w");
+  //int  n = fwrite(FileSystemImage + 0x400,1, FileSystemImage_size - 0x400, fp);
+  //fclose(fp);
+
+  //printf( "Wrote: intended=%d wrote=%d error=%d\n",FileSystemImage_size - 0x400, n,errno);
+
+
+  printf( "\n\n*** dijkstra benchmark ***\n" );
+
+  int i,j,k;
+  FILE *fp;
+
+  /* open the adjacency matrix file */
+  fp = fopen (in_file,"r");
+
+  /* make a fully connected matrix */
+  for (i=0;i<NUM_NODES;i++) {
+    for (j=0;j<NUM_NODES;j++) {
+      /* make it more sparce */
+      fscanf(fp,"%d",&k);
+			AdjMatrix[i][j]= k;
+    }
+  }
+
+  asm volatile("break_start_opal:");
+  /* finds 10 shortest paths between nodes */
+  for (i=0,j=NUM_NODES/2;i<20;i++,j++) {
+			j=j%NUM_NODES;
+      dijkstra(i,j);
+  }
+  MAGIC_BREAKPOINT;
+
+  printf( "*** end of dijkstra benchmark ***\n" );
+  exit( 0 );
+}
+
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/Makefile.am rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/Makefile.am
--- rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/Makefile.am	2011-01-10 12:53:36.000000000 -0500
@@ -0,0 +1,26 @@
+##
+##  $Id$
+##
+
+MANAGERS = io semaphore
+
+rtems_tests_PROGRAMS = dijkstra_small_sort_OSPQ
+dijkstra_small_sort_OSPQ_SOURCES = init.c FileSystemImage.c
+
+#dist_rtems_tests_DATA = dijkstra_small_sort_OSPQ.scn
+#dist_rtems_tests_DATA += dijkstra_small_sort_OSPQ.doc
+
+include $(RTEMS_ROOT)/make/custom/@RTEMS_BSP@.cfg
+include $(top_srcdir)/../automake/compile.am
+include $(top_srcdir)/../automake/leaf.am
+
+dijkstra_small_sort_OSPQ_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
+
+LINK_OBJS = $(dijkstra_small_sort_OSPQ_OBJECTS) $(dijkstra_small_sort_OSPQ_LDADD)
+LINK_LIBS = $(dijkstra_small_sort_OSPQ_LDLIBS)
+
+dijkstra_small_sort_OSPQ$(EXEEXT): $(dijkstra_small_sort_OSPQ_OBJECTS) $(dijkstra_small_sort_OSPQ_DEPENDENCIES)
+	@rm -f dijkstra_small_sort_OSPQ$(EXEEXT)
+	$(make-exe)
+
+include $(top_srcdir)/../automake/local.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/system.h rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/system.h
--- rtems-base/testsuites/mibench/dijkstra_small_sort_OSPQ/system.h	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/dijkstra_small_sort_OSPQ/system.h	2011-01-10 13:11:37.000000000 -0500
@@ -0,0 +1,49 @@
+/*  system.h
+ *
+ *  This include file contains information that is included in every
+ *  function in the test set.
+ *
+ *  COPYRIGHT (c) 1989-2009.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id$
+ */
+
+#include <rtems.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/* fs includes */
+#include "FileSystemImage.h"
+#include <rtems/untar.h>
+
+/* functions */
+rtems_task Init(
+  rtems_task_argument argument
+);
+
+/* configuration information */
+#include <bsp.h> /* for device driver prototypes */
+
+/* drivers */
+#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER
+#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
+
+/* filesystem */
+#define CONFIGURE_USE_IMFS_AS_BASE_FILESYSTEM
+#define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
+#define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
+
+//#define CONFIGURE_STACK_CHECKER_ENABLED
+
+/* tasks */
+#define CONFIGURE_MAXIMUM_TASKS             4
+#define CONFIGURE_RTEMS_INIT_TASKS_TABLE
+#define CONFIGURE_EXTRA_TASK_STACKS         (3 * RTEMS_MINIMUM_STACK_SIZE)
+
+#include <rtems/confdefs.h>
diff -X dontdiff -uprN rtems-base/testsuites/mibench/LICENSE rtems-hwpq-dev/testsuites/mibench/LICENSE
--- rtems-base/testsuites/mibench/LICENSE	2011-01-30 18:50:53.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/LICENSE	2011-01-10 12:53:36.000000000 -0500
@@ -1,2 +1 @@
-See the individual LICENSE files.
-
+MIBench is under GPL.
diff -X dontdiff -uprN rtems-base/testsuites/mibench/Makefile.am rtems-hwpq-dev/testsuites/mibench/Makefile.am
--- rtems-base/testsuites/mibench/Makefile.am	2011-01-30 19:12:03.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/Makefile.am	2011-02-13 13:15:02.000000000 -0500
@@ -4,14 +4,13 @@
 
 ACLOCAL_AMFLAGS = -I ../aclocal
 
-SUBDIRS = basicmath_large basicmath_small bitcount_large bitcount_small \
-					crc dijkstra \
-					fft_small fft_large fftinv_small fftinv_large \
-					qsort_small rijndael_small sha_small \
-					stringsearch_large stringsearch_small \
-					susan_corners susan_edges susan_smoothing
-#	dijkstra_small_sort dijkstra_large_sort \
-#	dijkstra_small_sort_HWPQ dijkstra_large_sort_HWPQ
+SUBDIRS = sha_small sha_large crc dijkstra susan_smoothing \
+					dijkstra_large_sort_HWPQ dijkstra_large_sort_OSPQ \
+					dijkstra_small_sort_HWPQ dijkstra_small_sort_OSPQ \
+					dijkstra_small_sort_HWPQ_spill \
+					dijkstra_small_sort dijkstra_large_sort \
+					dijkstra_small_heap dijkstra_large_heap \
+					dijkstra_small_3_heap
 
 if MPTESTS
 endif
@@ -20,7 +19,6 @@ if CXXTESTS
 endif
 
 if NETTESTS
-SUBDIRS += patricia_small
 endif
 
 include $(top_srcdir)/../automake/subdirs.am
diff -X dontdiff -uprN rtems-base/testsuites/mibench/sha_large/LICENSE rtems-hwpq-dev/testsuites/mibench/sha_large/LICENSE
--- rtems-base/testsuites/mibench/sha_large/LICENSE	2011-01-30 18:56:06.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/sha_large/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-/* NIST Secure Hash Algorithm */
-/* heavily modified by Uwe Hollerbach uh@alumni.caltech edu */
-/* from Peter C. Gutmann's implementation as found in */
-/* Applied Cryptography by Bruce Schneier */
-
-/* NIST's proposed modification to SHA of 7/11/94 may be */
-/* activated by defining USE_MODIFIED_SHA */
-
diff -X dontdiff -uprN rtems-base/testsuites/mibench/sha_small/LICENSE rtems-hwpq-dev/testsuites/mibench/sha_small/LICENSE
--- rtems-base/testsuites/mibench/sha_small/LICENSE	2011-01-30 18:55:55.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/sha_small/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-/* NIST Secure Hash Algorithm */
-/* heavily modified by Uwe Hollerbach uh@alumni.caltech edu */
-/* from Peter C. Gutmann's implementation as found in */
-/* Applied Cryptography by Bruce Schneier */
-
-/* NIST's proposed modification to SHA of 7/11/94 may be */
-/* activated by defining USE_MODIFIED_SHA */
-
diff -X dontdiff -uprN rtems-base/testsuites/mibench/sha_small/sha.h rtems-hwpq-dev/testsuites/mibench/sha_small/sha.h
--- rtems-base/testsuites/mibench/sha_small/sha.h	2011-01-30 19:22:36.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/sha_small/sha.h	2011-01-10 12:53:36.000000000 -0500
@@ -7,7 +7,7 @@
 /* Useful defines & typedefs */
 
 typedef unsigned char BYTE;
-typedef unsigned int LONG;
+typedef unsigned long LONG;
 
 #define SHA_BLOCKSIZE		64
 #define SHA_DIGESTSIZE		20
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_corners/init.c rtems-hwpq-dev/testsuites/mibench/susan_corners/init.c
--- rtems-base/testsuites/mibench/susan_corners/init.c	2011-02-01 15:01:07.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_corners/init.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,2165 +0,0 @@
-/* {{{ Copyright etc. */
-
-/**********************************************************************\
-
-  SUSAN Version 2l by Stephen Smith
-  Oxford Centre for Functional Magnetic Resonance Imaging of the Brain,
-  Department of Clinical Neurology, Oxford University, Oxford, UK
-  (Previously in Computer Vision and Image Processing Group - now
-  Computer Vision and Electro Optics Group - DERA Chertsey, UK)
-  Email:    steve@fmrib.ox.ac.uk
-  WWW:      http://www.fmrib.ox.ac.uk/~steve
-
-  (C) Crown Copyright (1995-1999), Defence Evaluation and Research Agency,
-  Farnborough, Hampshire, GU14 6TD, UK
-  DERA WWW site:
-  http://www.dera.gov.uk/
-  DERA Computer Vision and Electro Optics Group WWW site:
-  http://www.dera.gov.uk/imageprocessing/dera/group_home.html
-  DERA Computer Vision and Electro Optics Group point of contact:
-  Dr. John Savage, jtsavage@dera.gov.uk, +44 1344 633203
-
-  A UK patent has been granted: "Method for digitally processing
-  images to determine the position of edges and/or corners therein for
-  guidance of unmanned vehicle", UK Patent 2272285. Proprietor:
-  Secretary of State for Defence, UK. 15 January 1997
-
-  This code is issued for research purposes only and remains the
-  property of the UK Secretary of State for Defence. This code must
-  not be passed on without this header information being kept
-  intact. This code must not be sold.
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ Readme First */
-
-/**********************************************************************\
-
-  SUSAN Version 2l
-  SUSAN = Smallest Univalue Segment Assimilating Nucleus
-
-  Email:    steve@fmrib.ox.ac.uk
-  WWW:      http://www.fmrib.ox.ac.uk/~steve
-
-  Related paper:
-  @article{Smith97,
-        author = "Smith, S.M. and Brady, J.M.",
-        title = "{SUSAN} - A New Approach to Low Level Image Processing",
-        journal = "Int. Journal of Computer Vision",
-        pages = "45--78",
-        volume = "23",
-        number = "1",
-        month = "May",
-        year = 1997}
-
-  To be registered for automatic (bug) updates of SUSAN, send an email.
-
-  Compile with:
-  gcc -O4 -o susan susan2l.c -lm
-
-  See following section for different machine information. Please
-  report any bugs (and fixes). There are a few optional changes that
-  can be made in the "defines" section which follows shortly.
-
-  Usage: type "susan" to get usage. Only PGM format files can be input
-  and output. Utilities such as the netpbm package and XV can be used
-  to convert to and from other formats. Any size of image can be
-  processed.
-
-  This code is written using an emacs folding mode, making moving
-  around the different sections very easy. This is why there are
-  various marks within comments and why comments are indented.
-
-
-  SUSAN QUICK:
-
-  This version of the SUSAN corner finder does not do all the
-  false-corner suppression and thus is faster and produced some false
-  positives, particularly on strong edges. However, because there are
-  less stages involving thresholds etc., the corners that are
-  correctly reported are usually more stable than those reported with
-  the full algorithm. Thus I recommend at least TRYING this algorithm
-  for applications where stability is important, e.g., tracking.
-
-  THRESHOLDS:
-
-  There are two thresholds which can be set at run-time. These are the
-  brightness threshold (t) and the distance threshold (d).
-
-  SPATIAL CONTROL: d
-
-  In SUSAN smoothing d controls the size of the Gaussian mask; its
-  default is 4.0. Increasing d gives more smoothing. In edge finding,
-  a fixed flat mask is used, either 37 pixels arranged in a "circle"
-  (default), or a 3 by 3 mask which gives finer detail. In corner
-  finding, only the larger 37 pixel mask is used; d is not
-  variable. In smoothing, the flat 3 by 3 mask can be used instead of
-  a larger Gaussian mask; this gives low smoothing and fast operation.
-
-  BRIGHTNESS CONTROL: t
-
-  In all three algorithms, t can be varied (default=20); this is the
-  main threshold to be varied. It determines the maximum difference in
-  greylevels between two pixels which allows them to be considered
-  part of the same "region" in the image. Thus it can be reduced to
-  give more edges or corners, i.e. to be more sensitive, and vice
-  versa. In smoothing, reducing t gives less smoothing, and vice
-  versa. Set t=10 for the test image available from the SUSAN web
-  page.
-
-  ITERATIONS:
-
-  With SUSAN smoothing, more smoothing can also be obtained by
-  iterating the algorithm several times. This has a different effect
-  from varying d or t.
-
-  FIXED MASKS:
-
-  37 pixel mask:    ooo       3 by 3 mask:  ooo
-                   ooooo                    ooo
-                  ooooooo                   ooo
-                  ooooooo
-                  ooooooo
-                   ooooo
-                    ooo
-
-  CORNER ATTRIBUTES dx, dy and I
-  (Only read this if you are interested in the C implementation or in
-  using corner attributes, e.g., for corner matching)
-
-  Corners reported in the corner list have attributes associated with
-  them as well as positions. This is useful, for example, when
-  attempting to match corners from one image to another, as these
-  attributes can often be fairly unchanged between images. The
-  attributes are dx, dy and I. I is the value of image brightness at
-  the position of the corner. In the case of susan_corners_quick, dx
-  and dy are the first order derivatives (differentials) of the image
-  brightness in the x and y directions respectively, at the position
-  of the corner. In the case of normal susan corner finding, dx and dy
-  are scaled versions of the position of the centre of gravity of the
-  USAN with respect to the centre pixel (nucleus).
-
-  BRIGHTNESS FUNCTION LUT IMPLEMENTATION:
-  (Only read this if you are interested in the C implementation)
-
-  The SUSAN brightness function is implemented as a LUT
-  (Look-Up-Table) for speed. The resulting pointer-based code is a
-  little hard to follow, so here is a brief explanation. In
-  setup_brightness_lut() the LUT is setup. This mallocs enough space
-  for *bp and then repositions the pointer to the centre of the
-  malloced space. The SUSAN function e^-(x^6) or e^-(x^2) is
-  calculated and converted to a uchar in the range 0-100, for all
-  possible image brightness differences (including negative
-  ones). Thus bp[23] is the output for a brightness difference of 23
-  greylevels. In the SUSAN algorithms this LUT is used as follows:
-
-  p=in + (i-3)*x_size + j - 1;
-  p points to the first image pixel in the circular mask surrounding
-  point (x,y).
-
-  cp=bp + in[i*x_size+j];
-  cp points to a position in the LUT corresponding to the brightness
-  of the centre pixel (x,y).
-
-  now for every pixel within the mask surrounding (x,y),
-  n+=*(cp-*p++);
-  the brightness difference function is found by moving the cp pointer
-  down by an amount equal to the value of the pixel pointed to by p,
-  thus subtracting the two brightness values and performing the
-  exponential function. This value is added to n, the running USAN
-  area.
-
-  in SUSAN smoothing, the variable height mask is implemented by
-  multiplying the above by the moving mask pointer, reset for each new
-  centre pixel.
-  tmp = *dpt++ * *(cp-brightness);
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ Machine Information */
-
-/**********************************************************************\
-
-  Success has been reported with the following:
-
-  MACHINE  OS         COMPILER
-
-  Sun      4.1.4      bundled C, gcc
-
-  Next
-
-  SGI      IRIX       SGI cc
-
-  DEC      Unix V3.2+
-
-  IBM RISC AIX        gcc
-
-  PC                  Borland 5.0
-
-  PC       Linux      gcc-2.6.3
-
-  PC       Win32      Visual C++ 4.0 (Console Application)
-
-  PC       Win95      Visual C++ 5.0 (Console Application)
-                      Thanks to Niu Yongsheng <niuysbit@163.net>:
-                      Use the FOPENB option below
-
-  PC       DOS        djgpp gnu C
-                      Thanks to Mark Pettovello <mpettove@umdsun2.umd.umich.edu>:
-                      Use the FOPENB option below
-
-  HP       HP-UX      bundled cc
-                      Thanks to Brian Dixon <briand@hpcvsgen.cv.hp.com>:
-                      in ksh:
-                      export CCOPTS="-Aa -D_HPUX_SOURCE | -lM"
-                      cc -O3 -o susan susan2l.c
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ History */
-
-/**********************************************************************\
-
-  SUSAN Version 2l, 12/2/99
-  Changed GNUDOS option to FOPENB.
-  (Thanks to Niu Yongsheng <niuysbit@163.net>.)
-  Took out redundant "sq=sq/2;".
-
-  SUSAN Version 2k, 19/8/98:
-  In corner finding:
-  Changed if(yy<sq) {...} else if(xx<sq) {...} to
-          if(yy<xx) {...} else {...}
-  (Thanks to adq@cim.mcgill.edu - Alain Domercq.)
-
-  SUSAN Version 2j, 22/10/97:
-  Fixed (mask_size>x_size) etc. tests in smoothing.
-  Added a couple of free() calls for cgx and cgy.
-  (Thanks to geoffb@ucs.ed.ac.uk - Geoff Browitt.)
-
-  SUSAN Version 2i, 21/7/97:
-  Added information about corner attributes.
-
-  SUSAN Version 2h, 16/12/96:
-  Added principle (initial enhancement) option.
-
-  SUSAN Version 2g, 2/7/96:
-  Minor superficial changes to code.
-
-  SUSAN Version 2f, 16/1/96:
-  Added GNUDOS option (now called FOPENB; see options below).
-
-  SUSAN Version 2e, 9/1/96:
-  Added -b option.
-  Fixed 1 pixel horizontal offset error for drawing edges.
-
-  SUSAN Version 2d, 27/11/95:
-  Fixed loading of certain PGM files in get_image (again!)
-
-  SUSAN Version 2c, 22/11/95:
-  Fixed loading of certain PGM files in get_image.
-  (Thanks to qu@San-Jose.ate.slb.com - Gongyuan Qu.)
-
-  SUSAN Version 2b, 9/11/95:
-  removed "z==" error in edges routines.
-
-  SUSAN Version 2a, 6/11/95:
-  Removed a few unnecessary variable declarations.
-  Added different machine information.
-  Changed "header" in get_image to char.
-
-  SUSAN Version 2, 1/11/95: first combined version able to take any
-  image sizes.
-
-  SUSAN "Versions 1", circa 1992: the various SUSAN algorithms were
-  developed during my doctorate within different programs and for
-  fixed image sizes. The algorithms themselves are virtually unaltered
-  between "versions 1" and the combined program, version 2.
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ defines, includes and typedefs */
-
-/* ********** Optional settings */
-
-#define CONFIGURE_INIT
-#include "system.h"
-
-#ifndef PPC
-typedef int        TOTAL_TYPE; /* this is faster for "int" but should be "float" for large d masks */
-#else
-typedef float      TOTAL_TYPE; /* for my PowerPC accelerator only */
-#endif
-
-/*#define FOPENB*/           /* uncomment if using djgpp gnu C for DOS or certain Win95 compilers */
-#define SEVEN_SUPP           /* size for non-max corner suppression; SEVEN_SUPP or FIVE_SUPP */
-#define MAX_CORNERS   15000  /* max corners per frame */
-
-/* ********** Leave the rest - but you may need to remove one or both of sys/file.h and malloc.h lines */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#define  exit_error(IFB,IFC) { fprintf(stderr,IFB,IFC); exit(0); }
-#define  FTOI(a) ( (a) < 0 ? ((int)(a-0.5)) : ((int)(a+0.5)) )
-typedef  unsigned char uchar;
-typedef  struct {int x,y,info, dx, dy, I;} CORNER_LIST[MAX_CORNERS];
-
-/* }}} */
-/* {{{ usage() */
-
-usage()
-{
-  printf("Usage: susan <in.pgm> <out.pgm> [options]\n\n");
-
-  printf("-s : Smoothing mode (default)\n");
-  printf("-e : Edges mode\n");
-  printf("-c : Corners mode\n\n");
-
-  printf("See source code for more information about setting the thresholds\n");
-  printf("-t <thresh> : Brightness threshold, all modes (default=20)\n");
-  printf("-d <thresh> : Distance threshold, smoothing mode, (default=4) (use next option instead for flat 3x3 mask)\n");
-  printf("-3 : Use flat 3x3 mask, edges or smoothing mode\n");
-  printf("-n : No post-processing on the binary edge map (runs much faster); edges mode\n");
-  printf("-q : Use faster (and usually stabler) corner mode; edge-like corner suppression not carried out; corners mode\n");
-  printf("-b : Mark corners/edges with single black points instead of black with white border; corners or edges mode\n");
-  printf("-p : Output initial enhancement image only; corners or edges mode (default is edges mode)\n");
-
-  printf("\nSUSAN Version 2l (C) 1995-1997 Stephen Smith, DRA UK. steve@fmrib.ox.ac.uk\n");
-
-  exit(0);
-}
-
-/* }}} */
-/* {{{ get_image(filename,in,x_size,y_size) */
-
-/* {{{ int getint(fp) derived from XV */
-
-int getint(fd)
-  FILE *fd;
-{
-  char c;
-  int i = 0;
-  char dummy[10000];
-
-  c = getc(fd);
-  while (1) /* find next integer */
-  {
-    if (c=='#')    /* if we're at a comment, read to end of line */
-      //fgets(dummy,9000,fd);
-      while(c != '\n' && i<100)
-      	{
-			c = getc(fd);
-			//printf("%d",i);
-			i++;
-		}
-    if (c==EOF)
-      exit_error("Image %s not binary PGM.\n","is");
-    if (c>='0' && c<='9')
-      break;   /* found what we were looking for */
-    c = getc(fd);
-  }
-
-  /* we're at the start of a number, continue until we hit a non-number */
-  i = 0;
-  while (1) {
-    i = (i*10) + (c - '0');
-    c = getc(fd);
-    if (c==EOF) return (i);
-    if (c<'0' || c>'9') break;
-  }
-
-  return (i);
-}
-
-/* }}} */
-
-void get_image(filename,in,x_size,y_size)
-  char           filename[200];
-  unsigned char  **in;
-  int            *x_size, *y_size;
-{
-FILE  *fd;
-char header [100];
-int  tmp;
-
-printf("in get_image\n");
-
-#ifdef FOPENB
-  if ((fd=fopen(filename,"rb")) == NULL)
-#else
-  if ((fd=fopen(filename,"r")) == NULL)
-#endif
-    exit_error("Can't input image %s.\n",filename);
-
-  /* {{{ read header */
-
-printf("get_image: read header\n");
-
-  header[0]=fgetc(fd);
-  header[1]=fgetc(fd);
-  if(!(header[0]=='P' && header[1]=='5'))
-    exit_error("Image %s does not have binary PGM header.\n",filename);
-
-  *x_size = getint(fd);
-  *y_size = getint(fd);
-  tmp = getint(fd);
-
-/* }}} */
-
-printf("get_image: read header %d %d \n",*x_size,*y_size);
-
-  *in = (uchar *) malloc(*x_size * *y_size);
-
-  if (fread(*in,1,*x_size * *y_size,fd) == 0)
-    exit_error("Image %s is wrong size.\n",filename);
-
-  fclose(fd);
-}
-
-/* }}} */
-/* {{{ put_image(filename,in,x_size,y_size) */
-
-put_image(filename,in,x_size,y_size)
-  char filename [100],
-       *in;
-  int  x_size,
-       y_size;
-{
-FILE  *fd;
-
-#ifdef FOPENB
-  if ((fd=fopen(filename,"wb")) == NULL)
-#else
-  if ((fd=fopen(filename,"w")) == NULL)
-#endif
-    exit_error("Can't output image%s.\n",filename);
-
-  fprintf(fd,"P5\n");
-  fprintf(fd,"%d %d\n",x_size,y_size);
-  fprintf(fd,"255\n");
-
-  if (fwrite(in,x_size*y_size,1,fd) != 1)
-    exit_error("Can't write image %s.\n",filename);
-
-  fclose(fd);
-}
-
-/* }}} */
-/* {{{ int_to_uchar(r,in,size) */
-
-int_to_uchar(r,in,size)
-  uchar *in;
-  int   *r, size;
-{
-int i,
-    max_r=r[0],
-    min_r=r[0];
-
-  for (i=0; i<size; i++)
-    {
-      if ( r[i] > max_r )
-        max_r=r[i];
-      if ( r[i] < min_r )
-        min_r=r[i];
-    }
-
-  /*printf("min=%d max=%d\n",min_r,max_r);*/
-
-  max_r-=min_r;
-
-  for (i=0; i<size; i++)
-    in[i] = (uchar)((int)((int)(r[i]-min_r)*255)/max_r);
-}
-
-/* }}} */
-/* {{{ setup_brightness_lut(bp,thresh,form) */
-
-void setup_brightness_lut(bp,thresh,form)
-  uchar **bp;
-  int   thresh, form;
-{
-int   k;
-float temp;
-
-  *bp=(unsigned char *)malloc(516);
-  *bp=*bp+258;
-
-  for(k=-256;k<257;k++)
-  {
-    temp=((float)k)/((float)thresh);
-    temp=temp*temp;
-    if (form==6)
-      temp=temp*temp*temp;
-    temp=100.0*exp(-temp);
-    *(*bp+k)= (uchar)temp;
-  }
-}
-
-/* }}} */
-/* {{{ susan principle */
-
-/* {{{ susan_principle(in,r,bp,max_no,x_size,y_size) */
-
-susan_principle(in,r,bp,max_no,x_size,y_size)
-  uchar *in, *bp;
-  int   *r, max_no, x_size, y_size;
-{
-int   i, j, n;
-uchar *p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  for (i=3;i<y_size-3;i++)
-    for (j=3;j<x_size-3;j++)
-    {
-      n=100;
-      p=in + (i-3)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-}
-
-/* }}} */
-/* {{{ susan_principle_small(in,r,bp,max_no,x_size,y_size) */
-
-susan_principle_small(in,r,bp,max_no,x_size,y_size)
-  uchar *in, *bp;
-  int   *r, max_no, x_size, y_size;
-{
-int   i, j, n;
-uchar *p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  max_no = 730; /* ho hum ;) */
-
-  for (i=1;i<y_size-1;i++)
-    for (j=1;j<x_size-1;j++)
-    {
-      n=100;
-      p=in + (i-1)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ smoothing */
-
-/* {{{ median(in,i,j,x_size) */
-
-uchar median(in,i,j,x_size)
-  uchar *in;
-  int   i, j, x_size;
-{
-int p[8],k,l,tmp;
-
-  p[0]=in[(i-1)*x_size+j-1];
-  p[1]=in[(i-1)*x_size+j  ];
-  p[2]=in[(i-1)*x_size+j+1];
-  p[3]=in[(i  )*x_size+j-1];
-  p[4]=in[(i  )*x_size+j+1];
-  p[5]=in[(i+1)*x_size+j-1];
-  p[6]=in[(i+1)*x_size+j  ];
-  p[7]=in[(i+1)*x_size+j+1];
-
-  for(k=0; k<7; k++)
-    for(l=0; l<(7-k); l++)
-      if (p[l]>p[l+1])
-      {
-        tmp=p[l]; p[l]=p[l+1]; p[l+1]=tmp;
-      }
-
-  return( (p[3]+p[4]) / 2 );
-}
-
-/* }}} */
-/* {{{ enlarge(in,tmp_image,x_size,y_size,border) */
-
-/* this enlarges "in" so that borders can be dealt with easily */
-
-enlarge(in,tmp_image,x_size,y_size,border)
-  uchar **in;
-  uchar *tmp_image;
-  int   *x_size, *y_size, border;
-{
-int   i, j;
-
-  for(i=0; i<*y_size; i++)   /* copy *in into tmp_image */
-    memcpy(tmp_image+(i+border)*(*x_size+2*border)+border, *in+i* *x_size, *x_size);
-
-  for(i=0; i<border; i++) /* copy top and bottom rows; invert as many as necessary */
-  {
-    memcpy(tmp_image+(border-1-i)*(*x_size+2*border)+border,*in+i* *x_size,*x_size);
-    memcpy(tmp_image+(*y_size+border+i)*(*x_size+2*border)+border,*in+(*y_size-i-1)* *x_size,*x_size);
-  }
-
-  for(i=0; i<border; i++) /* copy left and right columns */
-    for(j=0; j<*y_size+2*border; j++)
-    {
-      tmp_image[j*(*x_size+2*border)+border-1-i]=tmp_image[j*(*x_size+2*border)+border+i];
-      tmp_image[j*(*x_size+2*border)+ *x_size+border+i]=tmp_image[j*(*x_size+2*border)+ *x_size+border-1-i];
-    }
-
-  *x_size+=2*border;  /* alter image size */
-  *y_size+=2*border;
-  *in=tmp_image;      /* repoint in */
-}
-
-/* }}} */
-/* {{{ void susan_smoothing(three_by_three,in,dt,x_size,y_size,bp) */
-
-void susan_smoothing(three_by_three,in,dt,x_size,y_size,bp)
-  int   three_by_three, x_size, y_size;
-  uchar *in, *bp;
-  float dt;
-{
-/* {{{ vars */
-
-float temp;
-int   n_max, increment, mask_size,
-      i,j,x,y,area,brightness,tmp,centre;
-uchar *ip, *dp, *dpt, *cp, *out=in,
-      *tmp_image;
-TOTAL_TYPE total;
-
-/* }}} */
-
-  /* {{{ setup larger image and border sizes */
-
-  if (three_by_three==0)
-    mask_size = ((int)(1.5 * dt)) + 1;
-  else
-    mask_size = 1;
-
-  total=0.1; /* test for total's type */
-  if ( (dt>15) && (total==0) )
-  {
-    printf("Distance_thresh (%f) too big for integer arithmetic.\n",dt);
-    printf("Either reduce it to <=15 or recompile with variable \"total\"\n");
-    printf("as a float: see top \"defines\" section.\n");
-    exit(0);
-  }
-
-  if ( (2*mask_size+1>x_size) || (2*mask_size+1>y_size) )
-  {
-    printf("Mask size (1.5*distance_thresh+1=%d) too big for image (%dx%d).\n",mask_size,x_size,y_size);
-    exit(0);
-  }
-
-  tmp_image = (uchar *) malloc( (x_size+mask_size*2) * (y_size+mask_size*2) );
-  enlarge(&in,tmp_image,&x_size,&y_size,mask_size);
-
-/* }}} */
-
-  if (three_by_three==0)
-  {     /* large Gaussian masks */
-    /* {{{ setup distance lut */
-
-  n_max = (mask_size*2) + 1;
-
-  increment = x_size - n_max;
-
-  dp     = (unsigned char *)malloc(n_max*n_max);
-  dpt    = dp;
-  temp   = -(dt*dt);
-
-  for(i=-mask_size; i<=mask_size; i++)
-    for(j=-mask_size; j<=mask_size; j++)
-    {
-      x = (int) (100.0 * exp( ((float)((i*i)+(j*j))) / temp ));
-      *dpt++ = (unsigned char)x;
-    }
-
-/* }}} */
-    /* {{{ main section */
-
-  for (i=mask_size;i<y_size-mask_size;i++)
-  {
-    for (j=mask_size;j<x_size-mask_size;j++)
-    {
-      area = 0;
-      total = 0;
-      dpt = dp;
-      ip = in + ((i-mask_size)*x_size) + j - mask_size;
-      centre = in[i*x_size+j];
-      cp = bp + centre;
-      for(y=-mask_size; y<=mask_size; y++)
-      {
-        for(x=-mask_size; x<=mask_size; x++)
-	{
-          brightness = *ip++;
-          tmp = *dpt++ * *(cp-brightness);
-          area += tmp;
-          total += tmp * brightness;
-        }
-        ip += increment;
-      }
-      tmp = area-10000;
-      if (tmp==0)
-        *out++=median(in,i,j,x_size);
-      else
-        *out++=((total-(centre*10000))/tmp);
-    }
-  }
-
-/* }}} */
-  }
-  else
-  {     /* 3x3 constant mask */
-    /* {{{ main section */
-
-  for (i=1;i<y_size-1;i++)
-  {
-    for (j=1;j<x_size-1;j++)
-    {
-      area = 0;
-      total = 0;
-      ip = in + ((i-1)*x_size) + j - 1;
-      centre = in[i*x_size+j];
-      cp = bp + centre;
-
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      ip += x_size-2;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      ip += x_size-2;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-
-      tmp = area-100;
-      if (tmp==0)
-        *out++=median(in,i,j,x_size);
-      else
-        *out++=(total-(centre*100))/tmp;
-    }
-  }
-
-/* }}} */
-  }
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ edges */
-
-/* {{{ edge_draw(in,corner_list,drawing_mode) */
-
-edge_draw(in,mid,x_size,y_size,drawing_mode)
-  uchar *in, *mid;
-  int x_size, y_size, drawing_mode;
-{
-int   i;
-uchar *inp, *midp;
-
-  if (drawing_mode==0)
-  {
-    /* mark 3x3 white block around each edge point */
-    midp=mid;
-    for (i=0; i<x_size*y_size; i++)
-    {
-      if (*midp<8)
-      {
-        inp = in + (midp - mid) - x_size - 1;
-        *inp++=255; *inp++=255; *inp=255; inp+=x_size-2;
-        *inp++=255; *inp++;     *inp=255; inp+=x_size-2;
-        *inp++=255; *inp++=255; *inp=255;
-      }
-      midp++;
-    }
-  }
-
-  /* now mark 1 black pixel at each edge point */
-  midp=mid;
-  for (i=0; i<x_size*y_size; i++)
-  {
-    if (*midp<8)
-      *(in + (midp - mid)) = 0;
-    midp++;
-  }
-}
-
-/* }}} */
-/* {{{ susan_thin(r,mid,x_size,y_size) */
-
-/* only one pass is needed as i,j are decremented if necessary to go
-   back and do bits again */
-
-susan_thin(r,mid,x_size,y_size)
-  uchar *mid;
-  int   *r, x_size, y_size;
-{
-int   l[9], centre, nlinks, npieces,
-      b01, b12, b21, b10,
-      p1, p2, p3, p4,
-      b00, b02, b20, b22,
-      m, n, a, b, x, y, i, j;
-uchar *mp;
-
-  for (i=4;i<y_size-4;i++)
-    for (j=4;j<x_size-4;j++)
-      if (mid[i*x_size+j]<8)
-      {
-        centre = r[i*x_size+j];
-        /* {{{ count number of neighbours */
-
-        mp=mid + (i-1)*x_size + j-1;
-
-        n = (*mp<8) +
-            (*(mp+1)<8) +
-            (*(mp+2)<8) +
-            (*(mp+x_size)<8) +
-            (*(mp+x_size+2)<8) +
-            (*(mp+x_size+x_size)<8) +
-            (*(mp+x_size+x_size+1)<8) +
-            (*(mp+x_size+x_size+2)<8);
-
-/* }}} */
-        /* {{{ n==0 no neighbours - remove point */
-
-        if (n==0)
-          mid[i*x_size+j]=100;
-
-/* }}} */
-        /* {{{ n==1 - extend line if I can */
-
-        /* extension is only allowed a few times - the value of mid is used to control this */
-
-        if ( (n==1) && (mid[i*x_size+j]<6) )
-        {
-          /* find maximum neighbour weighted in direction opposite the
-             neighbour already present. e.g.
-             have: O O O  weight r by 0 2 3
-                   X X O              0 0 4
-                   O O O              0 2 3     */
-
-          l[0]=r[(i-1)*x_size+j-1]; l[1]=r[(i-1)*x_size+j]; l[2]=r[(i-1)*x_size+j+1];
-          l[3]=r[(i  )*x_size+j-1]; l[4]=0;                 l[5]=r[(i  )*x_size+j+1];
-          l[6]=r[(i+1)*x_size+j-1]; l[7]=r[(i+1)*x_size+j]; l[8]=r[(i+1)*x_size+j+1];
-
-          if (mid[(i-1)*x_size+j-1]<8)        { l[0]=0; l[1]=0; l[3]=0; l[2]*=2;
-                                                l[6]*=2; l[5]*=3; l[7]*=3; l[8]*=4; }
-          else { if (mid[(i-1)*x_size+j]<8)   { l[1]=0; l[0]=0; l[2]=0; l[3]*=2;
-                                                l[5]*=2; l[6]*=3; l[8]*=3; l[7]*=4; }
-          else { if (mid[(i-1)*x_size+j+1]<8) { l[2]=0; l[1]=0; l[5]=0; l[0]*=2;
-                                                l[8]*=2; l[3]*=3; l[7]*=3; l[6]*=4; }
-          else { if (mid[(i)*x_size+j-1]<8)   { l[3]=0; l[0]=0; l[6]=0; l[1]*=2;
-                                                l[7]*=2; l[2]*=3; l[8]*=3; l[5]*=4; }
-          else { if (mid[(i)*x_size+j+1]<8)   { l[5]=0; l[2]=0; l[8]=0; l[1]*=2;
-                                                l[7]*=2; l[0]*=3; l[6]*=3; l[3]*=4; }
-          else { if (mid[(i+1)*x_size+j-1]<8) { l[6]=0; l[3]=0; l[7]=0; l[0]*=2;
-                                                l[8]*=2; l[1]*=3; l[5]*=3; l[2]*=4; }
-          else { if (mid[(i+1)*x_size+j]<8)   { l[7]=0; l[6]=0; l[8]=0; l[3]*=2;
-                                                l[5]*=2; l[0]*=3; l[2]*=3; l[1]*=4; }
-          else { if (mid[(i+1)*x_size+j+1]<8) { l[8]=0; l[5]=0; l[7]=0; l[6]*=2;
-                                                l[2]*=2; l[1]*=3; l[3]*=3; l[0]*=4; } }}}}}}}
-
-          m=0;     /* find the highest point */
-          for(y=0; y<3; y++)
-            for(x=0; x<3; x++)
-              if (l[y+y+y+x]>m) { m=l[y+y+y+x]; a=y; b=x; }
-
-          if (m>0)
-          {
-            if (mid[i*x_size+j]<4)
-              mid[(i+a-1)*x_size+j+b-1] = 4;
-            else
-              mid[(i+a-1)*x_size+j+b-1] = mid[i*x_size+j]+1;
-            if ( (a+a+b) < 3 ) /* need to jump back in image */
-	    {
-              i+=a-1;
-              j+=b-2;
-              if (i<4) i=4;
-              if (j<4) j=4;
-	    }
-	  }
-        }
-
-/* }}} */
-        /* {{{ n==2 */
-
-        if (n==2)
-	{
-          /* put in a bit here to straighten edges */
-          b00 = mid[(i-1)*x_size+j-1]<8; /* corners of 3x3 */
-          b02 = mid[(i-1)*x_size+j+1]<8;
-	  b20 = mid[(i+1)*x_size+j-1]<8;
-          b22 = mid[(i+1)*x_size+j+1]<8;
-          if ( ((b00+b02+b20+b22)==2) && ((b00|b22)&(b02|b20)))
-	  {  /* case: move a point back into line.
-                e.g. X O X  CAN  become X X X
-                     O X O              O O O
-                     O O O              O O O    */
-            if (b00)
-	    {
-              if (b02) { x=0; y=-1; }
-              else     { x=-1; y=0; }
-	    }
-            else
-	    {
-              if (b02) { x=1; y=0; }
-              else     { x=0; y=1; }
-	    }
-            if (((float)r[(i+y)*x_size+j+x]/(float)centre) > 0.7)
-	    {
-              if ( ( (x==0) && (mid[(i+(2*y))*x_size+j]>7) && (mid[(i+(2*y))*x_size+j-1]>7) && (mid[(i+(2*y))*x_size+j+1]>7) ) ||
-                   ( (y==0) && (mid[(i)*x_size+j+(2*x)]>7) && (mid[(i+1)*x_size+j+(2*x)]>7) && (mid[(i-1)*x_size+j+(2*x)]>7) ) )
-	      {
-                mid[(i)*x_size+j]=100;
-                mid[(i+y)*x_size+j+x]=3;  /* no jumping needed */
-	      }
-	    }
-	  }
-          else
-          {
-            b01 = mid[(i-1)*x_size+j  ]<8;
-            b12 = mid[(i  )*x_size+j+1]<8;
-            b21 = mid[(i+1)*x_size+j  ]<8;
-            b10 = mid[(i  )*x_size+j-1]<8;
-            /* {{{ right angle ends - not currently used */
-
-#ifdef IGNORETHIS
-            if ( (b00&b01)|(b00&b10)|(b02&b01)|(b02&b12)|(b20&b10)|(b20&b21)|(b22&b21)|(b22&b12) )
-	    { /* case; right angle ends. clean up.
-                 e.g.; X X O  CAN  become X X O
-                       O X O              O O O
-                       O O O              O O O        */
-              if ( ((b01)&(mid[(i-2)*x_size+j-1]>7)&(mid[(i-2)*x_size+j]>7)&(mid[(i-2)*x_size+j+1]>7)&
-                                    ((b00&((2*r[(i-1)*x_size+j+1])>centre))|(b02&((2*r[(i-1)*x_size+j-1])>centre)))) |
-                   ((b10)&(mid[(i-1)*x_size+j-2]>7)&(mid[(i)*x_size+j-2]>7)&(mid[(i+1)*x_size+j-2]>7)&
-                                    ((b00&((2*r[(i+1)*x_size+j-1])>centre))|(b20&((2*r[(i-1)*x_size+j-1])>centre)))) |
-                   ((b12)&(mid[(i-1)*x_size+j+2]>7)&(mid[(i)*x_size+j+2]>7)&(mid[(i+1)*x_size+j+2]>7)&
-                                    ((b02&((2*r[(i+1)*x_size+j+1])>centre))|(b22&((2*r[(i-1)*x_size+j+1])>centre)))) |
-                   ((b21)&(mid[(i+2)*x_size+j-1]>7)&(mid[(i+2)*x_size+j]>7)&(mid[(i+2)*x_size+j+1]>7)&
-                                    ((b20&((2*r[(i+1)*x_size+j+1])>centre))|(b22&((2*r[(i+1)*x_size+j-1])>centre)))) )
-	      {
-                mid[(i)*x_size+j]=100;
-                if (b10&b20) j-=2;
-                if (b00|b01|b02) { i--; j-=2; }
-  	      }
-	    }
-#endif
-
-/* }}} */
-            if ( ((b01+b12+b21+b10)==2) && ((b10|b12)&(b01|b21)) &&
-                 ((b01&((mid[(i-2)*x_size+j-1]<8)|(mid[(i-2)*x_size+j+1]<8)))|(b10&((mid[(i-1)*x_size+j-2]<8)|(mid[(i+1)*x_size+j-2]<8)))|
-                (b12&((mid[(i-1)*x_size+j+2]<8)|(mid[(i+1)*x_size+j+2]<8)))|(b21&((mid[(i+2)*x_size+j-1]<8)|(mid[(i+2)*x_size+j+1]<8)))) )
-	    { /* case; clears odd right angles.
-                 e.g.; O O O  becomes O O O
-                       X X O          X O O
-                       O X O          O X O     */
-              mid[(i)*x_size+j]=100;
-              i--;               /* jump back */
-              j-=2;
-              if (i<4) i=4;
-              if (j<4) j=4;
-	    }
-	  }
-	}
-
-/* }}} */
-        /* {{{ n>2 the thinning is done here without breaking connectivity */
-
-        if (n>2)
-        {
-          b01 = mid[(i-1)*x_size+j  ]<8;
-          b12 = mid[(i  )*x_size+j+1]<8;
-          b21 = mid[(i+1)*x_size+j  ]<8;
-          b10 = mid[(i  )*x_size+j-1]<8;
-          if((b01+b12+b21+b10)>1)
-          {
-            b00 = mid[(i-1)*x_size+j-1]<8;
-            b02 = mid[(i-1)*x_size+j+1]<8;
-	    b20 = mid[(i+1)*x_size+j-1]<8;
-	    b22 = mid[(i+1)*x_size+j+1]<8;
-            p1 = b00 | b01;
-            p2 = b02 | b12;
-            p3 = b22 | b21;
-            p4 = b20 | b10;
-
-            if( ((p1 + p2 + p3 + p4) - ((b01 & p2)+(b12 & p3)+(b21 & p4)+(b10 & p1))) < 2)
-            {
-              mid[(i)*x_size+j]=100;
-              i--;
-              j-=2;
-              if (i<4) i=4;
-              if (j<4) j=4;
-            }
-          }
-        }
-
-/* }}} */
-      }
-}
-
-/* }}} */
-/* {{{ susan_edges(in,r,sf,max_no,out) */
-
-susan_edges(in,r,mid,bp,max_no,x_size,y_size)
-  uchar *in, *bp, *mid;
-  int   *r, max_no, x_size, y_size;
-{
-float z;
-int   do_symmetry, i, j, m, n, a, b, x, y, w;
-uchar c,*p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  for (i=3;i<y_size-3;i++)
-    for (j=3;j<x_size-3;j++)
-    {
-      n=100;
-      p=in + (i-3)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-
-  for (i=4;i<y_size-4;i++)
-    for (j=4;j<x_size-4;j++)
-    {
-      if (r[i*x_size+j]>0)
-      {
-        m=r[i*x_size+j];
-        n=max_no - m;
-        cp=bp + in[i*x_size+j];
-
-        if (n>600)
-        {
-          p=in + (i-3)*x_size + j - 1;
-          x=0;y=0;
-
-          c=*(cp-*p++);x-=c;y-=3*c;
-          c=*(cp-*p++);y-=3*c;
-          c=*(cp-*p);x+=c;y-=3*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x-=2*c;y-=2*c;
-          c=*(cp-*p++);x-=c;y-=2*c;
-          c=*(cp-*p++);y-=2*c;
-          c=*(cp-*p++);x+=c;y-=2*c;
-          c=*(cp-*p);x+=2*c;y-=2*c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x-=3*c;y-=c;
-          c=*(cp-*p++);x-=2*c;y-=c;
-          c=*(cp-*p++);x-=c;y-=c;
-          c=*(cp-*p++);y-=c;
-          c=*(cp-*p++);x+=c;y-=c;
-          c=*(cp-*p++);x+=2*c;y-=c;
-          c=*(cp-*p);x+=3*c;y-=c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x-=3*c;
-          c=*(cp-*p++);x-=2*c;
-          c=*(cp-*p);x-=c;
-          p+=2;
-          c=*(cp-*p++);x+=c;
-          c=*(cp-*p++);x+=2*c;
-          c=*(cp-*p);x+=3*c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x-=3*c;y+=c;
-          c=*(cp-*p++);x-=2*c;y+=c;
-          c=*(cp-*p++);x-=c;y+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p++);x+=c;y+=c;
-          c=*(cp-*p++);x+=2*c;y+=c;
-          c=*(cp-*p);x+=3*c;y+=c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x-=2*c;y+=2*c;
-          c=*(cp-*p++);x-=c;y+=2*c;
-          c=*(cp-*p++);y+=2*c;
-          c=*(cp-*p++);x+=c;y+=2*c;
-          c=*(cp-*p);x+=2*c;y+=2*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x-=c;y+=3*c;
-          c=*(cp-*p++);y+=3*c;
-          c=*(cp-*p);x+=c;y+=3*c;
-
-          z = sqrt((float)((x*x) + (y*y)));
-          if (z > (0.9*(float)n)) /* 0.5 */
-	  {
-            do_symmetry=0;
-            if (x==0)
-              z=1000000.0;
-            else
-              z=((float)y) / ((float)x);
-            if (z < 0) { z=-z; w=-1; }
-            else w=1;
-            if (z < 0.5) { /* vert_edge */ a=0; b=1; }
-            else { if (z > 2.0) { /* hor_edge */ a=1; b=0; }
-            else { /* diag_edge */ if (w>0) { a=1; b=1; }
-                                   else { a=-1; b=1; }}}
-            if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
-                 (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
-              mid[i*x_size+j] = 1;
-          }
-          else
-            do_symmetry=1;
-        }
-        else
-          do_symmetry=1;
-
-        if (do_symmetry==1)
-	{
-          p=in + (i-3)*x_size + j - 1;
-          x=0; y=0; w=0;
-
-          /*   |      \
-               y  -x-  w
-               |        \   */
-
-          c=*(cp-*p++);x+=c;y+=9*c;w+=3*c;
-          c=*(cp-*p++);y+=9*c;
-          c=*(cp-*p);x+=c;y+=9*c;w-=3*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x+=4*c;y+=4*c;w+=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
-          c=*(cp-*p++);y+=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
-          c=*(cp-*p);x+=4*c;y+=4*c;w-=4*c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x+=9*c;y+=c;w+=3*c;
-          c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
-          c=*(cp-*p++);x+=c;y+=c;w+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p++);x+=c;y+=c;w-=c;
-          c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
-          c=*(cp-*p);x+=9*c;y+=c;w-=3*c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x+=9*c;
-          c=*(cp-*p++);x+=4*c;
-          c=*(cp-*p);x+=c;
-          p+=2;
-          c=*(cp-*p++);x+=c;
-          c=*(cp-*p++);x+=4*c;
-          c=*(cp-*p);x+=9*c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x+=9*c;y+=c;w-=3*c;
-          c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
-          c=*(cp-*p++);x+=c;y+=c;w-=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p++);x+=c;y+=c;w+=c;
-          c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
-          c=*(cp-*p);x+=9*c;y+=c;w+=3*c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x+=4*c;y+=4*c;w-=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
-          c=*(cp-*p++);y+=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
-          c=*(cp-*p);x+=4*c;y+=4*c;w+=4*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x+=c;y+=9*c;w-=3*c;
-          c=*(cp-*p++);y+=9*c;
-          c=*(cp-*p);x+=c;y+=9*c;w+=3*c;
-
-          if (y==0)
-            z = 1000000.0;
-          else
-            z = ((float)x) / ((float)y);
-          if (z < 0.5) { /* vertical */ a=0; b=1; }
-          else { if (z > 2.0) { /* horizontal */ a=1; b=0; }
-          else { /* diagonal */ if (w>0) { a=-1; b=1; }
-                                else { a=1; b=1; }}}
-          if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
-               (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
-            mid[i*x_size+j] = 2;
-        }
-      }
-    }
-}
-
-/* }}} */
-/* {{{ susan_edges_small(in,r,sf,max_no,out) */
-
-susan_edges_small(in,r,mid,bp,max_no,x_size,y_size)
-  uchar *in, *bp, *mid;
-  int   *r, max_no, x_size, y_size;
-{
-float z;
-int   do_symmetry, i, j, m, n, a, b, x, y, w;
-uchar c,*p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  max_no = 730; /* ho hum ;) */
-
-  for (i=1;i<y_size-1;i++)
-    for (j=1;j<x_size-1;j++)
-    {
-      n=100;
-      p=in + (i-1)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-
-  for (i=2;i<y_size-2;i++)
-    for (j=2;j<x_size-2;j++)
-    {
-      if (r[i*x_size+j]>0)
-      {
-        m=r[i*x_size+j];
-        n=max_no - m;
-        cp=bp + in[i*x_size+j];
-
-        if (n>250)
-	{
-          p=in + (i-1)*x_size + j - 1;
-          x=0;y=0;
-
-          c=*(cp-*p++);x-=c;y-=c;
-          c=*(cp-*p++);y-=c;
-          c=*(cp-*p);x+=c;y-=c;
-          p+=x_size-2;
-
-          c=*(cp-*p);x-=c;
-          p+=2;
-          c=*(cp-*p);x+=c;
-          p+=x_size-2;
-
-          c=*(cp-*p++);x-=c;y+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p);x+=c;y+=c;
-
-          z = sqrt((float)((x*x) + (y*y)));
-          if (z > (0.4*(float)n)) /* 0.6 */
-          {
-            do_symmetry=0;
-            if (x==0)
-	      z=1000000.0;
-	    else
-	      z=((float)y) / ((float)x);
-	    if (z < 0) { z=-z; w=-1; }
-            else w=1;
-            if (z < 0.5) { /* vert_edge */ a=0; b=1; }
-            else { if (z > 2.0) { /* hor_edge */ a=1; b=0; }
-            else { /* diag_edge */ if (w>0) { a=1; b=1; }
-                                   else { a=-1; b=1; }}}
-            if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
-              mid[i*x_size+j] = 1;
-          }
-          else
-            do_symmetry=1;
-        }
-        else
-          do_symmetry=1;
-
-        if (do_symmetry==1)
-	{
-          p=in + (i-1)*x_size + j - 1;
-          x=0; y=0; w=0;
-
-          /*   |      \
-               y  -x-  w
-               |        \   */
-
-          c=*(cp-*p++);x+=c;y+=c;w+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p);x+=c;y+=c;w-=c;
-          p+=x_size-2;
-
-          c=*(cp-*p);x+=c;
-          p+=2;
-          c=*(cp-*p);x+=c;
-          p+=x_size-2;
-
-          c=*(cp-*p++);x+=c;y+=c;w-=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p);x+=c;y+=c;w+=c;
-
-          if (y==0)
-            z = 1000000.0;
-          else
-            z = ((float)x) / ((float)y);
-          if (z < 0.5) { /* vertical */ a=0; b=1; }
-          else { if (z > 2.0) { /* horizontal */ a=1; b=0; }
-          else { /* diagonal */ if (w>0) { a=-1; b=1; }
-                                else { a=1; b=1; }}}
-          if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
-            mid[i*x_size+j] = 2;
-        }
-      }
-    }
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ corners */
-
-/* {{{ corner_draw(in,corner_list,drawing_mode) */
-
-corner_draw(in,corner_list,x_size,drawing_mode)
-  uchar *in;
-  CORNER_LIST corner_list;
-  int x_size, drawing_mode;
-{
-uchar *p;
-int   n=0;
-
-  while(corner_list[n].info != 7)
-  {
-    if (drawing_mode==0)
-    {
-      p = in + (corner_list[n].y-1)*x_size + corner_list[n].x - 1;
-      *p++=255; *p++=255; *p=255; p+=x_size-2;
-      *p++=255; *p++=0;   *p=255; p+=x_size-2;
-      *p++=255; *p++=255; *p=255;
-      n++;
-    }
-    else
-    {
-      p = in + corner_list[n].y*x_size + corner_list[n].x;
-      *p=0;
-      n++;
-    }
-  }
-}
-
-/* }}} */
-/* {{{ susan(in,r,sf,max_no,corner_list) */
-
-susan_corners(in,r,bp,max_no,corner_list,x_size,y_size)
-  uchar       *in, *bp;
-  int         *r, max_no, x_size, y_size;
-  CORNER_LIST corner_list;
-{
-int   n,x,y,sq,xx,yy,
-      i,j,*cgx,*cgy;
-float divide;
-uchar c,*p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  cgx=(int *)malloc(x_size*y_size*sizeof(int));
-  cgy=(int *)malloc(x_size*y_size*sizeof(int));
-
-  for (i=5;i<y_size-5;i++)
-    for (j=5;j<x_size-5;j++) {
-        n=100;
-        p=in + (i-3)*x_size + j - 1;
-        cp=bp + in[i*x_size+j];
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-      if (n<max_no){    /* do this test early and often ONLY to save wasted computation */
-        p+=2;
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-
-        if (n<max_no)
-        {
-            x=0;y=0;
-            p=in + (i-3)*x_size + j - 1;
-
-            c=*(cp-*p++);x-=c;y-=3*c;
-            c=*(cp-*p++);y-=3*c;
-            c=*(cp-*p);x+=c;y-=3*c;
-            p+=x_size-3;
-
-            c=*(cp-*p++);x-=2*c;y-=2*c;
-            c=*(cp-*p++);x-=c;y-=2*c;
-            c=*(cp-*p++);y-=2*c;
-            c=*(cp-*p++);x+=c;y-=2*c;
-            c=*(cp-*p);x+=2*c;y-=2*c;
-            p+=x_size-5;
-
-            c=*(cp-*p++);x-=3*c;y-=c;
-            c=*(cp-*p++);x-=2*c;y-=c;
-            c=*(cp-*p++);x-=c;y-=c;
-            c=*(cp-*p++);y-=c;
-            c=*(cp-*p++);x+=c;y-=c;
-            c=*(cp-*p++);x+=2*c;y-=c;
-            c=*(cp-*p);x+=3*c;y-=c;
-            p+=x_size-6;
-
-            c=*(cp-*p++);x-=3*c;
-            c=*(cp-*p++);x-=2*c;
-            c=*(cp-*p);x-=c;
-            p+=2;
-            c=*(cp-*p++);x+=c;
-            c=*(cp-*p++);x+=2*c;
-            c=*(cp-*p);x+=3*c;
-            p+=x_size-6;
-
-            c=*(cp-*p++);x-=3*c;y+=c;
-            c=*(cp-*p++);x-=2*c;y+=c;
-            c=*(cp-*p++);x-=c;y+=c;
-            c=*(cp-*p++);y+=c;
-            c=*(cp-*p++);x+=c;y+=c;
-            c=*(cp-*p++);x+=2*c;y+=c;
-            c=*(cp-*p);x+=3*c;y+=c;
-            p+=x_size-5;
-
-            c=*(cp-*p++);x-=2*c;y+=2*c;
-            c=*(cp-*p++);x-=c;y+=2*c;
-            c=*(cp-*p++);y+=2*c;
-            c=*(cp-*p++);x+=c;y+=2*c;
-            c=*(cp-*p);x+=2*c;y+=2*c;
-            p+=x_size-3;
-
-            c=*(cp-*p++);x-=c;y+=3*c;
-            c=*(cp-*p++);y+=3*c;
-            c=*(cp-*p);x+=c;y+=3*c;
-
-            xx=x*x;
-            yy=y*y;
-            sq=xx+yy;
-            if ( sq > ((n*n)/2) )
-            {
-              if(yy<xx) {
-                divide=(float)y/(float)abs(x);
-                sq=abs(x)/x;
-                sq=*(cp-in[(i+FTOI(divide))*x_size+j+sq]) +
-                   *(cp-in[(i+FTOI(2*divide))*x_size+j+2*sq]) +
-                   *(cp-in[(i+FTOI(3*divide))*x_size+j+3*sq]);}
-              else {
-                divide=(float)x/(float)abs(y);
-                sq=abs(y)/y;
-                sq=*(cp-in[(i+sq)*x_size+j+FTOI(divide)]) +
-                   *(cp-in[(i+2*sq)*x_size+j+FTOI(2*divide)]) +
-                   *(cp-in[(i+3*sq)*x_size+j+FTOI(3*divide)]);}
-
-              if(sq>290){
-                r[i*x_size+j] = max_no-n;
-                cgx[i*x_size+j] = (51*x)/n;
-                cgy[i*x_size+j] = (51*y)/n;}
-            }
-	}
-}}}}}}}}}}}}}}}}}}}
-
-  /* to locate the local maxima */
-  n=0;
-  for (i=5;i<y_size-5;i++)
-    for (j=5;j<x_size-5;j++) {
-       x = r[i*x_size+j];
-       if (x>0)  {
-          /* 5x5 mask */
-#ifdef FIVE_SUPP
-          if (
-              (x>r[(i-1)*x_size+j+2]) &&
-              (x>r[(i  )*x_size+j+1]) &&
-              (x>r[(i  )*x_size+j+2]) &&
-              (x>r[(i+1)*x_size+j-1]) &&
-              (x>r[(i+1)*x_size+j  ]) &&
-              (x>r[(i+1)*x_size+j+1]) &&
-              (x>r[(i+1)*x_size+j+2]) &&
-              (x>r[(i+2)*x_size+j-2]) &&
-              (x>r[(i+2)*x_size+j-1]) &&
-              (x>r[(i+2)*x_size+j  ]) &&
-              (x>r[(i+2)*x_size+j+1]) &&
-              (x>r[(i+2)*x_size+j+2]) &&
-              (x>=r[(i-2)*x_size+j-2]) &&
-              (x>=r[(i-2)*x_size+j-1]) &&
-              (x>=r[(i-2)*x_size+j  ]) &&
-              (x>=r[(i-2)*x_size+j+1]) &&
-              (x>=r[(i-2)*x_size+j+2]) &&
-              (x>=r[(i-1)*x_size+j-2]) &&
-              (x>=r[(i-1)*x_size+j-1]) &&
-	      (x>=r[(i-1)*x_size+j  ]) &&
-	      (x>=r[(i-1)*x_size+j+1]) &&
-	      (x>=r[(i  )*x_size+j-2]) &&
-	      (x>=r[(i  )*x_size+j-1]) &&
-	      (x>=r[(i+1)*x_size+j-2]) )
-#endif
-#ifdef SEVEN_SUPP
-          if (
-                (x>r[(i-3)*x_size+j-3]) &&
-                (x>r[(i-3)*x_size+j-2]) &&
-                (x>r[(i-3)*x_size+j-1]) &&
-                (x>r[(i-3)*x_size+j  ]) &&
-                (x>r[(i-3)*x_size+j+1]) &&
-                (x>r[(i-3)*x_size+j+2]) &&
-                (x>r[(i-3)*x_size+j+3]) &&
-
-                (x>r[(i-2)*x_size+j-3]) &&
-                (x>r[(i-2)*x_size+j-2]) &&
-                (x>r[(i-2)*x_size+j-1]) &&
-                (x>r[(i-2)*x_size+j  ]) &&
-                (x>r[(i-2)*x_size+j+1]) &&
-                (x>r[(i-2)*x_size+j+2]) &&
-                (x>r[(i-2)*x_size+j+3]) &&
-
-                (x>r[(i-1)*x_size+j-3]) &&
-                (x>r[(i-1)*x_size+j-2]) &&
-                (x>r[(i-1)*x_size+j-1]) &&
-                (x>r[(i-1)*x_size+j  ]) &&
-                (x>r[(i-1)*x_size+j+1]) &&
-                (x>r[(i-1)*x_size+j+2]) &&
-                (x>r[(i-1)*x_size+j+3]) &&
-
-                (x>r[(i)*x_size+j-3]) &&
-                (x>r[(i)*x_size+j-2]) &&
-                (x>r[(i)*x_size+j-1]) &&
-                (x>=r[(i)*x_size+j+1]) &&
-                (x>=r[(i)*x_size+j+2]) &&
-                (x>=r[(i)*x_size+j+3]) &&
-
-                (x>=r[(i+1)*x_size+j-3]) &&
-                (x>=r[(i+1)*x_size+j-2]) &&
-                (x>=r[(i+1)*x_size+j-1]) &&
-                (x>=r[(i+1)*x_size+j  ]) &&
-                (x>=r[(i+1)*x_size+j+1]) &&
-                (x>=r[(i+1)*x_size+j+2]) &&
-                (x>=r[(i+1)*x_size+j+3]) &&
-
-                (x>=r[(i+2)*x_size+j-3]) &&
-                (x>=r[(i+2)*x_size+j-2]) &&
-                (x>=r[(i+2)*x_size+j-1]) &&
-                (x>=r[(i+2)*x_size+j  ]) &&
-                (x>=r[(i+2)*x_size+j+1]) &&
-                (x>=r[(i+2)*x_size+j+2]) &&
-                (x>=r[(i+2)*x_size+j+3]) &&
-
-                (x>=r[(i+3)*x_size+j-3]) &&
-                (x>=r[(i+3)*x_size+j-2]) &&
-                (x>=r[(i+3)*x_size+j-1]) &&
-                (x>=r[(i+3)*x_size+j  ]) &&
-                (x>=r[(i+3)*x_size+j+1]) &&
-                (x>=r[(i+3)*x_size+j+2]) &&
-                (x>=r[(i+3)*x_size+j+3]) )
-#endif
-{
-corner_list[n].info=0;
-corner_list[n].x=j;
-corner_list[n].y=i;
-corner_list[n].dx=cgx[i*x_size+j];
-corner_list[n].dy=cgy[i*x_size+j];
-corner_list[n].I=in[i*x_size+j];
-n++;
-if(n==MAX_CORNERS){
-      fprintf(stderr,"Too many corners.\n");
-      exit(1);
-         }}}}
-corner_list[n].info=7;
-
-free(cgx);
-free(cgy);
-
-}
-
-/* }}} */
-/* {{{ susan_quick(in,r,sf,max_no,corner_list) */
-
-susan_corners_quick(in,r,bp,max_no,corner_list,x_size,y_size)
-  uchar       *in, *bp;
-  int         *r, max_no, x_size, y_size;
-  CORNER_LIST corner_list;
-{
-int   n,x,y,i,j;
-uchar *p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  for (i=7;i<y_size-7;i++)
-    for (j=7;j<x_size-7;j++) {
-        n=100;
-        p=in + (i-3)*x_size + j - 1;
-        cp=bp + in[i*x_size+j];
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=2;
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-
-        if (n<max_no)
-          r[i*x_size+j] = max_no-n;
-}}}}}}}}}}}}}}}}}}}
-
-  /* to locate the local maxima */
-  n=0;
-  for (i=7;i<y_size-7;i++)
-    for (j=7;j<x_size-7;j++) {
-       x = r[i*x_size+j];
-       if (x>0)  {
-          /* 5x5 mask */
-#ifdef FIVE_SUPP
-          if (
-              (x>r[(i-1)*x_size+j+2]) &&
-              (x>r[(i  )*x_size+j+1]) &&
-              (x>r[(i  )*x_size+j+2]) &&
-              (x>r[(i+1)*x_size+j-1]) &&
-              (x>r[(i+1)*x_size+j  ]) &&
-              (x>r[(i+1)*x_size+j+1]) &&
-              (x>r[(i+1)*x_size+j+2]) &&
-              (x>r[(i+2)*x_size+j-2]) &&
-              (x>r[(i+2)*x_size+j-1]) &&
-              (x>r[(i+2)*x_size+j  ]) &&
-              (x>r[(i+2)*x_size+j+1]) &&
-              (x>r[(i+2)*x_size+j+2]) &&
-              (x>=r[(i-2)*x_size+j-2]) &&
-              (x>=r[(i-2)*x_size+j-1]) &&
-              (x>=r[(i-2)*x_size+j  ]) &&
-              (x>=r[(i-2)*x_size+j+1]) &&
-              (x>=r[(i-2)*x_size+j+2]) &&
-              (x>=r[(i-1)*x_size+j-2]) &&
-              (x>=r[(i-1)*x_size+j-1]) &&
-	      (x>=r[(i-1)*x_size+j  ]) &&
-	      (x>=r[(i-1)*x_size+j+1]) &&
-	      (x>=r[(i  )*x_size+j-2]) &&
-	      (x>=r[(i  )*x_size+j-1]) &&
-	      (x>=r[(i+1)*x_size+j-2]) )
-#endif
-#ifdef SEVEN_SUPP
-          if (
-                (x>r[(i-3)*x_size+j-3]) &&
-                (x>r[(i-3)*x_size+j-2]) &&
-                (x>r[(i-3)*x_size+j-1]) &&
-                (x>r[(i-3)*x_size+j  ]) &&
-                (x>r[(i-3)*x_size+j+1]) &&
-                (x>r[(i-3)*x_size+j+2]) &&
-                (x>r[(i-3)*x_size+j+3]) &&
-
-                (x>r[(i-2)*x_size+j-3]) &&
-                (x>r[(i-2)*x_size+j-2]) &&
-                (x>r[(i-2)*x_size+j-1]) &&
-                (x>r[(i-2)*x_size+j  ]) &&
-                (x>r[(i-2)*x_size+j+1]) &&
-                (x>r[(i-2)*x_size+j+2]) &&
-                (x>r[(i-2)*x_size+j+3]) &&
-
-                (x>r[(i-1)*x_size+j-3]) &&
-                (x>r[(i-1)*x_size+j-2]) &&
-                (x>r[(i-1)*x_size+j-1]) &&
-                (x>r[(i-1)*x_size+j  ]) &&
-                (x>r[(i-1)*x_size+j+1]) &&
-                (x>r[(i-1)*x_size+j+2]) &&
-                (x>r[(i-1)*x_size+j+3]) &&
-
-                (x>r[(i)*x_size+j-3]) &&
-                (x>r[(i)*x_size+j-2]) &&
-                (x>r[(i)*x_size+j-1]) &&
-                (x>=r[(i)*x_size+j+1]) &&
-                (x>=r[(i)*x_size+j+2]) &&
-                (x>=r[(i)*x_size+j+3]) &&
-
-                (x>=r[(i+1)*x_size+j-3]) &&
-                (x>=r[(i+1)*x_size+j-2]) &&
-                (x>=r[(i+1)*x_size+j-1]) &&
-                (x>=r[(i+1)*x_size+j  ]) &&
-                (x>=r[(i+1)*x_size+j+1]) &&
-                (x>=r[(i+1)*x_size+j+2]) &&
-                (x>=r[(i+1)*x_size+j+3]) &&
-
-                (x>=r[(i+2)*x_size+j-3]) &&
-                (x>=r[(i+2)*x_size+j-2]) &&
-                (x>=r[(i+2)*x_size+j-1]) &&
-                (x>=r[(i+2)*x_size+j  ]) &&
-                (x>=r[(i+2)*x_size+j+1]) &&
-                (x>=r[(i+2)*x_size+j+2]) &&
-                (x>=r[(i+2)*x_size+j+3]) &&
-
-                (x>=r[(i+3)*x_size+j-3]) &&
-                (x>=r[(i+3)*x_size+j-2]) &&
-                (x>=r[(i+3)*x_size+j-1]) &&
-                (x>=r[(i+3)*x_size+j  ]) &&
-                (x>=r[(i+3)*x_size+j+1]) &&
-                (x>=r[(i+3)*x_size+j+2]) &&
-                (x>=r[(i+3)*x_size+j+3]) )
-#endif
-{
-corner_list[n].info=0;
-corner_list[n].x=j;
-corner_list[n].y=i;
-x = in[(i-2)*x_size+j-2] + in[(i-2)*x_size+j-1] + in[(i-2)*x_size+j] + in[(i-2)*x_size+j+1] + in[(i-2)*x_size+j+2] +
-    in[(i-1)*x_size+j-2] + in[(i-1)*x_size+j-1] + in[(i-1)*x_size+j] + in[(i-1)*x_size+j+1] + in[(i-1)*x_size+j+2] +
-    in[(i  )*x_size+j-2] + in[(i  )*x_size+j-1] + in[(i  )*x_size+j] + in[(i  )*x_size+j+1] + in[(i  )*x_size+j+2] +
-    in[(i+1)*x_size+j-2] + in[(i+1)*x_size+j-1] + in[(i+1)*x_size+j] + in[(i+1)*x_size+j+1] + in[(i+1)*x_size+j+2] +
-    in[(i+2)*x_size+j-2] + in[(i+2)*x_size+j-1] + in[(i+2)*x_size+j] + in[(i+2)*x_size+j+1] + in[(i+2)*x_size+j+2];
-
-corner_list[n].I=x/25;
-/*corner_list[n].I=in[i*x_size+j];*/
-x = in[(i-2)*x_size+j+2] + in[(i-1)*x_size+j+2] + in[(i)*x_size+j+2] + in[(i+1)*x_size+j+2] + in[(i+2)*x_size+j+2] -
-   (in[(i-2)*x_size+j-2] + in[(i-1)*x_size+j-2] + in[(i)*x_size+j-2] + in[(i+1)*x_size+j-2] + in[(i+2)*x_size+j-2]);
-x += x + in[(i-2)*x_size+j+1] + in[(i-1)*x_size+j+1] + in[(i)*x_size+j+1] + in[(i+1)*x_size+j+1] + in[(i+2)*x_size+j+1] -
-        (in[(i-2)*x_size+j-1] + in[(i-1)*x_size+j-1] + in[(i)*x_size+j-1] + in[(i+1)*x_size+j-1] + in[(i+2)*x_size+j-1]);
-
-y = in[(i+2)*x_size+j-2] + in[(i+2)*x_size+j-1] + in[(i+2)*x_size+j] + in[(i+2)*x_size+j+1] + in[(i+2)*x_size+j+2] -
-   (in[(i-2)*x_size+j-2] + in[(i-2)*x_size+j-1] + in[(i-2)*x_size+j] + in[(i-2)*x_size+j+1] + in[(i-2)*x_size+j+2]);
-y += y + in[(i+1)*x_size+j-2] + in[(i+1)*x_size+j-1] + in[(i+1)*x_size+j] + in[(i+1)*x_size+j+1] + in[(i+1)*x_size+j+2] -
-        (in[(i-1)*x_size+j-2] + in[(i-1)*x_size+j-1] + in[(i-1)*x_size+j] + in[(i-1)*x_size+j+1] + in[(i-1)*x_size+j+2]);
-corner_list[n].dx=x/15;
-corner_list[n].dy=y/15;
-n++;
-if(n==MAX_CORNERS){
-      fprintf(stderr,"Too many corners.\n");
-      exit(1);
-         }}}}
-corner_list[n].info=7;
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ main(argc, argv) */
-
-CORNER_LIST corner_list;
-main(argc, argv)
-  int   argc;
-  char  *argv [];
-{
-/* {{{ vars */
-
-FILE   *ofp;
-char   filename [80],
-       *tcp;
-uchar  *in, *bp, *mid;
-float  dt=4.0;
-int    *r,
-       argindex=3,
-       bt=20,
-       principle=0,
-       thin_post_proc=1,
-       three_by_three=0,
-       drawing_mode=0,
-       susan_quick=0,
-       max_no_corners=1850,
-       max_no_edges=2650,
-       mode = 0, i,
-       x_size, y_size;
-
-/* }}} */
-
-  if (argc<3)
-    usage();
-
-printf("before get_image\n");
-
-  get_image(argv[1],&in,&x_size,&y_size);
-
-printf("look at options\n");
-
-  /* {{{ look at options */
-
-  while (argindex < argc)
-  {
-    tcp = argv[argindex];
-    if (*tcp == '-')
-      switch (*++tcp)
-      {
-        case 's': /* smoothing */
-          mode=0;
-	  break;
-        case 'e': /* edges */
-          mode=1;
-	  break;
-        case 'c': /* corners */
-          mode=2;
-	  break;
-        case 'p': /* principle */
-          principle=1;
-	  break;
-        case 'n': /* thinning post processing */
-          thin_post_proc=0;
-	  break;
-        case 'b': /* simple drawing mode */
-          drawing_mode=1;
-	  break;
-        case '3': /* 3x3 flat mask */
-          three_by_three=1;
-	  break;
-        case 'q': /* quick susan mask */
-          susan_quick=1;
-	  break;
-	case 'd': /* distance threshold */
-          if (++argindex >= argc){
-	    printf ("No argument following -d\n");
-	    exit(0);}
-	  dt=atof(argv[argindex]);
-          if (dt<0) three_by_three=1;
-	  break;
-	case 't': /* brightness threshold */
-          if (++argindex >= argc){
-	    printf ("No argument following -t\n");
-	    exit(0);}
-	  bt=atoi(argv[argindex]);
-	  break;
-      }
-      else
-        usage();
-    argindex++;
-  }
-
-  if ( (principle==1) && (mode==0) )
-    mode=1;
-printf("begin main processing\n");
-/* }}} */
-  /* {{{ main processing */
-
-  switch (mode)
-  {
-    case 0:
-      /* {{{ smoothing */
-
-      setup_brightness_lut(&bp,bt,2);
-      susan_smoothing(three_by_three,in,dt,x_size,y_size,bp);
-      break;
-
-/* }}} */
-    case 1:
-      /* {{{ edges */
-
-      r   = (int *) malloc(x_size * y_size * sizeof(int));
-      setup_brightness_lut(&bp,bt,6);
-
-      if (principle)
-      {
-        if (three_by_three)
-          susan_principle_small(in,r,bp,max_no_edges,x_size,y_size);
-        else
-          susan_principle(in,r,bp,max_no_edges,x_size,y_size);
-        int_to_uchar(r,in,x_size*y_size);
-      }
-      else
-      {
-        mid = (uchar *)malloc(x_size*y_size);
-        memset (mid,100,x_size * y_size); /* note not set to zero */
-
-        if (three_by_three)
-          susan_edges_small(in,r,mid,bp,max_no_edges,x_size,y_size);
-        else
-          susan_edges(in,r,mid,bp,max_no_edges,x_size,y_size);
-        if(thin_post_proc)
-          susan_thin(r,mid,x_size,y_size);
-        edge_draw(in,mid,x_size,y_size,drawing_mode);
-      }
-
-      break;
-
-/* }}} */
-    case 2:
-      /* {{{ corners */
-
-      r   = (int *) malloc(x_size * y_size * sizeof(int));
-      setup_brightness_lut(&bp,bt,6);
-
-      if (principle)
-      {
-        susan_principle(in,r,bp,max_no_corners,x_size,y_size);
-        int_to_uchar(r,in,x_size*y_size);
-      }
-      else
-      {
-        if(susan_quick)
-          susan_corners_quick(in,r,bp,max_no_corners,corner_list,x_size,y_size);
-        else
-          susan_corners(in,r,bp,max_no_corners,corner_list,x_size,y_size);
-        corner_draw(in,corner_list,x_size,drawing_mode);
-      }
-
-      break;
-
-/* }}} */
-  }
-
-/* }}} */
-
-  put_image(argv[2],in,x_size,y_size);
-}
-
-/* }}} */
-
-rtems_task Init(
-  rtems_task_argument ignored
-)
-{
-
-
-  char in_file[20] = "/input_small.pgm";
-
-  printf("Unpacking tar filesystem\nThis may take awhile...\n");
-  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
-    printf("Can't unpack tar filesystem\n");
-    exit(1);
-  }
-
-
-  printf( "\n\n*** susan_corners benchmark ***\n" );
-
-  char * argv[] = {"susan_corners","/input_small.pgm", "/susan_corners.pgm","-c"};
-  main(4,argv);
-
-  printf( "*** end of susan_corners benchmark ***\n" );
-  exit( 0 );
-}
-
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_corners/LICENSE rtems-hwpq-dev/testsuites/mibench/susan_corners/LICENSE
--- rtems-base/testsuites/mibench/susan_corners/LICENSE	2011-01-30 18:51:06.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_corners/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-This code is issued for research purposes only and remains the
-property of the UK Secretary of State for Defence. This code must
-not be passed on without this header information being kept
-intact. This code must not be sold.
-
-A UK patent has been granted: "Method for digitally processing
-images to determine the position of edges and/or corners therein for
-guidance of unmanned vehicle", UK Patent 2272285. Proprietor:
-Secretary of State for Defence, UK. 15 January 1997
-
-
-Source Code obtained from:
-
-http://www.fmrib.ox.ac.uk/~steve/susan/index.html
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_corners/Makefile.am rtems-hwpq-dev/testsuites/mibench/susan_corners/Makefile.am
--- rtems-base/testsuites/mibench/susan_corners/Makefile.am	2011-01-30 13:55:22.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_corners/Makefile.am	2011-01-10 12:53:36.000000000 -0500
@@ -15,7 +15,6 @@ include $(top_srcdir)/../automake/compil
 include $(top_srcdir)/../automake/leaf.am
 
 susan_corners_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
-susan_corners_LDLIBS = -lm
 
 LINK_OBJS = $(susan_corners_OBJECTS) $(susan_corners_LDADD)
 LINK_LIBS = $(susan_corners_LDLIBS)
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_corners/susan.c rtems-hwpq-dev/testsuites/mibench/susan_corners/susan.c
--- rtems-base/testsuites/mibench/susan_corners/susan.c	1969-12-31 19:00:00.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_corners/susan.c	2011-01-10 12:53:36.000000000 -0500
@@ -0,0 +1,2122 @@
+/* {{{ Copyright etc. */
+
+/**********************************************************************\
+
+  SUSAN Version 2l by Stephen Smith
+  Oxford Centre for Functional Magnetic Resonance Imaging of the Brain,
+  Department of Clinical Neurology, Oxford University, Oxford, UK
+  (Previously in Computer Vision and Image Processing Group - now
+  Computer Vision and Electro Optics Group - DERA Chertsey, UK)
+  Email:    steve@fmrib.ox.ac.uk
+  WWW:      http://www.fmrib.ox.ac.uk/~steve
+
+  (C) Crown Copyright (1995-1999), Defence Evaluation and Research Agency,
+  Farnborough, Hampshire, GU14 6TD, UK
+  DERA WWW site:
+  http://www.dera.gov.uk/
+  DERA Computer Vision and Electro Optics Group WWW site:
+  http://www.dera.gov.uk/imageprocessing/dera/group_home.html
+  DERA Computer Vision and Electro Optics Group point of contact:
+  Dr. John Savage, jtsavage@dera.gov.uk, +44 1344 633203
+
+  A UK patent has been granted: "Method for digitally processing
+  images to determine the position of edges and/or corners therein for
+  guidance of unmanned vehicle", UK Patent 2272285. Proprietor:
+  Secretary of State for Defence, UK. 15 January 1997
+
+  This code is issued for research purposes only and remains the
+  property of the UK Secretary of State for Defence. This code must
+  not be passed on without this header information being kept
+  intact. This code must not be sold.
+
+\**********************************************************************/
+
+/* }}} */
+/* {{{ Readme First */
+
+/**********************************************************************\
+
+  SUSAN Version 2l
+  SUSAN = Smallest Univalue Segment Assimilating Nucleus
+
+  Email:    steve@fmrib.ox.ac.uk
+  WWW:      http://www.fmrib.ox.ac.uk/~steve
+
+  Related paper:
+  @article{Smith97,
+        author = "Smith, S.M. and Brady, J.M.",
+        title = "{SUSAN} - A New Approach to Low Level Image Processing",
+        journal = "Int. Journal of Computer Vision",
+        pages = "45--78",
+        volume = "23",
+        number = "1",
+        month = "May",
+        year = 1997}
+
+  To be registered for automatic (bug) updates of SUSAN, send an email.
+
+  Compile with:
+  gcc -O4 -o susan susan2l.c -lm
+
+  See following section for different machine information. Please
+  report any bugs (and fixes). There are a few optional changes that
+  can be made in the "defines" section which follows shortly.
+
+  Usage: type "susan" to get usage. Only PGM format files can be input
+  and output. Utilities such as the netpbm package and XV can be used
+  to convert to and from other formats. Any size of image can be
+  processed.
+
+  This code is written using an emacs folding mode, making moving
+  around the different sections very easy. This is why there are
+  various marks within comments and why comments are indented.
+
+
+  SUSAN QUICK:
+
+  This version of the SUSAN corner finder does not do all the
+  false-corner suppression and thus is faster and produced some false
+  positives, particularly on strong edges. However, because there are
+  less stages involving thresholds etc., the corners that are
+  correctly reported are usually more stable than those reported with
+  the full algorithm. Thus I recommend at least TRYING this algorithm
+  for applications where stability is important, e.g., tracking.
+
+  THRESHOLDS:
+
+  There are two thresholds which can be set at run-time. These are the
+  brightness threshold (t) and the distance threshold (d).
+
+  SPATIAL CONTROL: d
+
+  In SUSAN smoothing d controls the size of the Gaussian mask; its
+  default is 4.0. Increasing d gives more smoothing. In edge finding,
+  a fixed flat mask is used, either 37 pixels arranged in a "circle"
+  (default), or a 3 by 3 mask which gives finer detail. In corner
+  finding, only the larger 37 pixel mask is used; d is not
+  variable. In smoothing, the flat 3 by 3 mask can be used instead of
+  a larger Gaussian mask; this gives low smoothing and fast operation.
+
+  BRIGHTNESS CONTROL: t
+
+  In all three algorithms, t can be varied (default=20); this is the
+  main threshold to be varied. It determines the maximum difference in
+  greylevels between two pixels which allows them to be considered
+  part of the same "region" in the image. Thus it can be reduced to
+  give more edges or corners, i.e. to be more sensitive, and vice
+  versa. In smoothing, reducing t gives less smoothing, and vice
+  versa. Set t=10 for the test image available from the SUSAN web
+  page.
+
+  ITERATIONS:
+
+  With SUSAN smoothing, more smoothing can also be obtained by
+  iterating the algorithm several times. This has a different effect
+  from varying d or t.
+
+  FIXED MASKS:
+
+  37 pixel mask:    ooo       3 by 3 mask:  ooo
+                   ooooo                    ooo
+                  ooooooo                   ooo
+                  ooooooo
+                  ooooooo
+                   ooooo
+                    ooo
+
+  CORNER ATTRIBUTES dx, dy and I
+  (Only read this if you are interested in the C implementation or in
+  using corner attributes, e.g., for corner matching)
+
+  Corners reported in the corner list have attributes associated with
+  them as well as positions. This is useful, for example, when
+  attempting to match corners from one image to another, as these
+  attributes can often be fairly unchanged between images. The
+  attributes are dx, dy and I. I is the value of image brightness at
+  the position of the corner. In the case of susan_corners_quick, dx
+  and dy are the first order derivatives (differentials) of the image
+  brightness in the x and y directions respectively, at the position
+  of the corner. In the case of normal susan corner finding, dx and dy
+  are scaled versions of the position of the centre of gravity of the
+  USAN with respect to the centre pixel (nucleus).
+
+  BRIGHTNESS FUNCTION LUT IMPLEMENTATION:
+  (Only read this if you are interested in the C implementation)
+
+  The SUSAN brightness function is implemented as a LUT
+  (Look-Up-Table) for speed. The resulting pointer-based code is a
+  little hard to follow, so here is a brief explanation. In
+  setup_brightness_lut() the LUT is setup. This mallocs enough space
+  for *bp and then repositions the pointer to the centre of the
+  malloced space. The SUSAN function e^-(x^6) or e^-(x^2) is
+  calculated and converted to a uchar in the range 0-100, for all
+  possible image brightness differences (including negative
+  ones). Thus bp[23] is the output for a brightness difference of 23
+  greylevels. In the SUSAN algorithms this LUT is used as follows:
+
+  p=in + (i-3)*x_size + j - 1;
+  p points to the first image pixel in the circular mask surrounding
+  point (x,y).
+
+  cp=bp + in[i*x_size+j];
+  cp points to a position in the LUT corresponding to the brightness
+  of the centre pixel (x,y).
+
+  now for every pixel within the mask surrounding (x,y),
+  n+=*(cp-*p++);
+  the brightness difference function is found by moving the cp pointer
+  down by an amount equal to the value of the pixel pointed to by p,
+  thus subtracting the two brightness values and performing the
+  exponential function. This value is added to n, the running USAN
+  area.
+
+  in SUSAN smoothing, the variable height mask is implemented by
+  multiplying the above by the moving mask pointer, reset for each new
+  centre pixel.
+  tmp = *dpt++ * *(cp-brightness);
+
+\**********************************************************************/
+
+/* }}} */
+/* {{{ Machine Information */
+
+/**********************************************************************\
+
+  Success has been reported with the following:
+
+  MACHINE  OS         COMPILER
+
+  Sun      4.1.4      bundled C, gcc
+
+  Next
+
+  SGI      IRIX       SGI cc
+
+  DEC      Unix V3.2+ 
+
+  IBM RISC AIX        gcc
+
+  PC                  Borland 5.0
+
+  PC       Linux      gcc-2.6.3
+
+  PC       Win32      Visual C++ 4.0 (Console Application)
+
+  PC       Win95      Visual C++ 5.0 (Console Application)
+                      Thanks to Niu Yongsheng <niuysbit@163.net>:
+                      Use the FOPENB option below
+
+  PC       DOS        djgpp gnu C
+                      Thanks to Mark Pettovello <mpettove@umdsun2.umd.umich.edu>:
+                      Use the FOPENB option below
+
+  HP       HP-UX      bundled cc
+                      Thanks to Brian Dixon <briand@hpcvsgen.cv.hp.com>:
+                      in ksh:
+                      export CCOPTS="-Aa -D_HPUX_SOURCE | -lM"
+                      cc -O3 -o susan susan2l.c
+
+\**********************************************************************/
+
+/* }}} */
+/* {{{ History */
+
+/**********************************************************************\
+
+  SUSAN Version 2l, 12/2/99
+  Changed GNUDOS option to FOPENB.
+  (Thanks to Niu Yongsheng <niuysbit@163.net>.)
+  Took out redundant "sq=sq/2;".
+
+  SUSAN Version 2k, 19/8/98:
+  In corner finding:
+  Changed if(yy<sq) {...} else if(xx<sq) {...} to
+          if(yy<xx) {...} else {...}
+  (Thanks to adq@cim.mcgill.edu - Alain Domercq.)
+
+  SUSAN Version 2j, 22/10/97:
+  Fixed (mask_size>x_size) etc. tests in smoothing.
+  Added a couple of free() calls for cgx and cgy.
+  (Thanks to geoffb@ucs.ed.ac.uk - Geoff Browitt.)
+
+  SUSAN Version 2i, 21/7/97:
+  Added information about corner attributes.
+
+  SUSAN Version 2h, 16/12/96:
+  Added principle (initial enhancement) option.
+
+  SUSAN Version 2g, 2/7/96:
+  Minor superficial changes to code.
+
+  SUSAN Version 2f, 16/1/96:
+  Added GNUDOS option (now called FOPENB; see options below).
+
+  SUSAN Version 2e, 9/1/96:
+  Added -b option.
+  Fixed 1 pixel horizontal offset error for drawing edges.
+
+  SUSAN Version 2d, 27/11/95:
+  Fixed loading of certain PGM files in get_image (again!)
+
+  SUSAN Version 2c, 22/11/95:
+  Fixed loading of certain PGM files in get_image.
+  (Thanks to qu@San-Jose.ate.slb.com - Gongyuan Qu.)
+
+  SUSAN Version 2b, 9/11/95:
+  removed "z==" error in edges routines.
+
+  SUSAN Version 2a, 6/11/95:
+  Removed a few unnecessary variable declarations.
+  Added different machine information.
+  Changed "header" in get_image to char.
+
+  SUSAN Version 2, 1/11/95: first combined version able to take any
+  image sizes.
+
+  SUSAN "Versions 1", circa 1992: the various SUSAN algorithms were
+  developed during my doctorate within different programs and for
+  fixed image sizes. The algorithms themselves are virtually unaltered
+  between "versions 1" and the combined program, version 2.
+
+\**********************************************************************/
+
+/* }}} */
+/* {{{ defines, includes and typedefs */
+
+/* ********** Optional settings */
+
+#ifndef PPC
+typedef int        TOTAL_TYPE; /* this is faster for "int" but should be "float" for large d masks */
+#else
+typedef float      TOTAL_TYPE; /* for my PowerPC accelerator only */
+#endif
+
+/*#define FOPENB*/           /* uncomment if using djgpp gnu C for DOS or certain Win95 compilers */
+#define SEVEN_SUPP           /* size for non-max corner suppression; SEVEN_SUPP or FIVE_SUPP */
+#define MAX_CORNERS   15000  /* max corners per frame */
+
+/* ********** Leave the rest - but you may need to remove one or both of sys/file.h and malloc.h lines */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <sys/file.h>    /* may want to remove this line */
+#include <malloc.h>      /* may want to remove this line */
+#define  exit_error(IFB,IFC) { fprintf(stderr,IFB,IFC); exit(0); }
+#define  FTOI(a) ( (a) < 0 ? ((int)(a-0.5)) : ((int)(a+0.5)) )
+typedef  unsigned char uchar;
+typedef  struct {int x,y,info, dx, dy, I;} CORNER_LIST[MAX_CORNERS];
+
+/* }}} */
+/* {{{ usage() */
+
+usage()
+{
+  printf("Usage: susan <in.pgm> <out.pgm> [options]\n\n");
+
+  printf("-s : Smoothing mode (default)\n");
+  printf("-e : Edges mode\n");
+  printf("-c : Corners mode\n\n");
+
+  printf("See source code for more information about setting the thresholds\n");
+  printf("-t <thresh> : Brightness threshold, all modes (default=20)\n");
+  printf("-d <thresh> : Distance threshold, smoothing mode, (default=4) (use next option instead for flat 3x3 mask)\n");
+  printf("-3 : Use flat 3x3 mask, edges or smoothing mode\n");
+  printf("-n : No post-processing on the binary edge map (runs much faster); edges mode\n");
+  printf("-q : Use faster (and usually stabler) corner mode; edge-like corner suppression not carried out; corners mode\n");
+  printf("-b : Mark corners/edges with single black points instead of black with white border; corners or edges mode\n");
+  printf("-p : Output initial enhancement image only; corners or edges mode (default is edges mode)\n");
+
+  printf("\nSUSAN Version 2l (C) 1995-1997 Stephen Smith, DRA UK. steve@fmrib.ox.ac.uk\n");
+
+  exit(0);
+}
+
+/* }}} */
+/* {{{ get_image(filename,in,x_size,y_size) */
+
+/* {{{ int getint(fp) derived from XV */
+
+int getint(fd)
+  FILE *fd;
+{
+  int c, i;
+  char dummy[10000];
+
+  c = getc(fd);
+  while (1) /* find next integer */
+  {
+    if (c=='#')    /* if we're at a comment, read to end of line */
+      fgets(dummy,9000,fd);
+    if (c==EOF)
+      exit_error("Image %s not binary PGM.\n","is");
+    if (c>='0' && c<='9')
+      break;   /* found what we were looking for */
+    c = getc(fd);
+  }
+
+  /* we're at the start of a number, continue until we hit a non-number */
+  i = 0;
+  while (1) {
+    i = (i*10) + (c - '0');
+    c = getc(fd);
+    if (c==EOF) return (i);
+    if (c<'0' || c>'9') break;
+  }
+
+  return (i);
+}
+
+/* }}} */
+
+void get_image(filename,in,x_size,y_size)
+  char           filename[200];
+  unsigned char  **in;
+  int            *x_size, *y_size;
+{
+FILE  *fd;
+char header [100];
+int  tmp;
+
+#ifdef FOPENB
+  if ((fd=fopen(filename,"rb")) == NULL)
+#else
+  if ((fd=fopen(filename,"r")) == NULL)
+#endif
+    exit_error("Can't input image %s.\n",filename);
+
+  /* {{{ read header */
+
+  header[0]=fgetc(fd);
+  header[1]=fgetc(fd);
+  if(!(header[0]=='P' && header[1]=='5'))
+    exit_error("Image %s does not have binary PGM header.\n",filename);
+
+  *x_size = getint(fd);
+  *y_size = getint(fd);
+  tmp = getint(fd);
+
+/* }}} */
+
+  *in = (uchar *) malloc(*x_size * *y_size);
+
+  if (fread(*in,1,*x_size * *y_size,fd) == 0)
+    exit_error("Image %s is wrong size.\n",filename);
+
+  fclose(fd);
+}
+
+/* }}} */
+/* {{{ put_image(filename,in,x_size,y_size) */
+
+put_image(filename,in,x_size,y_size)
+  char filename [100],
+       *in;
+  int  x_size,
+       y_size;
+{
+FILE  *fd;
+
+#ifdef FOPENB
+  if ((fd=fopen(filename,"wb")) == NULL) 
+#else
+  if ((fd=fopen(filename,"w")) == NULL) 
+#endif
+    exit_error("Can't output image%s.\n",filename);
+
+  fprintf(fd,"P5\n");
+  fprintf(fd,"%d %d\n",x_size,y_size);
+  fprintf(fd,"255\n");
+  
+  if (fwrite(in,x_size*y_size,1,fd) != 1)
+    exit_error("Can't write image %s.\n",filename);
+
+  fclose(fd);
+}
+
+/* }}} */
+/* {{{ int_to_uchar(r,in,size) */
+
+int_to_uchar(r,in,size)
+  uchar *in;
+  int   *r, size;
+{
+int i,
+    max_r=r[0],
+    min_r=r[0];
+
+  for (i=0; i<size; i++)
+    {
+      if ( r[i] > max_r )
+        max_r=r[i];
+      if ( r[i] < min_r )
+        min_r=r[i];
+    }
+
+  /*printf("min=%d max=%d\n",min_r,max_r);*/
+
+  max_r-=min_r;
+
+  for (i=0; i<size; i++)
+    in[i] = (uchar)((int)((int)(r[i]-min_r)*255)/max_r);
+}
+
+/* }}} */
+/* {{{ setup_brightness_lut(bp,thresh,form) */
+
+void setup_brightness_lut(bp,thresh,form)
+  uchar **bp;
+  int   thresh, form;
+{
+int   k;
+float temp;
+
+  *bp=(unsigned char *)malloc(516);
+  *bp=*bp+258;
+
+  for(k=-256;k<257;k++)
+  {
+    temp=((float)k)/((float)thresh);
+    temp=temp*temp;
+    if (form==6)
+      temp=temp*temp*temp;
+    temp=100.0*exp(-temp);
+    *(*bp+k)= (uchar)temp;
+  }
+}
+
+/* }}} */
+/* {{{ susan principle */
+
+/* {{{ susan_principle(in,r,bp,max_no,x_size,y_size) */
+
+susan_principle(in,r,bp,max_no,x_size,y_size)
+  uchar *in, *bp;
+  int   *r, max_no, x_size, y_size;
+{
+int   i, j, n;
+uchar *p,*cp;
+
+  memset (r,0,x_size * y_size * sizeof(int));
+
+  for (i=3;i<y_size-3;i++)
+    for (j=3;j<x_size-3;j++)
+    {
+      n=100;
+      p=in + (i-3)*x_size + j - 1;
+      cp=bp + in[i*x_size+j];
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-3; 
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-5;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-6;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=2;
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-6;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-5;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-3;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+
+      if (n<=max_no)
+        r[i*x_size+j] = max_no - n;
+    }
+}
+
+/* }}} */
+/* {{{ susan_principle_small(in,r,bp,max_no,x_size,y_size) */
+
+susan_principle_small(in,r,bp,max_no,x_size,y_size)
+  uchar *in, *bp;
+  int   *r, max_no, x_size, y_size;
+{
+int   i, j, n;
+uchar *p,*cp;
+
+  memset (r,0,x_size * y_size * sizeof(int));
+
+  max_no = 730; /* ho hum ;) */
+
+  for (i=1;i<y_size-1;i++)
+    for (j=1;j<x_size-1;j++)
+    {
+      n=100;
+      p=in + (i-1)*x_size + j - 1;
+      cp=bp + in[i*x_size+j];
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-2; 
+
+      n+=*(cp-*p);
+      p+=2;
+      n+=*(cp-*p);
+      p+=x_size-2;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+
+      if (n<=max_no)
+        r[i*x_size+j] = max_no - n;
+    }
+}
+
+/* }}} */
+
+/* }}} */
+/* {{{ smoothing */
+
+/* {{{ median(in,i,j,x_size) */
+
+uchar median(in,i,j,x_size)
+  uchar *in;
+  int   i, j, x_size;
+{
+int p[8],k,l,tmp;
+
+  p[0]=in[(i-1)*x_size+j-1];
+  p[1]=in[(i-1)*x_size+j  ];
+  p[2]=in[(i-1)*x_size+j+1];
+  p[3]=in[(i  )*x_size+j-1];
+  p[4]=in[(i  )*x_size+j+1];
+  p[5]=in[(i+1)*x_size+j-1];
+  p[6]=in[(i+1)*x_size+j  ];
+  p[7]=in[(i+1)*x_size+j+1];
+
+  for(k=0; k<7; k++)
+    for(l=0; l<(7-k); l++)
+      if (p[l]>p[l+1])
+      {
+        tmp=p[l]; p[l]=p[l+1]; p[l+1]=tmp;
+      }
+
+  return( (p[3]+p[4]) / 2 );
+}
+
+/* }}} */
+/* {{{ enlarge(in,tmp_image,x_size,y_size,border) */
+
+/* this enlarges "in" so that borders can be dealt with easily */
+
+enlarge(in,tmp_image,x_size,y_size,border)
+  uchar **in;
+  uchar *tmp_image;
+  int   *x_size, *y_size, border;
+{
+int   i, j;
+
+  for(i=0; i<*y_size; i++)   /* copy *in into tmp_image */
+    memcpy(tmp_image+(i+border)*(*x_size+2*border)+border, *in+i* *x_size, *x_size);
+
+  for(i=0; i<border; i++) /* copy top and bottom rows; invert as many as necessary */
+  {
+    memcpy(tmp_image+(border-1-i)*(*x_size+2*border)+border,*in+i* *x_size,*x_size);
+    memcpy(tmp_image+(*y_size+border+i)*(*x_size+2*border)+border,*in+(*y_size-i-1)* *x_size,*x_size);
+  }
+
+  for(i=0; i<border; i++) /* copy left and right columns */
+    for(j=0; j<*y_size+2*border; j++)
+    {
+      tmp_image[j*(*x_size+2*border)+border-1-i]=tmp_image[j*(*x_size+2*border)+border+i];
+      tmp_image[j*(*x_size+2*border)+ *x_size+border+i]=tmp_image[j*(*x_size+2*border)+ *x_size+border-1-i];
+    }
+
+  *x_size+=2*border;  /* alter image size */
+  *y_size+=2*border;
+  *in=tmp_image;      /* repoint in */
+}
+
+/* }}} */
+/* {{{ void susan_smoothing(three_by_three,in,dt,x_size,y_size,bp) */
+
+void susan_smoothing(three_by_three,in,dt,x_size,y_size,bp)
+  int   three_by_three, x_size, y_size;
+  uchar *in, *bp;
+  float dt;
+{
+/* {{{ vars */
+
+float temp;
+int   n_max, increment, mask_size,
+      i,j,x,y,area,brightness,tmp,centre;
+uchar *ip, *dp, *dpt, *cp, *out=in,
+      *tmp_image;
+TOTAL_TYPE total;
+
+/* }}} */
+
+  /* {{{ setup larger image and border sizes */
+
+  if (three_by_three==0)
+    mask_size = ((int)(1.5 * dt)) + 1;
+  else
+    mask_size = 1;
+
+  total=0.1; /* test for total's type */
+  if ( (dt>15) && (total==0) )
+  {
+    printf("Distance_thresh (%f) too big for integer arithmetic.\n",dt);
+    printf("Either reduce it to <=15 or recompile with variable \"total\"\n");
+    printf("as a float: see top \"defines\" section.\n");
+    exit(0);
+  }
+
+  if ( (2*mask_size+1>x_size) || (2*mask_size+1>y_size) )
+  {
+    printf("Mask size (1.5*distance_thresh+1=%d) too big for image (%dx%d).\n",mask_size,x_size,y_size);
+    exit(0);
+  }
+
+  tmp_image = (uchar *) malloc( (x_size+mask_size*2) * (y_size+mask_size*2) );
+  enlarge(&in,tmp_image,&x_size,&y_size,mask_size);
+
+/* }}} */
+
+  if (three_by_three==0)
+  {     /* large Gaussian masks */
+    /* {{{ setup distance lut */
+
+  n_max = (mask_size*2) + 1;
+
+  increment = x_size - n_max;
+
+  dp     = (unsigned char *)malloc(n_max*n_max);
+  dpt    = dp;
+  temp   = -(dt*dt);
+
+  for(i=-mask_size; i<=mask_size; i++)
+    for(j=-mask_size; j<=mask_size; j++)
+    {
+      x = (int) (100.0 * exp( ((float)((i*i)+(j*j))) / temp ));
+      *dpt++ = (unsigned char)x;
+    }
+
+/* }}} */
+    /* {{{ main section */
+
+  for (i=mask_size;i<y_size-mask_size;i++)
+  {
+    for (j=mask_size;j<x_size-mask_size;j++)
+    {
+      area = 0;
+      total = 0;
+      dpt = dp;
+      ip = in + ((i-mask_size)*x_size) + j - mask_size;
+      centre = in[i*x_size+j];
+      cp = bp + centre;
+      for(y=-mask_size; y<=mask_size; y++)
+      {
+        for(x=-mask_size; x<=mask_size; x++)
+	{
+          brightness = *ip++;
+          tmp = *dpt++ * *(cp-brightness);
+          area += tmp;
+          total += tmp * brightness;
+        }
+        ip += increment;
+      }
+      tmp = area-10000;
+      if (tmp==0)
+        *out++=median(in,i,j,x_size);
+      else
+        *out++=((total-(centre*10000))/tmp);
+    }
+  }
+
+/* }}} */
+  }
+  else
+  {     /* 3x3 constant mask */
+    /* {{{ main section */
+
+  for (i=1;i<y_size-1;i++)
+  {
+    for (j=1;j<x_size-1;j++)
+    {
+      area = 0;
+      total = 0;
+      ip = in + ((i-1)*x_size) + j - 1;
+      centre = in[i*x_size+j];
+      cp = bp + centre;
+
+      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      ip += x_size-2;
+      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      ip += x_size-2;
+      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
+
+      tmp = area-100;
+      if (tmp==0)
+        *out++=median(in,i,j,x_size);
+      else
+        *out++=(total-(centre*100))/tmp;
+    }
+  }
+
+/* }}} */
+  }
+}
+
+/* }}} */
+
+/* }}} */
+/* {{{ edges */
+
+/* {{{ edge_draw(in,corner_list,drawing_mode) */
+
+edge_draw(in,mid,x_size,y_size,drawing_mode)
+  uchar *in, *mid;
+  int x_size, y_size, drawing_mode;
+{
+int   i;
+uchar *inp, *midp;
+
+  if (drawing_mode==0)
+  {
+    /* mark 3x3 white block around each edge point */
+    midp=mid;
+    for (i=0; i<x_size*y_size; i++)
+    {
+      if (*midp<8) 
+      {
+        inp = in + (midp - mid) - x_size - 1;
+        *inp++=255; *inp++=255; *inp=255; inp+=x_size-2;
+        *inp++=255; *inp++;     *inp=255; inp+=x_size-2;
+        *inp++=255; *inp++=255; *inp=255;
+      }
+      midp++;
+    }
+  }
+
+  /* now mark 1 black pixel at each edge point */
+  midp=mid;
+  for (i=0; i<x_size*y_size; i++)
+  {
+    if (*midp<8) 
+      *(in + (midp - mid)) = 0;
+    midp++;
+  }
+}
+
+/* }}} */
+/* {{{ susan_thin(r,mid,x_size,y_size) */
+
+/* only one pass is needed as i,j are decremented if necessary to go
+   back and do bits again */
+
+susan_thin(r,mid,x_size,y_size)
+  uchar *mid;
+  int   *r, x_size, y_size;
+{
+int   l[9], centre, nlinks, npieces,
+      b01, b12, b21, b10,
+      p1, p2, p3, p4,
+      b00, b02, b20, b22,
+      m, n, a, b, x, y, i, j;
+uchar *mp;
+
+  for (i=4;i<y_size-4;i++)
+    for (j=4;j<x_size-4;j++)
+      if (mid[i*x_size+j]<8)
+      {
+        centre = r[i*x_size+j];
+        /* {{{ count number of neighbours */
+
+        mp=mid + (i-1)*x_size + j-1;
+
+        n = (*mp<8) +
+            (*(mp+1)<8) +
+            (*(mp+2)<8) +
+            (*(mp+x_size)<8) +
+            (*(mp+x_size+2)<8) +
+            (*(mp+x_size+x_size)<8) +
+            (*(mp+x_size+x_size+1)<8) +
+            (*(mp+x_size+x_size+2)<8);
+
+/* }}} */
+        /* {{{ n==0 no neighbours - remove point */
+
+        if (n==0)
+          mid[i*x_size+j]=100;
+
+/* }}} */
+        /* {{{ n==1 - extend line if I can */
+
+        /* extension is only allowed a few times - the value of mid is used to control this */
+
+        if ( (n==1) && (mid[i*x_size+j]<6) )
+        {
+          /* find maximum neighbour weighted in direction opposite the
+             neighbour already present. e.g.
+             have: O O O  weight r by 0 2 3
+                   X X O              0 0 4
+                   O O O              0 2 3     */
+
+          l[0]=r[(i-1)*x_size+j-1]; l[1]=r[(i-1)*x_size+j]; l[2]=r[(i-1)*x_size+j+1];
+          l[3]=r[(i  )*x_size+j-1]; l[4]=0;                 l[5]=r[(i  )*x_size+j+1];
+          l[6]=r[(i+1)*x_size+j-1]; l[7]=r[(i+1)*x_size+j]; l[8]=r[(i+1)*x_size+j+1];
+
+          if (mid[(i-1)*x_size+j-1]<8)        { l[0]=0; l[1]=0; l[3]=0; l[2]*=2; 
+                                                l[6]*=2; l[5]*=3; l[7]*=3; l[8]*=4; }
+          else { if (mid[(i-1)*x_size+j]<8)   { l[1]=0; l[0]=0; l[2]=0; l[3]*=2; 
+                                                l[5]*=2; l[6]*=3; l[8]*=3; l[7]*=4; }
+          else { if (mid[(i-1)*x_size+j+1]<8) { l[2]=0; l[1]=0; l[5]=0; l[0]*=2; 
+                                                l[8]*=2; l[3]*=3; l[7]*=3; l[6]*=4; }
+          else { if (mid[(i)*x_size+j-1]<8)   { l[3]=0; l[0]=0; l[6]=0; l[1]*=2; 
+                                                l[7]*=2; l[2]*=3; l[8]*=3; l[5]*=4; }
+          else { if (mid[(i)*x_size+j+1]<8)   { l[5]=0; l[2]=0; l[8]=0; l[1]*=2; 
+                                                l[7]*=2; l[0]*=3; l[6]*=3; l[3]*=4; }
+          else { if (mid[(i+1)*x_size+j-1]<8) { l[6]=0; l[3]=0; l[7]=0; l[0]*=2; 
+                                                l[8]*=2; l[1]*=3; l[5]*=3; l[2]*=4; }
+          else { if (mid[(i+1)*x_size+j]<8)   { l[7]=0; l[6]=0; l[8]=0; l[3]*=2; 
+                                                l[5]*=2; l[0]*=3; l[2]*=3; l[1]*=4; }
+          else { if (mid[(i+1)*x_size+j+1]<8) { l[8]=0; l[5]=0; l[7]=0; l[6]*=2; 
+                                                l[2]*=2; l[1]*=3; l[3]*=3; l[0]*=4; } }}}}}}}
+
+          m=0;     /* find the highest point */
+          for(y=0; y<3; y++)
+            for(x=0; x<3; x++)
+              if (l[y+y+y+x]>m) { m=l[y+y+y+x]; a=y; b=x; }
+
+          if (m>0)
+          {
+            if (mid[i*x_size+j]<4)
+              mid[(i+a-1)*x_size+j+b-1] = 4;
+            else
+              mid[(i+a-1)*x_size+j+b-1] = mid[i*x_size+j]+1;
+            if ( (a+a+b) < 3 ) /* need to jump back in image */
+	    {
+              i+=a-1;
+              j+=b-2;
+              if (i<4) i=4;
+              if (j<4) j=4;
+	    }
+	  }
+        }
+
+/* }}} */
+        /* {{{ n==2 */
+
+        if (n==2)
+	{
+          /* put in a bit here to straighten edges */
+          b00 = mid[(i-1)*x_size+j-1]<8; /* corners of 3x3 */
+          b02 = mid[(i-1)*x_size+j+1]<8;
+	  b20 = mid[(i+1)*x_size+j-1]<8;
+          b22 = mid[(i+1)*x_size+j+1]<8;
+          if ( ((b00+b02+b20+b22)==2) && ((b00|b22)&(b02|b20)))
+	  {  /* case: move a point back into line.
+                e.g. X O X  CAN  become X X X
+                     O X O              O O O
+                     O O O              O O O    */
+            if (b00) 
+	    {
+              if (b02) { x=0; y=-1; }
+              else     { x=-1; y=0; }
+	    }
+            else
+	    {
+              if (b02) { x=1; y=0; }
+              else     { x=0; y=1; }
+	    }
+            if (((float)r[(i+y)*x_size+j+x]/(float)centre) > 0.7)
+	    {
+              if ( ( (x==0) && (mid[(i+(2*y))*x_size+j]>7) && (mid[(i+(2*y))*x_size+j-1]>7) && (mid[(i+(2*y))*x_size+j+1]>7) ) ||
+                   ( (y==0) && (mid[(i)*x_size+j+(2*x)]>7) && (mid[(i+1)*x_size+j+(2*x)]>7) && (mid[(i-1)*x_size+j+(2*x)]>7) ) )
+	      {
+                mid[(i)*x_size+j]=100;
+                mid[(i+y)*x_size+j+x]=3;  /* no jumping needed */
+	      }
+	    }
+	  }
+          else
+          {
+            b01 = mid[(i-1)*x_size+j  ]<8;
+            b12 = mid[(i  )*x_size+j+1]<8;
+            b21 = mid[(i+1)*x_size+j  ]<8;
+            b10 = mid[(i  )*x_size+j-1]<8;
+            /* {{{ right angle ends - not currently used */
+
+#ifdef IGNORETHIS
+            if ( (b00&b01)|(b00&b10)|(b02&b01)|(b02&b12)|(b20&b10)|(b20&b21)|(b22&b21)|(b22&b12) )
+	    { /* case; right angle ends. clean up.
+                 e.g.; X X O  CAN  become X X O
+                       O X O              O O O
+                       O O O              O O O        */
+              if ( ((b01)&(mid[(i-2)*x_size+j-1]>7)&(mid[(i-2)*x_size+j]>7)&(mid[(i-2)*x_size+j+1]>7)&
+                                    ((b00&((2*r[(i-1)*x_size+j+1])>centre))|(b02&((2*r[(i-1)*x_size+j-1])>centre)))) |
+                   ((b10)&(mid[(i-1)*x_size+j-2]>7)&(mid[(i)*x_size+j-2]>7)&(mid[(i+1)*x_size+j-2]>7)&
+                                    ((b00&((2*r[(i+1)*x_size+j-1])>centre))|(b20&((2*r[(i-1)*x_size+j-1])>centre)))) |
+                   ((b12)&(mid[(i-1)*x_size+j+2]>7)&(mid[(i)*x_size+j+2]>7)&(mid[(i+1)*x_size+j+2]>7)&
+                                    ((b02&((2*r[(i+1)*x_size+j+1])>centre))|(b22&((2*r[(i-1)*x_size+j+1])>centre)))) |
+                   ((b21)&(mid[(i+2)*x_size+j-1]>7)&(mid[(i+2)*x_size+j]>7)&(mid[(i+2)*x_size+j+1]>7)&
+                                    ((b20&((2*r[(i+1)*x_size+j+1])>centre))|(b22&((2*r[(i+1)*x_size+j-1])>centre)))) )
+	      {
+                mid[(i)*x_size+j]=100;
+                if (b10&b20) j-=2;
+                if (b00|b01|b02) { i--; j-=2; }
+  	      }
+	    }
+#endif
+
+/* }}} */
+            if ( ((b01+b12+b21+b10)==2) && ((b10|b12)&(b01|b21)) &&
+                 ((b01&((mid[(i-2)*x_size+j-1]<8)|(mid[(i-2)*x_size+j+1]<8)))|(b10&((mid[(i-1)*x_size+j-2]<8)|(mid[(i+1)*x_size+j-2]<8)))|
+                (b12&((mid[(i-1)*x_size+j+2]<8)|(mid[(i+1)*x_size+j+2]<8)))|(b21&((mid[(i+2)*x_size+j-1]<8)|(mid[(i+2)*x_size+j+1]<8)))) )
+	    { /* case; clears odd right angles.
+                 e.g.; O O O  becomes O O O
+                       X X O          X O O
+                       O X O          O X O     */
+              mid[(i)*x_size+j]=100;
+              i--;               /* jump back */
+              j-=2;
+              if (i<4) i=4;
+              if (j<4) j=4;
+	    }
+	  }
+	}
+
+/* }}} */
+        /* {{{ n>2 the thinning is done here without breaking connectivity */
+
+        if (n>2)
+        {
+          b01 = mid[(i-1)*x_size+j  ]<8;
+          b12 = mid[(i  )*x_size+j+1]<8;
+          b21 = mid[(i+1)*x_size+j  ]<8;
+          b10 = mid[(i  )*x_size+j-1]<8;
+          if((b01+b12+b21+b10)>1)
+          {
+            b00 = mid[(i-1)*x_size+j-1]<8;
+            b02 = mid[(i-1)*x_size+j+1]<8;
+	    b20 = mid[(i+1)*x_size+j-1]<8;
+	    b22 = mid[(i+1)*x_size+j+1]<8;
+            p1 = b00 | b01;
+            p2 = b02 | b12;
+            p3 = b22 | b21;
+            p4 = b20 | b10;
+
+            if( ((p1 + p2 + p3 + p4) - ((b01 & p2)+(b12 & p3)+(b21 & p4)+(b10 & p1))) < 2)
+            {
+              mid[(i)*x_size+j]=100;
+              i--;
+              j-=2;
+              if (i<4) i=4;
+              if (j<4) j=4;
+            }
+          }
+        }
+
+/* }}} */
+      }
+}
+
+/* }}} */
+/* {{{ susan_edges(in,r,sf,max_no,out) */
+
+susan_edges(in,r,mid,bp,max_no,x_size,y_size)
+  uchar *in, *bp, *mid;
+  int   *r, max_no, x_size, y_size;
+{
+float z;
+int   do_symmetry, i, j, m, n, a, b, x, y, w;
+uchar c,*p,*cp;
+
+  memset (r,0,x_size * y_size * sizeof(int));
+
+  for (i=3;i<y_size-3;i++)
+    for (j=3;j<x_size-3;j++)
+    {
+      n=100;
+      p=in + (i-3)*x_size + j - 1;
+      cp=bp + in[i*x_size+j];
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-3; 
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-5;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-6;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=2;
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-6;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-5;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-3;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+
+      if (n<=max_no)
+        r[i*x_size+j] = max_no - n;
+    }
+
+  for (i=4;i<y_size-4;i++)
+    for (j=4;j<x_size-4;j++)
+    {
+      if (r[i*x_size+j]>0)
+      {
+        m=r[i*x_size+j];
+        n=max_no - m;
+        cp=bp + in[i*x_size+j];
+
+        if (n>600)
+        {
+          p=in + (i-3)*x_size + j - 1;
+          x=0;y=0;
+
+          c=*(cp-*p++);x-=c;y-=3*c;
+          c=*(cp-*p++);y-=3*c;
+          c=*(cp-*p);x+=c;y-=3*c;
+          p+=x_size-3; 
+    
+          c=*(cp-*p++);x-=2*c;y-=2*c;
+          c=*(cp-*p++);x-=c;y-=2*c;
+          c=*(cp-*p++);y-=2*c;
+          c=*(cp-*p++);x+=c;y-=2*c;
+          c=*(cp-*p);x+=2*c;y-=2*c;
+          p+=x_size-5;
+    
+          c=*(cp-*p++);x-=3*c;y-=c;
+          c=*(cp-*p++);x-=2*c;y-=c;
+          c=*(cp-*p++);x-=c;y-=c;
+          c=*(cp-*p++);y-=c;
+          c=*(cp-*p++);x+=c;y-=c;
+          c=*(cp-*p++);x+=2*c;y-=c;
+          c=*(cp-*p);x+=3*c;y-=c;
+          p+=x_size-6;
+
+          c=*(cp-*p++);x-=3*c;
+          c=*(cp-*p++);x-=2*c;
+          c=*(cp-*p);x-=c;
+          p+=2;
+          c=*(cp-*p++);x+=c;
+          c=*(cp-*p++);x+=2*c;
+          c=*(cp-*p);x+=3*c;
+          p+=x_size-6;
+    
+          c=*(cp-*p++);x-=3*c;y+=c;
+          c=*(cp-*p++);x-=2*c;y+=c;
+          c=*(cp-*p++);x-=c;y+=c;
+          c=*(cp-*p++);y+=c;
+          c=*(cp-*p++);x+=c;y+=c;
+          c=*(cp-*p++);x+=2*c;y+=c;
+          c=*(cp-*p);x+=3*c;y+=c;
+          p+=x_size-5;
+
+          c=*(cp-*p++);x-=2*c;y+=2*c;
+          c=*(cp-*p++);x-=c;y+=2*c;
+          c=*(cp-*p++);y+=2*c;
+          c=*(cp-*p++);x+=c;y+=2*c;
+          c=*(cp-*p);x+=2*c;y+=2*c;
+          p+=x_size-3;
+
+          c=*(cp-*p++);x-=c;y+=3*c;
+          c=*(cp-*p++);y+=3*c;
+          c=*(cp-*p);x+=c;y+=3*c;
+
+          z = sqrt((float)((x*x) + (y*y)));
+          if (z > (0.9*(float)n)) /* 0.5 */
+	  {
+            do_symmetry=0;
+            if (x==0)
+              z=1000000.0;
+            else
+              z=((float)y) / ((float)x);
+            if (z < 0) { z=-z; w=-1; }
+            else w=1;
+            if (z < 0.5) { /* vert_edge */ a=0; b=1; }
+            else { if (z > 2.0) { /* hor_edge */ a=1; b=0; }
+            else { /* diag_edge */ if (w>0) { a=1; b=1; }
+                                   else { a=-1; b=1; }}}
+            if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
+                 (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
+              mid[i*x_size+j] = 1;
+          }
+          else
+            do_symmetry=1;
+        }
+        else 
+          do_symmetry=1;
+
+        if (do_symmetry==1)
+	{ 
+          p=in + (i-3)*x_size + j - 1;
+          x=0; y=0; w=0;
+
+          /*   |      \
+               y  -x-  w
+               |        \   */
+
+          c=*(cp-*p++);x+=c;y+=9*c;w+=3*c;
+          c=*(cp-*p++);y+=9*c;
+          c=*(cp-*p);x+=c;y+=9*c;w-=3*c;
+          p+=x_size-3; 
+  
+          c=*(cp-*p++);x+=4*c;y+=4*c;w+=4*c;
+          c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
+          c=*(cp-*p++);y+=4*c;
+          c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
+          c=*(cp-*p);x+=4*c;y+=4*c;w-=4*c;
+          p+=x_size-5;
+    
+          c=*(cp-*p++);x+=9*c;y+=c;w+=3*c;
+          c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
+          c=*(cp-*p++);x+=c;y+=c;w+=c;
+          c=*(cp-*p++);y+=c;
+          c=*(cp-*p++);x+=c;y+=c;w-=c;
+          c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
+          c=*(cp-*p);x+=9*c;y+=c;w-=3*c;
+          p+=x_size-6;
+
+          c=*(cp-*p++);x+=9*c;
+          c=*(cp-*p++);x+=4*c;
+          c=*(cp-*p);x+=c;
+          p+=2;
+          c=*(cp-*p++);x+=c;
+          c=*(cp-*p++);x+=4*c;
+          c=*(cp-*p);x+=9*c;
+          p+=x_size-6;
+    
+          c=*(cp-*p++);x+=9*c;y+=c;w-=3*c;
+          c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
+          c=*(cp-*p++);x+=c;y+=c;w-=c;
+          c=*(cp-*p++);y+=c;
+          c=*(cp-*p++);x+=c;y+=c;w+=c;
+          c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
+          c=*(cp-*p);x+=9*c;y+=c;w+=3*c;
+          p+=x_size-5;
+ 
+          c=*(cp-*p++);x+=4*c;y+=4*c;w-=4*c;
+          c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
+          c=*(cp-*p++);y+=4*c;
+          c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
+          c=*(cp-*p);x+=4*c;y+=4*c;w+=4*c;
+          p+=x_size-3;
+
+          c=*(cp-*p++);x+=c;y+=9*c;w-=3*c;
+          c=*(cp-*p++);y+=9*c;
+          c=*(cp-*p);x+=c;y+=9*c;w+=3*c;
+
+          if (y==0)
+            z = 1000000.0;
+          else
+            z = ((float)x) / ((float)y);
+          if (z < 0.5) { /* vertical */ a=0; b=1; }
+          else { if (z > 2.0) { /* horizontal */ a=1; b=0; }
+          else { /* diagonal */ if (w>0) { a=-1; b=1; }
+                                else { a=1; b=1; }}}
+          if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
+               (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
+            mid[i*x_size+j] = 2;	
+        }
+      }
+    }
+}
+
+/* }}} */
+/* {{{ susan_edges_small(in,r,sf,max_no,out) */
+
+susan_edges_small(in,r,mid,bp,max_no,x_size,y_size)
+  uchar *in, *bp, *mid;
+  int   *r, max_no, x_size, y_size;
+{
+float z;
+int   do_symmetry, i, j, m, n, a, b, x, y, w;
+uchar c,*p,*cp;
+
+  memset (r,0,x_size * y_size * sizeof(int));
+
+  max_no = 730; /* ho hum ;) */
+
+  for (i=1;i<y_size-1;i++)
+    for (j=1;j<x_size-1;j++)
+    {
+      n=100;
+      p=in + (i-1)*x_size + j - 1;
+      cp=bp + in[i*x_size+j];
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+      p+=x_size-2; 
+
+      n+=*(cp-*p);
+      p+=2;
+      n+=*(cp-*p);
+      p+=x_size-2;
+
+      n+=*(cp-*p++);
+      n+=*(cp-*p++);
+      n+=*(cp-*p);
+
+      if (n<=max_no)
+        r[i*x_size+j] = max_no - n;
+    }
+
+  for (i=2;i<y_size-2;i++)
+    for (j=2;j<x_size-2;j++)
+    {
+      if (r[i*x_size+j]>0)
+      {
+        m=r[i*x_size+j];
+        n=max_no - m;
+        cp=bp + in[i*x_size+j];
+
+        if (n>250)
+	{
+          p=in + (i-1)*x_size + j - 1;
+          x=0;y=0;
+
+          c=*(cp-*p++);x-=c;y-=c;
+          c=*(cp-*p++);y-=c;
+          c=*(cp-*p);x+=c;y-=c;
+          p+=x_size-2; 
+
+          c=*(cp-*p);x-=c;
+          p+=2;
+          c=*(cp-*p);x+=c;
+          p+=x_size-2;
+
+          c=*(cp-*p++);x-=c;y+=c;
+          c=*(cp-*p++);y+=c;
+          c=*(cp-*p);x+=c;y+=c;
+
+          z = sqrt((float)((x*x) + (y*y)));
+          if (z > (0.4*(float)n)) /* 0.6 */
+          {
+            do_symmetry=0;
+            if (x==0)
+	      z=1000000.0;
+	    else
+	      z=((float)y) / ((float)x);
+	    if (z < 0) { z=-z; w=-1; }
+            else w=1;
+            if (z < 0.5) { /* vert_edge */ a=0; b=1; }
+            else { if (z > 2.0) { /* hor_edge */ a=1; b=0; }
+            else { /* diag_edge */ if (w>0) { a=1; b=1; }
+                                   else { a=-1; b=1; }}}
+            if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
+              mid[i*x_size+j] = 1;
+          }
+          else
+            do_symmetry=1;
+        }
+        else
+          do_symmetry=1;
+
+        if (do_symmetry==1)
+	{ 
+          p=in + (i-1)*x_size + j - 1;
+          x=0; y=0; w=0;
+
+          /*   |      \
+               y  -x-  w
+               |        \   */
+
+          c=*(cp-*p++);x+=c;y+=c;w+=c;
+          c=*(cp-*p++);y+=c;
+          c=*(cp-*p);x+=c;y+=c;w-=c;
+          p+=x_size-2; 
+
+          c=*(cp-*p);x+=c;
+          p+=2;
+          c=*(cp-*p);x+=c;
+          p+=x_size-2;
+
+          c=*(cp-*p++);x+=c;y+=c;w-=c;
+          c=*(cp-*p++);y+=c;
+          c=*(cp-*p);x+=c;y+=c;w+=c;
+
+          if (y==0)
+            z = 1000000.0;
+          else
+            z = ((float)x) / ((float)y);
+          if (z < 0.5) { /* vertical */ a=0; b=1; }
+          else { if (z > 2.0) { /* horizontal */ a=1; b=0; }
+          else { /* diagonal */ if (w>0) { a=-1; b=1; }
+                                else { a=1; b=1; }}}
+          if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
+            mid[i*x_size+j] = 2;	
+        }
+      }
+    }
+}
+
+/* }}} */
+
+/* }}} */
+/* {{{ corners */
+
+/* {{{ corner_draw(in,corner_list,drawing_mode) */
+
+corner_draw(in,corner_list,x_size,drawing_mode)
+  uchar *in;
+  CORNER_LIST corner_list;
+  int x_size, drawing_mode;
+{
+uchar *p;
+int   n=0;
+
+  while(corner_list[n].info != 7)
+  {
+    if (drawing_mode==0)
+    {
+      p = in + (corner_list[n].y-1)*x_size + corner_list[n].x - 1;
+      *p++=255; *p++=255; *p=255; p+=x_size-2;
+      *p++=255; *p++=0;   *p=255; p+=x_size-2;
+      *p++=255; *p++=255; *p=255;
+      n++;
+    }
+    else
+    {
+      p = in + corner_list[n].y*x_size + corner_list[n].x;
+      *p=0;
+      n++;
+    }
+  }
+}
+
+/* }}} */
+/* {{{ susan(in,r,sf,max_no,corner_list) */
+
+susan_corners(in,r,bp,max_no,corner_list,x_size,y_size)
+  uchar       *in, *bp;
+  int         *r, max_no, x_size, y_size;
+  CORNER_LIST corner_list;
+{
+int   n,x,y,sq,xx,yy,
+      i,j,*cgx,*cgy;
+float divide;
+uchar c,*p,*cp;
+
+  memset (r,0,x_size * y_size * sizeof(int));
+
+  cgx=(int *)malloc(x_size*y_size*sizeof(int));
+  cgy=(int *)malloc(x_size*y_size*sizeof(int));
+
+  for (i=5;i<y_size-5;i++)
+    for (j=5;j<x_size-5;j++) {
+        n=100;
+        p=in + (i-3)*x_size + j - 1;
+        cp=bp + in[i*x_size+j];
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+        p+=x_size-3; 
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+        p+=x_size-5;
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+        p+=x_size-6;
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+      if (n<max_no){    /* do this test early and often ONLY to save wasted computation */
+        p+=2;
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=x_size-6;
+
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=x_size-5;
+
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=x_size-3;
+
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+
+        if (n<max_no)
+        {
+            x=0;y=0;
+            p=in + (i-3)*x_size + j - 1;
+
+            c=*(cp-*p++);x-=c;y-=3*c;
+            c=*(cp-*p++);y-=3*c;
+            c=*(cp-*p);x+=c;y-=3*c;
+            p+=x_size-3; 
+    
+            c=*(cp-*p++);x-=2*c;y-=2*c;
+            c=*(cp-*p++);x-=c;y-=2*c;
+            c=*(cp-*p++);y-=2*c;
+            c=*(cp-*p++);x+=c;y-=2*c;
+            c=*(cp-*p);x+=2*c;y-=2*c;
+            p+=x_size-5;
+    
+            c=*(cp-*p++);x-=3*c;y-=c;
+            c=*(cp-*p++);x-=2*c;y-=c;
+            c=*(cp-*p++);x-=c;y-=c;
+            c=*(cp-*p++);y-=c;
+            c=*(cp-*p++);x+=c;y-=c;
+            c=*(cp-*p++);x+=2*c;y-=c;
+            c=*(cp-*p);x+=3*c;y-=c;
+            p+=x_size-6;
+
+            c=*(cp-*p++);x-=3*c;
+            c=*(cp-*p++);x-=2*c;
+            c=*(cp-*p);x-=c;
+            p+=2;
+            c=*(cp-*p++);x+=c;
+            c=*(cp-*p++);x+=2*c;
+            c=*(cp-*p);x+=3*c;
+            p+=x_size-6;
+    
+            c=*(cp-*p++);x-=3*c;y+=c;
+            c=*(cp-*p++);x-=2*c;y+=c;
+            c=*(cp-*p++);x-=c;y+=c;
+            c=*(cp-*p++);y+=c;
+            c=*(cp-*p++);x+=c;y+=c;
+            c=*(cp-*p++);x+=2*c;y+=c;
+            c=*(cp-*p);x+=3*c;y+=c;
+            p+=x_size-5;
+
+            c=*(cp-*p++);x-=2*c;y+=2*c;
+            c=*(cp-*p++);x-=c;y+=2*c;
+            c=*(cp-*p++);y+=2*c;
+            c=*(cp-*p++);x+=c;y+=2*c;
+            c=*(cp-*p);x+=2*c;y+=2*c;
+            p+=x_size-3;
+
+            c=*(cp-*p++);x-=c;y+=3*c;
+            c=*(cp-*p++);y+=3*c;
+            c=*(cp-*p);x+=c;y+=3*c;
+
+            xx=x*x;
+            yy=y*y;
+            sq=xx+yy;
+            if ( sq > ((n*n)/2) )
+            {
+              if(yy<xx) {
+                divide=(float)y/(float)abs(x);
+                sq=abs(x)/x;
+                sq=*(cp-in[(i+FTOI(divide))*x_size+j+sq]) +
+                   *(cp-in[(i+FTOI(2*divide))*x_size+j+2*sq]) +
+                   *(cp-in[(i+FTOI(3*divide))*x_size+j+3*sq]);}
+              else {
+                divide=(float)x/(float)abs(y);
+                sq=abs(y)/y;
+                sq=*(cp-in[(i+sq)*x_size+j+FTOI(divide)]) +
+                   *(cp-in[(i+2*sq)*x_size+j+FTOI(2*divide)]) +
+                   *(cp-in[(i+3*sq)*x_size+j+FTOI(3*divide)]);}
+
+              if(sq>290){
+                r[i*x_size+j] = max_no-n;
+                cgx[i*x_size+j] = (51*x)/n;
+                cgy[i*x_size+j] = (51*y)/n;}
+            }
+	}
+}}}}}}}}}}}}}}}}}}}
+
+  /* to locate the local maxima */
+  n=0;
+  for (i=5;i<y_size-5;i++)
+    for (j=5;j<x_size-5;j++) {
+       x = r[i*x_size+j];
+       if (x>0)  {
+          /* 5x5 mask */
+#ifdef FIVE_SUPP
+          if (
+              (x>r[(i-1)*x_size+j+2]) &&
+              (x>r[(i  )*x_size+j+1]) &&
+              (x>r[(i  )*x_size+j+2]) &&
+              (x>r[(i+1)*x_size+j-1]) &&
+              (x>r[(i+1)*x_size+j  ]) &&
+              (x>r[(i+1)*x_size+j+1]) &&
+              (x>r[(i+1)*x_size+j+2]) &&
+              (x>r[(i+2)*x_size+j-2]) &&
+              (x>r[(i+2)*x_size+j-1]) &&
+              (x>r[(i+2)*x_size+j  ]) &&
+              (x>r[(i+2)*x_size+j+1]) &&
+              (x>r[(i+2)*x_size+j+2]) &&
+              (x>=r[(i-2)*x_size+j-2]) &&
+              (x>=r[(i-2)*x_size+j-1]) &&
+              (x>=r[(i-2)*x_size+j  ]) &&
+              (x>=r[(i-2)*x_size+j+1]) &&
+              (x>=r[(i-2)*x_size+j+2]) &&
+              (x>=r[(i-1)*x_size+j-2]) &&
+              (x>=r[(i-1)*x_size+j-1]) &&
+	      (x>=r[(i-1)*x_size+j  ]) &&
+	      (x>=r[(i-1)*x_size+j+1]) &&
+	      (x>=r[(i  )*x_size+j-2]) &&
+	      (x>=r[(i  )*x_size+j-1]) &&
+	      (x>=r[(i+1)*x_size+j-2]) )
+#endif
+#ifdef SEVEN_SUPP
+          if ( 
+                (x>r[(i-3)*x_size+j-3]) &&
+                (x>r[(i-3)*x_size+j-2]) &&
+                (x>r[(i-3)*x_size+j-1]) &&
+                (x>r[(i-3)*x_size+j  ]) &&
+                (x>r[(i-3)*x_size+j+1]) &&
+                (x>r[(i-3)*x_size+j+2]) &&
+                (x>r[(i-3)*x_size+j+3]) &&
+
+                (x>r[(i-2)*x_size+j-3]) &&
+                (x>r[(i-2)*x_size+j-2]) &&
+                (x>r[(i-2)*x_size+j-1]) &&
+                (x>r[(i-2)*x_size+j  ]) &&
+                (x>r[(i-2)*x_size+j+1]) &&
+                (x>r[(i-2)*x_size+j+2]) &&
+                (x>r[(i-2)*x_size+j+3]) &&
+
+                (x>r[(i-1)*x_size+j-3]) &&
+                (x>r[(i-1)*x_size+j-2]) &&
+                (x>r[(i-1)*x_size+j-1]) &&
+                (x>r[(i-1)*x_size+j  ]) &&
+                (x>r[(i-1)*x_size+j+1]) &&
+                (x>r[(i-1)*x_size+j+2]) &&
+                (x>r[(i-1)*x_size+j+3]) &&
+
+                (x>r[(i)*x_size+j-3]) &&
+                (x>r[(i)*x_size+j-2]) &&
+                (x>r[(i)*x_size+j-1]) &&
+                (x>=r[(i)*x_size+j+1]) &&
+                (x>=r[(i)*x_size+j+2]) &&
+                (x>=r[(i)*x_size+j+3]) &&
+
+                (x>=r[(i+1)*x_size+j-3]) &&
+                (x>=r[(i+1)*x_size+j-2]) &&
+                (x>=r[(i+1)*x_size+j-1]) &&
+                (x>=r[(i+1)*x_size+j  ]) &&
+                (x>=r[(i+1)*x_size+j+1]) &&
+                (x>=r[(i+1)*x_size+j+2]) &&
+                (x>=r[(i+1)*x_size+j+3]) &&
+
+                (x>=r[(i+2)*x_size+j-3]) &&
+                (x>=r[(i+2)*x_size+j-2]) &&
+                (x>=r[(i+2)*x_size+j-1]) &&
+                (x>=r[(i+2)*x_size+j  ]) &&
+                (x>=r[(i+2)*x_size+j+1]) &&
+                (x>=r[(i+2)*x_size+j+2]) &&
+                (x>=r[(i+2)*x_size+j+3]) &&
+
+                (x>=r[(i+3)*x_size+j-3]) &&
+                (x>=r[(i+3)*x_size+j-2]) &&
+                (x>=r[(i+3)*x_size+j-1]) &&
+                (x>=r[(i+3)*x_size+j  ]) &&
+                (x>=r[(i+3)*x_size+j+1]) &&
+                (x>=r[(i+3)*x_size+j+2]) &&
+                (x>=r[(i+3)*x_size+j+3]) )
+#endif
+{
+corner_list[n].info=0;
+corner_list[n].x=j;
+corner_list[n].y=i;
+corner_list[n].dx=cgx[i*x_size+j];
+corner_list[n].dy=cgy[i*x_size+j];
+corner_list[n].I=in[i*x_size+j];
+n++;
+if(n==MAX_CORNERS){
+      fprintf(stderr,"Too many corners.\n");
+      exit(1);
+         }}}}
+corner_list[n].info=7;
+
+free(cgx);
+free(cgy);
+
+}
+
+/* }}} */
+/* {{{ susan_quick(in,r,sf,max_no,corner_list) */
+
+susan_corners_quick(in,r,bp,max_no,corner_list,x_size,y_size)
+  uchar       *in, *bp;
+  int         *r, max_no, x_size, y_size;
+  CORNER_LIST corner_list;
+{
+int   n,x,y,i,j;
+uchar *p,*cp;
+
+  memset (r,0,x_size * y_size * sizeof(int));
+
+  for (i=7;i<y_size-7;i++)
+    for (j=7;j<x_size-7;j++) {
+        n=100;
+        p=in + (i-3)*x_size + j - 1;
+        cp=bp + in[i*x_size+j];
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+        p+=x_size-3;
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+        p+=x_size-5;
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+        p+=x_size-6;
+
+        n+=*(cp-*p++);
+        n+=*(cp-*p++);
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=2;
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=x_size-6;
+
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=x_size-5;
+
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+      if (n<max_no){
+        p+=x_size-3;
+
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p++);
+      if (n<max_no){
+        n+=*(cp-*p);
+
+        if (n<max_no)
+          r[i*x_size+j] = max_no-n;
+}}}}}}}}}}}}}}}}}}}
+
+  /* to locate the local maxima */
+  n=0;
+  for (i=7;i<y_size-7;i++)
+    for (j=7;j<x_size-7;j++) {
+       x = r[i*x_size+j];
+       if (x>0)  {
+          /* 5x5 mask */
+#ifdef FIVE_SUPP
+          if (
+              (x>r[(i-1)*x_size+j+2]) &&
+              (x>r[(i  )*x_size+j+1]) &&
+              (x>r[(i  )*x_size+j+2]) &&
+              (x>r[(i+1)*x_size+j-1]) &&
+              (x>r[(i+1)*x_size+j  ]) &&
+              (x>r[(i+1)*x_size+j+1]) &&
+              (x>r[(i+1)*x_size+j+2]) &&
+              (x>r[(i+2)*x_size+j-2]) &&
+              (x>r[(i+2)*x_size+j-1]) &&
+              (x>r[(i+2)*x_size+j  ]) &&
+              (x>r[(i+2)*x_size+j+1]) &&
+              (x>r[(i+2)*x_size+j+2]) &&
+              (x>=r[(i-2)*x_size+j-2]) &&
+              (x>=r[(i-2)*x_size+j-1]) &&
+              (x>=r[(i-2)*x_size+j  ]) &&
+              (x>=r[(i-2)*x_size+j+1]) &&
+              (x>=r[(i-2)*x_size+j+2]) &&
+              (x>=r[(i-1)*x_size+j-2]) &&
+              (x>=r[(i-1)*x_size+j-1]) &&
+	      (x>=r[(i-1)*x_size+j  ]) &&
+	      (x>=r[(i-1)*x_size+j+1]) &&
+	      (x>=r[(i  )*x_size+j-2]) &&
+	      (x>=r[(i  )*x_size+j-1]) &&
+	      (x>=r[(i+1)*x_size+j-2]) )
+#endif
+#ifdef SEVEN_SUPP
+          if ( 
+                (x>r[(i-3)*x_size+j-3]) &&
+                (x>r[(i-3)*x_size+j-2]) &&
+                (x>r[(i-3)*x_size+j-1]) &&
+                (x>r[(i-3)*x_size+j  ]) &&
+                (x>r[(i-3)*x_size+j+1]) &&
+                (x>r[(i-3)*x_size+j+2]) &&
+                (x>r[(i-3)*x_size+j+3]) &&
+
+                (x>r[(i-2)*x_size+j-3]) &&
+                (x>r[(i-2)*x_size+j-2]) &&
+                (x>r[(i-2)*x_size+j-1]) &&
+                (x>r[(i-2)*x_size+j  ]) &&
+                (x>r[(i-2)*x_size+j+1]) &&
+                (x>r[(i-2)*x_size+j+2]) &&
+                (x>r[(i-2)*x_size+j+3]) &&
+
+                (x>r[(i-1)*x_size+j-3]) &&
+                (x>r[(i-1)*x_size+j-2]) &&
+                (x>r[(i-1)*x_size+j-1]) &&
+                (x>r[(i-1)*x_size+j  ]) &&
+                (x>r[(i-1)*x_size+j+1]) &&
+                (x>r[(i-1)*x_size+j+2]) &&
+                (x>r[(i-1)*x_size+j+3]) &&
+
+                (x>r[(i)*x_size+j-3]) &&
+                (x>r[(i)*x_size+j-2]) &&
+                (x>r[(i)*x_size+j-1]) &&
+                (x>=r[(i)*x_size+j+1]) &&
+                (x>=r[(i)*x_size+j+2]) &&
+                (x>=r[(i)*x_size+j+3]) &&
+
+                (x>=r[(i+1)*x_size+j-3]) &&
+                (x>=r[(i+1)*x_size+j-2]) &&
+                (x>=r[(i+1)*x_size+j-1]) &&
+                (x>=r[(i+1)*x_size+j  ]) &&
+                (x>=r[(i+1)*x_size+j+1]) &&
+                (x>=r[(i+1)*x_size+j+2]) &&
+                (x>=r[(i+1)*x_size+j+3]) &&
+
+                (x>=r[(i+2)*x_size+j-3]) &&
+                (x>=r[(i+2)*x_size+j-2]) &&
+                (x>=r[(i+2)*x_size+j-1]) &&
+                (x>=r[(i+2)*x_size+j  ]) &&
+                (x>=r[(i+2)*x_size+j+1]) &&
+                (x>=r[(i+2)*x_size+j+2]) &&
+                (x>=r[(i+2)*x_size+j+3]) &&
+
+                (x>=r[(i+3)*x_size+j-3]) &&
+                (x>=r[(i+3)*x_size+j-2]) &&
+                (x>=r[(i+3)*x_size+j-1]) &&
+                (x>=r[(i+3)*x_size+j  ]) &&
+                (x>=r[(i+3)*x_size+j+1]) &&
+                (x>=r[(i+3)*x_size+j+2]) &&
+                (x>=r[(i+3)*x_size+j+3]) )
+#endif
+{
+corner_list[n].info=0;
+corner_list[n].x=j;
+corner_list[n].y=i;
+x = in[(i-2)*x_size+j-2] + in[(i-2)*x_size+j-1] + in[(i-2)*x_size+j] + in[(i-2)*x_size+j+1] + in[(i-2)*x_size+j+2] +
+    in[(i-1)*x_size+j-2] + in[(i-1)*x_size+j-1] + in[(i-1)*x_size+j] + in[(i-1)*x_size+j+1] + in[(i-1)*x_size+j+2] +
+    in[(i  )*x_size+j-2] + in[(i  )*x_size+j-1] + in[(i  )*x_size+j] + in[(i  )*x_size+j+1] + in[(i  )*x_size+j+2] +
+    in[(i+1)*x_size+j-2] + in[(i+1)*x_size+j-1] + in[(i+1)*x_size+j] + in[(i+1)*x_size+j+1] + in[(i+1)*x_size+j+2] +
+    in[(i+2)*x_size+j-2] + in[(i+2)*x_size+j-1] + in[(i+2)*x_size+j] + in[(i+2)*x_size+j+1] + in[(i+2)*x_size+j+2];
+
+corner_list[n].I=x/25;
+/*corner_list[n].I=in[i*x_size+j];*/
+x = in[(i-2)*x_size+j+2] + in[(i-1)*x_size+j+2] + in[(i)*x_size+j+2] + in[(i+1)*x_size+j+2] + in[(i+2)*x_size+j+2] -
+   (in[(i-2)*x_size+j-2] + in[(i-1)*x_size+j-2] + in[(i)*x_size+j-2] + in[(i+1)*x_size+j-2] + in[(i+2)*x_size+j-2]);
+x += x + in[(i-2)*x_size+j+1] + in[(i-1)*x_size+j+1] + in[(i)*x_size+j+1] + in[(i+1)*x_size+j+1] + in[(i+2)*x_size+j+1] -
+        (in[(i-2)*x_size+j-1] + in[(i-1)*x_size+j-1] + in[(i)*x_size+j-1] + in[(i+1)*x_size+j-1] + in[(i+2)*x_size+j-1]);
+
+y = in[(i+2)*x_size+j-2] + in[(i+2)*x_size+j-1] + in[(i+2)*x_size+j] + in[(i+2)*x_size+j+1] + in[(i+2)*x_size+j+2] -
+   (in[(i-2)*x_size+j-2] + in[(i-2)*x_size+j-1] + in[(i-2)*x_size+j] + in[(i-2)*x_size+j+1] + in[(i-2)*x_size+j+2]);
+y += y + in[(i+1)*x_size+j-2] + in[(i+1)*x_size+j-1] + in[(i+1)*x_size+j] + in[(i+1)*x_size+j+1] + in[(i+1)*x_size+j+2] -
+        (in[(i-1)*x_size+j-2] + in[(i-1)*x_size+j-1] + in[(i-1)*x_size+j] + in[(i-1)*x_size+j+1] + in[(i-1)*x_size+j+2]);
+corner_list[n].dx=x/15;
+corner_list[n].dy=y/15;
+n++;
+if(n==MAX_CORNERS){
+      fprintf(stderr,"Too many corners.\n");
+      exit(1);
+         }}}}
+corner_list[n].info=7;
+}
+
+/* }}} */
+
+/* }}} */
+/* {{{ main(argc, argv) */
+
+main(argc, argv)
+  int   argc;
+  char  *argv [];
+{
+/* {{{ vars */
+
+FILE   *ofp;
+char   filename [80],
+       *tcp;
+uchar  *in, *bp, *mid;
+float  dt=4.0;
+int    *r,
+       argindex=3,
+       bt=20,
+       principle=0,
+       thin_post_proc=1,
+       three_by_three=0,
+       drawing_mode=0,
+       susan_quick=0,
+       max_no_corners=1850,
+       max_no_edges=2650,
+       mode = 0, i,
+       x_size, y_size;
+CORNER_LIST corner_list;
+
+/* }}} */
+
+  if (argc<3)
+    usage();
+
+  get_image(argv[1],&in,&x_size,&y_size);
+
+  /* {{{ look at options */
+
+  while (argindex < argc)
+  {
+    tcp = argv[argindex];
+    if (*tcp == '-')
+      switch (*++tcp)
+      {
+        case 's': /* smoothing */
+          mode=0;
+	  break;
+        case 'e': /* edges */
+          mode=1;
+	  break;
+        case 'c': /* corners */
+          mode=2;
+	  break;
+        case 'p': /* principle */
+          principle=1;
+	  break;
+        case 'n': /* thinning post processing */
+          thin_post_proc=0;
+	  break;
+        case 'b': /* simple drawing mode */
+          drawing_mode=1;
+	  break;
+        case '3': /* 3x3 flat mask */
+          three_by_three=1;
+	  break;
+        case 'q': /* quick susan mask */
+          susan_quick=1;
+	  break;
+	case 'd': /* distance threshold */
+          if (++argindex >= argc){
+	    printf ("No argument following -d\n");
+	    exit(0);}
+	  dt=atof(argv[argindex]);
+          if (dt<0) three_by_three=1;
+	  break;
+	case 't': /* brightness threshold */
+          if (++argindex >= argc){
+	    printf ("No argument following -t\n");
+	    exit(0);}
+	  bt=atoi(argv[argindex]);
+	  break;
+      }	    
+      else
+        usage();
+    argindex++;
+  }
+
+  if ( (principle==1) && (mode==0) )
+    mode=1;
+
+/* }}} */
+  /* {{{ main processing */
+
+  switch (mode)
+  {
+    case 0:
+      /* {{{ smoothing */
+
+      setup_brightness_lut(&bp,bt,2);
+      susan_smoothing(three_by_three,in,dt,x_size,y_size,bp);
+      break;
+
+/* }}} */
+    case 1:
+      /* {{{ edges */
+
+      r   = (int *) malloc(x_size * y_size * sizeof(int));
+      setup_brightness_lut(&bp,bt,6);
+
+      if (principle)
+      {
+        if (three_by_three)
+          susan_principle_small(in,r,bp,max_no_edges,x_size,y_size);
+        else
+          susan_principle(in,r,bp,max_no_edges,x_size,y_size);
+        int_to_uchar(r,in,x_size*y_size);
+      }
+      else
+      {
+        mid = (uchar *)malloc(x_size*y_size);
+        memset (mid,100,x_size * y_size); /* note not set to zero */
+
+        if (three_by_three)
+          susan_edges_small(in,r,mid,bp,max_no_edges,x_size,y_size);
+        else
+          susan_edges(in,r,mid,bp,max_no_edges,x_size,y_size);
+        if(thin_post_proc)
+          susan_thin(r,mid,x_size,y_size);
+        edge_draw(in,mid,x_size,y_size,drawing_mode);
+      }
+
+      break;
+
+/* }}} */
+    case 2:
+      /* {{{ corners */
+
+      r   = (int *) malloc(x_size * y_size * sizeof(int));
+      setup_brightness_lut(&bp,bt,6);
+
+      if (principle)
+      {
+        susan_principle(in,r,bp,max_no_corners,x_size,y_size);
+        int_to_uchar(r,in,x_size*y_size);
+      }
+      else
+      {
+        if(susan_quick)
+          susan_corners_quick(in,r,bp,max_no_corners,corner_list,x_size,y_size);
+        else
+          susan_corners(in,r,bp,max_no_corners,corner_list,x_size,y_size);
+        corner_draw(in,corner_list,x_size,drawing_mode);
+      }
+
+      break;
+
+/* }}} */
+  }    
+
+/* }}} */
+
+  put_image(argv[2],in,x_size,y_size);
+}
+
+/* }}} */
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_edges/init.c rtems-hwpq-dev/testsuites/mibench/susan_edges/init.c
--- rtems-base/testsuites/mibench/susan_edges/init.c	2011-02-01 15:00:54.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_edges/init.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,2165 +0,0 @@
-/* {{{ Copyright etc. */
-
-/**********************************************************************\
-
-  SUSAN Version 2l by Stephen Smith
-  Oxford Centre for Functional Magnetic Resonance Imaging of the Brain,
-  Department of Clinical Neurology, Oxford University, Oxford, UK
-  (Previously in Computer Vision and Image Processing Group - now
-  Computer Vision and Electro Optics Group - DERA Chertsey, UK)
-  Email:    steve@fmrib.ox.ac.uk
-  WWW:      http://www.fmrib.ox.ac.uk/~steve
-
-  (C) Crown Copyright (1995-1999), Defence Evaluation and Research Agency,
-  Farnborough, Hampshire, GU14 6TD, UK
-  DERA WWW site:
-  http://www.dera.gov.uk/
-  DERA Computer Vision and Electro Optics Group WWW site:
-  http://www.dera.gov.uk/imageprocessing/dera/group_home.html
-  DERA Computer Vision and Electro Optics Group point of contact:
-  Dr. John Savage, jtsavage@dera.gov.uk, +44 1344 633203
-
-  A UK patent has been granted: "Method for digitally processing
-  images to determine the position of edges and/or corners therein for
-  guidance of unmanned vehicle", UK Patent 2272285. Proprietor:
-  Secretary of State for Defence, UK. 15 January 1997
-
-  This code is issued for research purposes only and remains the
-  property of the UK Secretary of State for Defence. This code must
-  not be passed on without this header information being kept
-  intact. This code must not be sold.
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ Readme First */
-
-/**********************************************************************\
-
-  SUSAN Version 2l
-  SUSAN = Smallest Univalue Segment Assimilating Nucleus
-
-  Email:    steve@fmrib.ox.ac.uk
-  WWW:      http://www.fmrib.ox.ac.uk/~steve
-
-  Related paper:
-  @article{Smith97,
-        author = "Smith, S.M. and Brady, J.M.",
-        title = "{SUSAN} - A New Approach to Low Level Image Processing",
-        journal = "Int. Journal of Computer Vision",
-        pages = "45--78",
-        volume = "23",
-        number = "1",
-        month = "May",
-        year = 1997}
-
-  To be registered for automatic (bug) updates of SUSAN, send an email.
-
-  Compile with:
-  gcc -O4 -o susan susan2l.c -lm
-
-  See following section for different machine information. Please
-  report any bugs (and fixes). There are a few optional changes that
-  can be made in the "defines" section which follows shortly.
-
-  Usage: type "susan" to get usage. Only PGM format files can be input
-  and output. Utilities such as the netpbm package and XV can be used
-  to convert to and from other formats. Any size of image can be
-  processed.
-
-  This code is written using an emacs folding mode, making moving
-  around the different sections very easy. This is why there are
-  various marks within comments and why comments are indented.
-
-
-  SUSAN QUICK:
-
-  This version of the SUSAN corner finder does not do all the
-  false-corner suppression and thus is faster and produced some false
-  positives, particularly on strong edges. However, because there are
-  less stages involving thresholds etc., the corners that are
-  correctly reported are usually more stable than those reported with
-  the full algorithm. Thus I recommend at least TRYING this algorithm
-  for applications where stability is important, e.g., tracking.
-
-  THRESHOLDS:
-
-  There are two thresholds which can be set at run-time. These are the
-  brightness threshold (t) and the distance threshold (d).
-
-  SPATIAL CONTROL: d
-
-  In SUSAN smoothing d controls the size of the Gaussian mask; its
-  default is 4.0. Increasing d gives more smoothing. In edge finding,
-  a fixed flat mask is used, either 37 pixels arranged in a "circle"
-  (default), or a 3 by 3 mask which gives finer detail. In corner
-  finding, only the larger 37 pixel mask is used; d is not
-  variable. In smoothing, the flat 3 by 3 mask can be used instead of
-  a larger Gaussian mask; this gives low smoothing and fast operation.
-
-  BRIGHTNESS CONTROL: t
-
-  In all three algorithms, t can be varied (default=20); this is the
-  main threshold to be varied. It determines the maximum difference in
-  greylevels between two pixels which allows them to be considered
-  part of the same "region" in the image. Thus it can be reduced to
-  give more edges or corners, i.e. to be more sensitive, and vice
-  versa. In smoothing, reducing t gives less smoothing, and vice
-  versa. Set t=10 for the test image available from the SUSAN web
-  page.
-
-  ITERATIONS:
-
-  With SUSAN smoothing, more smoothing can also be obtained by
-  iterating the algorithm several times. This has a different effect
-  from varying d or t.
-
-  FIXED MASKS:
-
-  37 pixel mask:    ooo       3 by 3 mask:  ooo
-                   ooooo                    ooo
-                  ooooooo                   ooo
-                  ooooooo
-                  ooooooo
-                   ooooo
-                    ooo
-
-  CORNER ATTRIBUTES dx, dy and I
-  (Only read this if you are interested in the C implementation or in
-  using corner attributes, e.g., for corner matching)
-
-  Corners reported in the corner list have attributes associated with
-  them as well as positions. This is useful, for example, when
-  attempting to match corners from one image to another, as these
-  attributes can often be fairly unchanged between images. The
-  attributes are dx, dy and I. I is the value of image brightness at
-  the position of the corner. In the case of susan_corners_quick, dx
-  and dy are the first order derivatives (differentials) of the image
-  brightness in the x and y directions respectively, at the position
-  of the corner. In the case of normal susan corner finding, dx and dy
-  are scaled versions of the position of the centre of gravity of the
-  USAN with respect to the centre pixel (nucleus).
-
-  BRIGHTNESS FUNCTION LUT IMPLEMENTATION:
-  (Only read this if you are interested in the C implementation)
-
-  The SUSAN brightness function is implemented as a LUT
-  (Look-Up-Table) for speed. The resulting pointer-based code is a
-  little hard to follow, so here is a brief explanation. In
-  setup_brightness_lut() the LUT is setup. This mallocs enough space
-  for *bp and then repositions the pointer to the centre of the
-  malloced space. The SUSAN function e^-(x^6) or e^-(x^2) is
-  calculated and converted to a uchar in the range 0-100, for all
-  possible image brightness differences (including negative
-  ones). Thus bp[23] is the output for a brightness difference of 23
-  greylevels. In the SUSAN algorithms this LUT is used as follows:
-
-  p=in + (i-3)*x_size + j - 1;
-  p points to the first image pixel in the circular mask surrounding
-  point (x,y).
-
-  cp=bp + in[i*x_size+j];
-  cp points to a position in the LUT corresponding to the brightness
-  of the centre pixel (x,y).
-
-  now for every pixel within the mask surrounding (x,y),
-  n+=*(cp-*p++);
-  the brightness difference function is found by moving the cp pointer
-  down by an amount equal to the value of the pixel pointed to by p,
-  thus subtracting the two brightness values and performing the
-  exponential function. This value is added to n, the running USAN
-  area.
-
-  in SUSAN smoothing, the variable height mask is implemented by
-  multiplying the above by the moving mask pointer, reset for each new
-  centre pixel.
-  tmp = *dpt++ * *(cp-brightness);
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ Machine Information */
-
-/**********************************************************************\
-
-  Success has been reported with the following:
-
-  MACHINE  OS         COMPILER
-
-  Sun      4.1.4      bundled C, gcc
-
-  Next
-
-  SGI      IRIX       SGI cc
-
-  DEC      Unix V3.2+
-
-  IBM RISC AIX        gcc
-
-  PC                  Borland 5.0
-
-  PC       Linux      gcc-2.6.3
-
-  PC       Win32      Visual C++ 4.0 (Console Application)
-
-  PC       Win95      Visual C++ 5.0 (Console Application)
-                      Thanks to Niu Yongsheng <niuysbit@163.net>:
-                      Use the FOPENB option below
-
-  PC       DOS        djgpp gnu C
-                      Thanks to Mark Pettovello <mpettove@umdsun2.umd.umich.edu>:
-                      Use the FOPENB option below
-
-  HP       HP-UX      bundled cc
-                      Thanks to Brian Dixon <briand@hpcvsgen.cv.hp.com>:
-                      in ksh:
-                      export CCOPTS="-Aa -D_HPUX_SOURCE | -lM"
-                      cc -O3 -o susan susan2l.c
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ History */
-
-/**********************************************************************\
-
-  SUSAN Version 2l, 12/2/99
-  Changed GNUDOS option to FOPENB.
-  (Thanks to Niu Yongsheng <niuysbit@163.net>.)
-  Took out redundant "sq=sq/2;".
-
-  SUSAN Version 2k, 19/8/98:
-  In corner finding:
-  Changed if(yy<sq) {...} else if(xx<sq) {...} to
-          if(yy<xx) {...} else {...}
-  (Thanks to adq@cim.mcgill.edu - Alain Domercq.)
-
-  SUSAN Version 2j, 22/10/97:
-  Fixed (mask_size>x_size) etc. tests in smoothing.
-  Added a couple of free() calls for cgx and cgy.
-  (Thanks to geoffb@ucs.ed.ac.uk - Geoff Browitt.)
-
-  SUSAN Version 2i, 21/7/97:
-  Added information about corner attributes.
-
-  SUSAN Version 2h, 16/12/96:
-  Added principle (initial enhancement) option.
-
-  SUSAN Version 2g, 2/7/96:
-  Minor superficial changes to code.
-
-  SUSAN Version 2f, 16/1/96:
-  Added GNUDOS option (now called FOPENB; see options below).
-
-  SUSAN Version 2e, 9/1/96:
-  Added -b option.
-  Fixed 1 pixel horizontal offset error for drawing edges.
-
-  SUSAN Version 2d, 27/11/95:
-  Fixed loading of certain PGM files in get_image (again!)
-
-  SUSAN Version 2c, 22/11/95:
-  Fixed loading of certain PGM files in get_image.
-  (Thanks to qu@San-Jose.ate.slb.com - Gongyuan Qu.)
-
-  SUSAN Version 2b, 9/11/95:
-  removed "z==" error in edges routines.
-
-  SUSAN Version 2a, 6/11/95:
-  Removed a few unnecessary variable declarations.
-  Added different machine information.
-  Changed "header" in get_image to char.
-
-  SUSAN Version 2, 1/11/95: first combined version able to take any
-  image sizes.
-
-  SUSAN "Versions 1", circa 1992: the various SUSAN algorithms were
-  developed during my doctorate within different programs and for
-  fixed image sizes. The algorithms themselves are virtually unaltered
-  between "versions 1" and the combined program, version 2.
-
-\**********************************************************************/
-
-/* }}} */
-/* {{{ defines, includes and typedefs */
-
-/* ********** Optional settings */
-
-#define CONFIGURE_INIT
-#include "system.h"
-
-#ifndef PPC
-typedef int        TOTAL_TYPE; /* this is faster for "int" but should be "float" for large d masks */
-#else
-typedef float      TOTAL_TYPE; /* for my PowerPC accelerator only */
-#endif
-
-/*#define FOPENB*/           /* uncomment if using djgpp gnu C for DOS or certain Win95 compilers */
-#define SEVEN_SUPP           /* size for non-max corner suppression; SEVEN_SUPP or FIVE_SUPP */
-#define MAX_CORNERS   15000  /* max corners per frame */
-
-/* ********** Leave the rest - but you may need to remove one or both of sys/file.h and malloc.h lines */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#define  exit_error(IFB,IFC) { fprintf(stderr,IFB,IFC); exit(0); }
-#define  FTOI(a) ( (a) < 0 ? ((int)(a-0.5)) : ((int)(a+0.5)) )
-typedef  unsigned char uchar;
-typedef  struct {int x,y,info, dx, dy, I;} CORNER_LIST[MAX_CORNERS];
-
-/* }}} */
-/* {{{ usage() */
-
-usage()
-{
-  printf("Usage: susan <in.pgm> <out.pgm> [options]\n\n");
-
-  printf("-s : Smoothing mode (default)\n");
-  printf("-e : Edges mode\n");
-  printf("-c : Corners mode\n\n");
-
-  printf("See source code for more information about setting the thresholds\n");
-  printf("-t <thresh> : Brightness threshold, all modes (default=20)\n");
-  printf("-d <thresh> : Distance threshold, smoothing mode, (default=4) (use next option instead for flat 3x3 mask)\n");
-  printf("-3 : Use flat 3x3 mask, edges or smoothing mode\n");
-  printf("-n : No post-processing on the binary edge map (runs much faster); edges mode\n");
-  printf("-q : Use faster (and usually stabler) corner mode; edge-like corner suppression not carried out; corners mode\n");
-  printf("-b : Mark corners/edges with single black points instead of black with white border; corners or edges mode\n");
-  printf("-p : Output initial enhancement image only; corners or edges mode (default is edges mode)\n");
-
-  printf("\nSUSAN Version 2l (C) 1995-1997 Stephen Smith, DRA UK. steve@fmrib.ox.ac.uk\n");
-
-  exit(0);
-}
-
-/* }}} */
-/* {{{ get_image(filename,in,x_size,y_size) */
-
-/* {{{ int getint(fp) derived from XV */
-
-int getint(fd)
-  FILE *fd;
-{
-  char c;
-  int i = 0;
-//  char dummy[10000];
-
-  c = getc(fd);
-  while (1) /* find next integer */
-  {
-    if (c=='#')    /* if we're at a comment, read to end of line */
-      //fgets(dummy,9000,fd);
-      while(c != '\n' && i<100)
-      	{
-			c = getc(fd);
-			//printf("%d",i);
-			i++;
-		}
-    if (c==EOF)
-      exit_error("Image %s not binary PGM.\n","is");
-    if (c>='0' && c<='9')
-      break;   /* found what we were looking for */
-    c = getc(fd);
-  }
-
-  /* we're at the start of a number, continue until we hit a non-number */
-  i = 0;
-  while (1) {
-    i = (i*10) + (c - '0');
-    c = getc(fd);
-    if (c==EOF) return (i);
-    if (c<'0' || c>'9') break;
-  }
-
-  return (i);
-}
-
-/* }}} */
-
-void get_image(filename,in,x_size,y_size)
-  char           filename[200];
-  unsigned char  **in;
-  int            *x_size, *y_size;
-{
-FILE  *fd;
-char header [100];
-int  tmp;
-
-printf("in get_image\n");
-
-#ifdef FOPENB
-  if ((fd=fopen(filename,"rb")) == NULL)
-#else
-  if ((fd=fopen(filename,"r")) == NULL)
-#endif
-    exit_error("Can't input image %s.\n",filename);
-
-  /* {{{ read header */
-
-printf("get_image: read header\n");
-
-  header[0]=fgetc(fd);
-  header[1]=fgetc(fd);
-  if(!(header[0]=='P' && header[1]=='5'))
-    exit_error("Image %s does not have binary PGM header.\n",filename);
-
-  *x_size = getint(fd);
-  *y_size = getint(fd);
-  tmp = getint(fd);
-
-/* }}} */
-
-printf("get_image: read header %d %d \n",*x_size,*y_size);
-
-  *in = (uchar *) malloc(*x_size * *y_size);
-
-  if (fread(*in,1,*x_size * *y_size,fd) == 0)
-    exit_error("Image %s is wrong size.\n",filename);
-
-  fclose(fd);
-}
-
-/* }}} */
-/* {{{ put_image(filename,in,x_size,y_size) */
-
-put_image(filename,in,x_size,y_size)
-  char filename [100],
-       *in;
-  int  x_size,
-       y_size;
-{
-FILE  *fd;
-
-#ifdef FOPENB
-  if ((fd=fopen(filename,"wb")) == NULL)
-#else
-  if ((fd=fopen(filename,"w")) == NULL)
-#endif
-    exit_error("Can't output image%s.\n",filename);
-
-  fprintf(fd,"P5\n");
-  fprintf(fd,"%d %d\n",x_size,y_size);
-  fprintf(fd,"255\n");
-
-  if (fwrite(in,x_size*y_size,1,fd) != 1)
-    exit_error("Can't write image %s.\n",filename);
-
-  fclose(fd);
-}
-
-/* }}} */
-/* {{{ int_to_uchar(r,in,size) */
-
-int_to_uchar(r,in,size)
-  uchar *in;
-  int   *r, size;
-{
-int i,
-    max_r=r[0],
-    min_r=r[0];
-
-  for (i=0; i<size; i++)
-    {
-      if ( r[i] > max_r )
-        max_r=r[i];
-      if ( r[i] < min_r )
-        min_r=r[i];
-    }
-
-  /*printf("min=%d max=%d\n",min_r,max_r);*/
-
-  max_r-=min_r;
-
-  for (i=0; i<size; i++)
-    in[i] = (uchar)((int)((int)(r[i]-min_r)*255)/max_r);
-}
-
-/* }}} */
-/* {{{ setup_brightness_lut(bp,thresh,form) */
-
-void setup_brightness_lut(bp,thresh,form)
-  uchar **bp;
-  int   thresh, form;
-{
-int   k;
-float temp;
-
-  *bp=(unsigned char *)malloc(516);
-  *bp=*bp+258;
-
-  for(k=-256;k<257;k++)
-  {
-    temp=((float)k)/((float)thresh);
-    temp=temp*temp;
-    if (form==6)
-      temp=temp*temp*temp;
-    temp=100.0*exp(-temp);
-    *(*bp+k)= (uchar)temp;
-  }
-}
-
-/* }}} */
-/* {{{ susan principle */
-
-/* {{{ susan_principle(in,r,bp,max_no,x_size,y_size) */
-
-susan_principle(in,r,bp,max_no,x_size,y_size)
-  uchar *in, *bp;
-  int   *r, max_no, x_size, y_size;
-{
-int   i, j, n;
-uchar *p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  for (i=3;i<y_size-3;i++)
-    for (j=3;j<x_size-3;j++)
-    {
-      n=100;
-      p=in + (i-3)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-}
-
-/* }}} */
-/* {{{ susan_principle_small(in,r,bp,max_no,x_size,y_size) */
-
-susan_principle_small(in,r,bp,max_no,x_size,y_size)
-  uchar *in, *bp;
-  int   *r, max_no, x_size, y_size;
-{
-int   i, j, n;
-uchar *p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  max_no = 730; /* ho hum ;) */
-
-  for (i=1;i<y_size-1;i++)
-    for (j=1;j<x_size-1;j++)
-    {
-      n=100;
-      p=in + (i-1)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ smoothing */
-
-/* {{{ median(in,i,j,x_size) */
-
-uchar median(in,i,j,x_size)
-  uchar *in;
-  int   i, j, x_size;
-{
-int p[8],k,l,tmp;
-
-  p[0]=in[(i-1)*x_size+j-1];
-  p[1]=in[(i-1)*x_size+j  ];
-  p[2]=in[(i-1)*x_size+j+1];
-  p[3]=in[(i  )*x_size+j-1];
-  p[4]=in[(i  )*x_size+j+1];
-  p[5]=in[(i+1)*x_size+j-1];
-  p[6]=in[(i+1)*x_size+j  ];
-  p[7]=in[(i+1)*x_size+j+1];
-
-  for(k=0; k<7; k++)
-    for(l=0; l<(7-k); l++)
-      if (p[l]>p[l+1])
-      {
-        tmp=p[l]; p[l]=p[l+1]; p[l+1]=tmp;
-      }
-
-  return( (p[3]+p[4]) / 2 );
-}
-
-/* }}} */
-/* {{{ enlarge(in,tmp_image,x_size,y_size,border) */
-
-/* this enlarges "in" so that borders can be dealt with easily */
-
-enlarge(in,tmp_image,x_size,y_size,border)
-  uchar **in;
-  uchar *tmp_image;
-  int   *x_size, *y_size, border;
-{
-int   i, j;
-
-  for(i=0; i<*y_size; i++)   /* copy *in into tmp_image */
-    memcpy(tmp_image+(i+border)*(*x_size+2*border)+border, *in+i* *x_size, *x_size);
-
-  for(i=0; i<border; i++) /* copy top and bottom rows; invert as many as necessary */
-  {
-    memcpy(tmp_image+(border-1-i)*(*x_size+2*border)+border,*in+i* *x_size,*x_size);
-    memcpy(tmp_image+(*y_size+border+i)*(*x_size+2*border)+border,*in+(*y_size-i-1)* *x_size,*x_size);
-  }
-
-  for(i=0; i<border; i++) /* copy left and right columns */
-    for(j=0; j<*y_size+2*border; j++)
-    {
-      tmp_image[j*(*x_size+2*border)+border-1-i]=tmp_image[j*(*x_size+2*border)+border+i];
-      tmp_image[j*(*x_size+2*border)+ *x_size+border+i]=tmp_image[j*(*x_size+2*border)+ *x_size+border-1-i];
-    }
-
-  *x_size+=2*border;  /* alter image size */
-  *y_size+=2*border;
-  *in=tmp_image;      /* repoint in */
-}
-
-/* }}} */
-/* {{{ void susan_smoothing(three_by_three,in,dt,x_size,y_size,bp) */
-
-void susan_smoothing(three_by_three,in,dt,x_size,y_size,bp)
-  int   three_by_three, x_size, y_size;
-  uchar *in, *bp;
-  float dt;
-{
-/* {{{ vars */
-
-float temp;
-int   n_max, increment, mask_size,
-      i,j,x,y,area,brightness,tmp,centre;
-uchar *ip, *dp, *dpt, *cp, *out=in,
-      *tmp_image;
-TOTAL_TYPE total;
-
-/* }}} */
-
-  /* {{{ setup larger image and border sizes */
-
-  if (three_by_three==0)
-    mask_size = ((int)(1.5 * dt)) + 1;
-  else
-    mask_size = 1;
-
-  total=0.1; /* test for total's type */
-  if ( (dt>15) && (total==0) )
-  {
-    printf("Distance_thresh (%f) too big for integer arithmetic.\n",dt);
-    printf("Either reduce it to <=15 or recompile with variable \"total\"\n");
-    printf("as a float: see top \"defines\" section.\n");
-    exit(0);
-  }
-
-  if ( (2*mask_size+1>x_size) || (2*mask_size+1>y_size) )
-  {
-    printf("Mask size (1.5*distance_thresh+1=%d) too big for image (%dx%d).\n",mask_size,x_size,y_size);
-    exit(0);
-  }
-
-  tmp_image = (uchar *) malloc( (x_size+mask_size*2) * (y_size+mask_size*2) );
-  enlarge(&in,tmp_image,&x_size,&y_size,mask_size);
-
-/* }}} */
-
-  if (three_by_three==0)
-  {     /* large Gaussian masks */
-    /* {{{ setup distance lut */
-
-  n_max = (mask_size*2) + 1;
-
-  increment = x_size - n_max;
-
-  dp     = (unsigned char *)malloc(n_max*n_max);
-  dpt    = dp;
-  temp   = -(dt*dt);
-
-  for(i=-mask_size; i<=mask_size; i++)
-    for(j=-mask_size; j<=mask_size; j++)
-    {
-      x = (int) (100.0 * exp( ((float)((i*i)+(j*j))) / temp ));
-      *dpt++ = (unsigned char)x;
-    }
-
-/* }}} */
-    /* {{{ main section */
-
-  for (i=mask_size;i<y_size-mask_size;i++)
-  {
-    for (j=mask_size;j<x_size-mask_size;j++)
-    {
-      area = 0;
-      total = 0;
-      dpt = dp;
-      ip = in + ((i-mask_size)*x_size) + j - mask_size;
-      centre = in[i*x_size+j];
-      cp = bp + centre;
-      for(y=-mask_size; y<=mask_size; y++)
-      {
-        for(x=-mask_size; x<=mask_size; x++)
-	{
-          brightness = *ip++;
-          tmp = *dpt++ * *(cp-brightness);
-          area += tmp;
-          total += tmp * brightness;
-        }
-        ip += increment;
-      }
-      tmp = area-10000;
-      if (tmp==0)
-        *out++=median(in,i,j,x_size);
-      else
-        *out++=((total-(centre*10000))/tmp);
-    }
-  }
-
-/* }}} */
-  }
-  else
-  {     /* 3x3 constant mask */
-    /* {{{ main section */
-
-  for (i=1;i<y_size-1;i++)
-  {
-    for (j=1;j<x_size-1;j++)
-    {
-      area = 0;
-      total = 0;
-      ip = in + ((i-1)*x_size) + j - 1;
-      centre = in[i*x_size+j];
-      cp = bp + centre;
-
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      ip += x_size-2;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      ip += x_size-2;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip++; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-      brightness=*ip; tmp=*(cp-brightness); area += tmp; total += tmp * brightness;
-
-      tmp = area-100;
-      if (tmp==0)
-        *out++=median(in,i,j,x_size);
-      else
-        *out++=(total-(centre*100))/tmp;
-    }
-  }
-
-/* }}} */
-  }
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ edges */
-
-/* {{{ edge_draw(in,corner_list,drawing_mode) */
-
-edge_draw(in,mid,x_size,y_size,drawing_mode)
-  uchar *in, *mid;
-  int x_size, y_size, drawing_mode;
-{
-int   i;
-uchar *inp, *midp;
-
-  if (drawing_mode==0)
-  {
-    /* mark 3x3 white block around each edge point */
-    midp=mid;
-    for (i=0; i<x_size*y_size; i++)
-    {
-      if (*midp<8)
-      {
-        inp = in + (midp - mid) - x_size - 1;
-        *inp++=255; *inp++=255; *inp=255; inp+=x_size-2;
-        *inp++=255; *inp++;     *inp=255; inp+=x_size-2;
-        *inp++=255; *inp++=255; *inp=255;
-      }
-      midp++;
-    }
-  }
-
-  /* now mark 1 black pixel at each edge point */
-  midp=mid;
-  for (i=0; i<x_size*y_size; i++)
-  {
-    if (*midp<8)
-      *(in + (midp - mid)) = 0;
-    midp++;
-  }
-}
-
-/* }}} */
-/* {{{ susan_thin(r,mid,x_size,y_size) */
-
-/* only one pass is needed as i,j are decremented if necessary to go
-   back and do bits again */
-
-susan_thin(r,mid,x_size,y_size)
-  uchar *mid;
-  int   *r, x_size, y_size;
-{
-int   l[9], centre, nlinks, npieces,
-      b01, b12, b21, b10,
-      p1, p2, p3, p4,
-      b00, b02, b20, b22,
-      m, n, a, b, x, y, i, j;
-uchar *mp;
-
-  for (i=4;i<y_size-4;i++)
-    for (j=4;j<x_size-4;j++)
-      if (mid[i*x_size+j]<8)
-      {
-        centre = r[i*x_size+j];
-        /* {{{ count number of neighbours */
-
-        mp=mid + (i-1)*x_size + j-1;
-
-        n = (*mp<8) +
-            (*(mp+1)<8) +
-            (*(mp+2)<8) +
-            (*(mp+x_size)<8) +
-            (*(mp+x_size+2)<8) +
-            (*(mp+x_size+x_size)<8) +
-            (*(mp+x_size+x_size+1)<8) +
-            (*(mp+x_size+x_size+2)<8);
-
-/* }}} */
-        /* {{{ n==0 no neighbours - remove point */
-
-        if (n==0)
-          mid[i*x_size+j]=100;
-
-/* }}} */
-        /* {{{ n==1 - extend line if I can */
-
-        /* extension is only allowed a few times - the value of mid is used to control this */
-
-        if ( (n==1) && (mid[i*x_size+j]<6) )
-        {
-          /* find maximum neighbour weighted in direction opposite the
-             neighbour already present. e.g.
-             have: O O O  weight r by 0 2 3
-                   X X O              0 0 4
-                   O O O              0 2 3     */
-
-          l[0]=r[(i-1)*x_size+j-1]; l[1]=r[(i-1)*x_size+j]; l[2]=r[(i-1)*x_size+j+1];
-          l[3]=r[(i  )*x_size+j-1]; l[4]=0;                 l[5]=r[(i  )*x_size+j+1];
-          l[6]=r[(i+1)*x_size+j-1]; l[7]=r[(i+1)*x_size+j]; l[8]=r[(i+1)*x_size+j+1];
-
-          if (mid[(i-1)*x_size+j-1]<8)        { l[0]=0; l[1]=0; l[3]=0; l[2]*=2;
-                                                l[6]*=2; l[5]*=3; l[7]*=3; l[8]*=4; }
-          else { if (mid[(i-1)*x_size+j]<8)   { l[1]=0; l[0]=0; l[2]=0; l[3]*=2;
-                                                l[5]*=2; l[6]*=3; l[8]*=3; l[7]*=4; }
-          else { if (mid[(i-1)*x_size+j+1]<8) { l[2]=0; l[1]=0; l[5]=0; l[0]*=2;
-                                                l[8]*=2; l[3]*=3; l[7]*=3; l[6]*=4; }
-          else { if (mid[(i)*x_size+j-1]<8)   { l[3]=0; l[0]=0; l[6]=0; l[1]*=2;
-                                                l[7]*=2; l[2]*=3; l[8]*=3; l[5]*=4; }
-          else { if (mid[(i)*x_size+j+1]<8)   { l[5]=0; l[2]=0; l[8]=0; l[1]*=2;
-                                                l[7]*=2; l[0]*=3; l[6]*=3; l[3]*=4; }
-          else { if (mid[(i+1)*x_size+j-1]<8) { l[6]=0; l[3]=0; l[7]=0; l[0]*=2;
-                                                l[8]*=2; l[1]*=3; l[5]*=3; l[2]*=4; }
-          else { if (mid[(i+1)*x_size+j]<8)   { l[7]=0; l[6]=0; l[8]=0; l[3]*=2;
-                                                l[5]*=2; l[0]*=3; l[2]*=3; l[1]*=4; }
-          else { if (mid[(i+1)*x_size+j+1]<8) { l[8]=0; l[5]=0; l[7]=0; l[6]*=2;
-                                                l[2]*=2; l[1]*=3; l[3]*=3; l[0]*=4; } }}}}}}}
-
-          m=0;     /* find the highest point */
-          for(y=0; y<3; y++)
-            for(x=0; x<3; x++)
-              if (l[y+y+y+x]>m) { m=l[y+y+y+x]; a=y; b=x; }
-
-          if (m>0)
-          {
-            if (mid[i*x_size+j]<4)
-              mid[(i+a-1)*x_size+j+b-1] = 4;
-            else
-              mid[(i+a-1)*x_size+j+b-1] = mid[i*x_size+j]+1;
-            if ( (a+a+b) < 3 ) /* need to jump back in image */
-	    {
-              i+=a-1;
-              j+=b-2;
-              if (i<4) i=4;
-              if (j<4) j=4;
-	    }
-	  }
-        }
-
-/* }}} */
-        /* {{{ n==2 */
-
-        if (n==2)
-	{
-          /* put in a bit here to straighten edges */
-          b00 = mid[(i-1)*x_size+j-1]<8; /* corners of 3x3 */
-          b02 = mid[(i-1)*x_size+j+1]<8;
-	  b20 = mid[(i+1)*x_size+j-1]<8;
-          b22 = mid[(i+1)*x_size+j+1]<8;
-          if ( ((b00+b02+b20+b22)==2) && ((b00|b22)&(b02|b20)))
-	  {  /* case: move a point back into line.
-                e.g. X O X  CAN  become X X X
-                     O X O              O O O
-                     O O O              O O O    */
-            if (b00)
-	    {
-              if (b02) { x=0; y=-1; }
-              else     { x=-1; y=0; }
-	    }
-            else
-	    {
-              if (b02) { x=1; y=0; }
-              else     { x=0; y=1; }
-	    }
-            if (((float)r[(i+y)*x_size+j+x]/(float)centre) > 0.7)
-	    {
-              if ( ( (x==0) && (mid[(i+(2*y))*x_size+j]>7) && (mid[(i+(2*y))*x_size+j-1]>7) && (mid[(i+(2*y))*x_size+j+1]>7) ) ||
-                   ( (y==0) && (mid[(i)*x_size+j+(2*x)]>7) && (mid[(i+1)*x_size+j+(2*x)]>7) && (mid[(i-1)*x_size+j+(2*x)]>7) ) )
-	      {
-                mid[(i)*x_size+j]=100;
-                mid[(i+y)*x_size+j+x]=3;  /* no jumping needed */
-	      }
-	    }
-	  }
-          else
-          {
-            b01 = mid[(i-1)*x_size+j  ]<8;
-            b12 = mid[(i  )*x_size+j+1]<8;
-            b21 = mid[(i+1)*x_size+j  ]<8;
-            b10 = mid[(i  )*x_size+j-1]<8;
-            /* {{{ right angle ends - not currently used */
-
-#ifdef IGNORETHIS
-            if ( (b00&b01)|(b00&b10)|(b02&b01)|(b02&b12)|(b20&b10)|(b20&b21)|(b22&b21)|(b22&b12) )
-	    { /* case; right angle ends. clean up.
-                 e.g.; X X O  CAN  become X X O
-                       O X O              O O O
-                       O O O              O O O        */
-              if ( ((b01)&(mid[(i-2)*x_size+j-1]>7)&(mid[(i-2)*x_size+j]>7)&(mid[(i-2)*x_size+j+1]>7)&
-                                    ((b00&((2*r[(i-1)*x_size+j+1])>centre))|(b02&((2*r[(i-1)*x_size+j-1])>centre)))) |
-                   ((b10)&(mid[(i-1)*x_size+j-2]>7)&(mid[(i)*x_size+j-2]>7)&(mid[(i+1)*x_size+j-2]>7)&
-                                    ((b00&((2*r[(i+1)*x_size+j-1])>centre))|(b20&((2*r[(i-1)*x_size+j-1])>centre)))) |
-                   ((b12)&(mid[(i-1)*x_size+j+2]>7)&(mid[(i)*x_size+j+2]>7)&(mid[(i+1)*x_size+j+2]>7)&
-                                    ((b02&((2*r[(i+1)*x_size+j+1])>centre))|(b22&((2*r[(i-1)*x_size+j+1])>centre)))) |
-                   ((b21)&(mid[(i+2)*x_size+j-1]>7)&(mid[(i+2)*x_size+j]>7)&(mid[(i+2)*x_size+j+1]>7)&
-                                    ((b20&((2*r[(i+1)*x_size+j+1])>centre))|(b22&((2*r[(i+1)*x_size+j-1])>centre)))) )
-	      {
-                mid[(i)*x_size+j]=100;
-                if (b10&b20) j-=2;
-                if (b00|b01|b02) { i--; j-=2; }
-  	      }
-	    }
-#endif
-
-/* }}} */
-            if ( ((b01+b12+b21+b10)==2) && ((b10|b12)&(b01|b21)) &&
-                 ((b01&((mid[(i-2)*x_size+j-1]<8)|(mid[(i-2)*x_size+j+1]<8)))|(b10&((mid[(i-1)*x_size+j-2]<8)|(mid[(i+1)*x_size+j-2]<8)))|
-                (b12&((mid[(i-1)*x_size+j+2]<8)|(mid[(i+1)*x_size+j+2]<8)))|(b21&((mid[(i+2)*x_size+j-1]<8)|(mid[(i+2)*x_size+j+1]<8)))) )
-	    { /* case; clears odd right angles.
-                 e.g.; O O O  becomes O O O
-                       X X O          X O O
-                       O X O          O X O     */
-              mid[(i)*x_size+j]=100;
-              i--;               /* jump back */
-              j-=2;
-              if (i<4) i=4;
-              if (j<4) j=4;
-	    }
-	  }
-	}
-
-/* }}} */
-        /* {{{ n>2 the thinning is done here without breaking connectivity */
-
-        if (n>2)
-        {
-          b01 = mid[(i-1)*x_size+j  ]<8;
-          b12 = mid[(i  )*x_size+j+1]<8;
-          b21 = mid[(i+1)*x_size+j  ]<8;
-          b10 = mid[(i  )*x_size+j-1]<8;
-          if((b01+b12+b21+b10)>1)
-          {
-            b00 = mid[(i-1)*x_size+j-1]<8;
-            b02 = mid[(i-1)*x_size+j+1]<8;
-	    b20 = mid[(i+1)*x_size+j-1]<8;
-	    b22 = mid[(i+1)*x_size+j+1]<8;
-            p1 = b00 | b01;
-            p2 = b02 | b12;
-            p3 = b22 | b21;
-            p4 = b20 | b10;
-
-            if( ((p1 + p2 + p3 + p4) - ((b01 & p2)+(b12 & p3)+(b21 & p4)+(b10 & p1))) < 2)
-            {
-              mid[(i)*x_size+j]=100;
-              i--;
-              j-=2;
-              if (i<4) i=4;
-              if (j<4) j=4;
-            }
-          }
-        }
-
-/* }}} */
-      }
-}
-
-/* }}} */
-/* {{{ susan_edges(in,r,sf,max_no,out) */
-
-susan_edges(in,r,mid,bp,max_no,x_size,y_size)
-  uchar *in, *bp, *mid;
-  int   *r, max_no, x_size, y_size;
-{
-float z;
-int   do_symmetry, i, j, m, n, a, b, x, y, w;
-uchar c,*p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  for (i=3;i<y_size-3;i++)
-    for (j=3;j<x_size-3;j++)
-    {
-      n=100;
-      p=in + (i-3)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-6;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-5;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-3;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-
-  for (i=4;i<y_size-4;i++)
-    for (j=4;j<x_size-4;j++)
-    {
-      if (r[i*x_size+j]>0)
-      {
-        m=r[i*x_size+j];
-        n=max_no - m;
-        cp=bp + in[i*x_size+j];
-
-        if (n>600)
-        {
-          p=in + (i-3)*x_size + j - 1;
-          x=0;y=0;
-
-          c=*(cp-*p++);x-=c;y-=3*c;
-          c=*(cp-*p++);y-=3*c;
-          c=*(cp-*p);x+=c;y-=3*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x-=2*c;y-=2*c;
-          c=*(cp-*p++);x-=c;y-=2*c;
-          c=*(cp-*p++);y-=2*c;
-          c=*(cp-*p++);x+=c;y-=2*c;
-          c=*(cp-*p);x+=2*c;y-=2*c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x-=3*c;y-=c;
-          c=*(cp-*p++);x-=2*c;y-=c;
-          c=*(cp-*p++);x-=c;y-=c;
-          c=*(cp-*p++);y-=c;
-          c=*(cp-*p++);x+=c;y-=c;
-          c=*(cp-*p++);x+=2*c;y-=c;
-          c=*(cp-*p);x+=3*c;y-=c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x-=3*c;
-          c=*(cp-*p++);x-=2*c;
-          c=*(cp-*p);x-=c;
-          p+=2;
-          c=*(cp-*p++);x+=c;
-          c=*(cp-*p++);x+=2*c;
-          c=*(cp-*p);x+=3*c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x-=3*c;y+=c;
-          c=*(cp-*p++);x-=2*c;y+=c;
-          c=*(cp-*p++);x-=c;y+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p++);x+=c;y+=c;
-          c=*(cp-*p++);x+=2*c;y+=c;
-          c=*(cp-*p);x+=3*c;y+=c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x-=2*c;y+=2*c;
-          c=*(cp-*p++);x-=c;y+=2*c;
-          c=*(cp-*p++);y+=2*c;
-          c=*(cp-*p++);x+=c;y+=2*c;
-          c=*(cp-*p);x+=2*c;y+=2*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x-=c;y+=3*c;
-          c=*(cp-*p++);y+=3*c;
-          c=*(cp-*p);x+=c;y+=3*c;
-
-          z = sqrt((float)((x*x) + (y*y)));
-          if (z > (0.9*(float)n)) /* 0.5 */
-	  {
-            do_symmetry=0;
-            if (x==0)
-              z=1000000.0;
-            else
-              z=((float)y) / ((float)x);
-            if (z < 0) { z=-z; w=-1; }
-            else w=1;
-            if (z < 0.5) { /* vert_edge */ a=0; b=1; }
-            else { if (z > 2.0) { /* hor_edge */ a=1; b=0; }
-            else { /* diag_edge */ if (w>0) { a=1; b=1; }
-                                   else { a=-1; b=1; }}}
-            if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
-                 (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
-              mid[i*x_size+j] = 1;
-          }
-          else
-            do_symmetry=1;
-        }
-        else
-          do_symmetry=1;
-
-        if (do_symmetry==1)
-	{
-          p=in + (i-3)*x_size + j - 1;
-          x=0; y=0; w=0;
-
-          /*   |      \
-               y  -x-  w
-               |        \   */
-
-          c=*(cp-*p++);x+=c;y+=9*c;w+=3*c;
-          c=*(cp-*p++);y+=9*c;
-          c=*(cp-*p);x+=c;y+=9*c;w-=3*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x+=4*c;y+=4*c;w+=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
-          c=*(cp-*p++);y+=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
-          c=*(cp-*p);x+=4*c;y+=4*c;w-=4*c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x+=9*c;y+=c;w+=3*c;
-          c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
-          c=*(cp-*p++);x+=c;y+=c;w+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p++);x+=c;y+=c;w-=c;
-          c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
-          c=*(cp-*p);x+=9*c;y+=c;w-=3*c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x+=9*c;
-          c=*(cp-*p++);x+=4*c;
-          c=*(cp-*p);x+=c;
-          p+=2;
-          c=*(cp-*p++);x+=c;
-          c=*(cp-*p++);x+=4*c;
-          c=*(cp-*p);x+=9*c;
-          p+=x_size-6;
-
-          c=*(cp-*p++);x+=9*c;y+=c;w-=3*c;
-          c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
-          c=*(cp-*p++);x+=c;y+=c;w-=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p++);x+=c;y+=c;w+=c;
-          c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
-          c=*(cp-*p);x+=9*c;y+=c;w+=3*c;
-          p+=x_size-5;
-
-          c=*(cp-*p++);x+=4*c;y+=4*c;w-=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
-          c=*(cp-*p++);y+=4*c;
-          c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
-          c=*(cp-*p);x+=4*c;y+=4*c;w+=4*c;
-          p+=x_size-3;
-
-          c=*(cp-*p++);x+=c;y+=9*c;w-=3*c;
-          c=*(cp-*p++);y+=9*c;
-          c=*(cp-*p);x+=c;y+=9*c;w+=3*c;
-
-          if (y==0)
-            z = 1000000.0;
-          else
-            z = ((float)x) / ((float)y);
-          if (z < 0.5) { /* vertical */ a=0; b=1; }
-          else { if (z > 2.0) { /* horizontal */ a=1; b=0; }
-          else { /* diagonal */ if (w>0) { a=-1; b=1; }
-                                else { a=1; b=1; }}}
-          if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
-               (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
-            mid[i*x_size+j] = 2;
-        }
-      }
-    }
-}
-
-/* }}} */
-/* {{{ susan_edges_small(in,r,sf,max_no,out) */
-
-susan_edges_small(in,r,mid,bp,max_no,x_size,y_size)
-  uchar *in, *bp, *mid;
-  int   *r, max_no, x_size, y_size;
-{
-float z;
-int   do_symmetry, i, j, m, n, a, b, x, y, w;
-uchar c,*p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  max_no = 730; /* ho hum ;) */
-
-  for (i=1;i<y_size-1;i++)
-    for (j=1;j<x_size-1;j++)
-    {
-      n=100;
-      p=in + (i-1)*x_size + j - 1;
-      cp=bp + in[i*x_size+j];
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p);
-      p+=2;
-      n+=*(cp-*p);
-      p+=x_size-2;
-
-      n+=*(cp-*p++);
-      n+=*(cp-*p++);
-      n+=*(cp-*p);
-
-      if (n<=max_no)
-        r[i*x_size+j] = max_no - n;
-    }
-
-  for (i=2;i<y_size-2;i++)
-    for (j=2;j<x_size-2;j++)
-    {
-      if (r[i*x_size+j]>0)
-      {
-        m=r[i*x_size+j];
-        n=max_no - m;
-        cp=bp + in[i*x_size+j];
-
-        if (n>250)
-	{
-          p=in + (i-1)*x_size + j - 1;
-          x=0;y=0;
-
-          c=*(cp-*p++);x-=c;y-=c;
-          c=*(cp-*p++);y-=c;
-          c=*(cp-*p);x+=c;y-=c;
-          p+=x_size-2;
-
-          c=*(cp-*p);x-=c;
-          p+=2;
-          c=*(cp-*p);x+=c;
-          p+=x_size-2;
-
-          c=*(cp-*p++);x-=c;y+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p);x+=c;y+=c;
-
-          z = sqrt((float)((x*x) + (y*y)));
-          if (z > (0.4*(float)n)) /* 0.6 */
-          {
-            do_symmetry=0;
-            if (x==0)
-	      z=1000000.0;
-	    else
-	      z=((float)y) / ((float)x);
-	    if (z < 0) { z=-z; w=-1; }
-            else w=1;
-            if (z < 0.5) { /* vert_edge */ a=0; b=1; }
-            else { if (z > 2.0) { /* hor_edge */ a=1; b=0; }
-            else { /* diag_edge */ if (w>0) { a=1; b=1; }
-                                   else { a=-1; b=1; }}}
-            if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
-              mid[i*x_size+j] = 1;
-          }
-          else
-            do_symmetry=1;
-        }
-        else
-          do_symmetry=1;
-
-        if (do_symmetry==1)
-	{
-          p=in + (i-1)*x_size + j - 1;
-          x=0; y=0; w=0;
-
-          /*   |      \
-               y  -x-  w
-               |        \   */
-
-          c=*(cp-*p++);x+=c;y+=c;w+=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p);x+=c;y+=c;w-=c;
-          p+=x_size-2;
-
-          c=*(cp-*p);x+=c;
-          p+=2;
-          c=*(cp-*p);x+=c;
-          p+=x_size-2;
-
-          c=*(cp-*p++);x+=c;y+=c;w-=c;
-          c=*(cp-*p++);y+=c;
-          c=*(cp-*p);x+=c;y+=c;w+=c;
-
-          if (y==0)
-            z = 1000000.0;
-          else
-            z = ((float)x) / ((float)y);
-          if (z < 0.5) { /* vertical */ a=0; b=1; }
-          else { if (z > 2.0) { /* horizontal */ a=1; b=0; }
-          else { /* diagonal */ if (w>0) { a=-1; b=1; }
-                                else { a=1; b=1; }}}
-          if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
-            mid[i*x_size+j] = 2;
-        }
-      }
-    }
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ corners */
-
-/* {{{ corner_draw(in,corner_list,drawing_mode) */
-
-corner_draw(in,corner_list,x_size,drawing_mode)
-  uchar *in;
-  CORNER_LIST corner_list;
-  int x_size, drawing_mode;
-{
-uchar *p;
-int   n=0;
-
-  while(corner_list[n].info != 7)
-  {
-    if (drawing_mode==0)
-    {
-      p = in + (corner_list[n].y-1)*x_size + corner_list[n].x - 1;
-      *p++=255; *p++=255; *p=255; p+=x_size-2;
-      *p++=255; *p++=0;   *p=255; p+=x_size-2;
-      *p++=255; *p++=255; *p=255;
-      n++;
-    }
-    else
-    {
-      p = in + corner_list[n].y*x_size + corner_list[n].x;
-      *p=0;
-      n++;
-    }
-  }
-}
-
-/* }}} */
-/* {{{ susan(in,r,sf,max_no,corner_list) */
-
-susan_corners(in,r,bp,max_no,corner_list,x_size,y_size)
-  uchar       *in, *bp;
-  int         *r, max_no, x_size, y_size;
-  CORNER_LIST corner_list;
-{
-int   n,x,y,sq,xx,yy,
-      i,j,*cgx,*cgy;
-float divide;
-uchar c,*p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  cgx=(int *)malloc(x_size*y_size*sizeof(int));
-  cgy=(int *)malloc(x_size*y_size*sizeof(int));
-
-  for (i=5;i<y_size-5;i++)
-    for (j=5;j<x_size-5;j++) {
-        n=100;
-        p=in + (i-3)*x_size + j - 1;
-        cp=bp + in[i*x_size+j];
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-      if (n<max_no){    /* do this test early and often ONLY to save wasted computation */
-        p+=2;
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-
-        if (n<max_no)
-        {
-            x=0;y=0;
-            p=in + (i-3)*x_size + j - 1;
-
-            c=*(cp-*p++);x-=c;y-=3*c;
-            c=*(cp-*p++);y-=3*c;
-            c=*(cp-*p);x+=c;y-=3*c;
-            p+=x_size-3;
-
-            c=*(cp-*p++);x-=2*c;y-=2*c;
-            c=*(cp-*p++);x-=c;y-=2*c;
-            c=*(cp-*p++);y-=2*c;
-            c=*(cp-*p++);x+=c;y-=2*c;
-            c=*(cp-*p);x+=2*c;y-=2*c;
-            p+=x_size-5;
-
-            c=*(cp-*p++);x-=3*c;y-=c;
-            c=*(cp-*p++);x-=2*c;y-=c;
-            c=*(cp-*p++);x-=c;y-=c;
-            c=*(cp-*p++);y-=c;
-            c=*(cp-*p++);x+=c;y-=c;
-            c=*(cp-*p++);x+=2*c;y-=c;
-            c=*(cp-*p);x+=3*c;y-=c;
-            p+=x_size-6;
-
-            c=*(cp-*p++);x-=3*c;
-            c=*(cp-*p++);x-=2*c;
-            c=*(cp-*p);x-=c;
-            p+=2;
-            c=*(cp-*p++);x+=c;
-            c=*(cp-*p++);x+=2*c;
-            c=*(cp-*p);x+=3*c;
-            p+=x_size-6;
-
-            c=*(cp-*p++);x-=3*c;y+=c;
-            c=*(cp-*p++);x-=2*c;y+=c;
-            c=*(cp-*p++);x-=c;y+=c;
-            c=*(cp-*p++);y+=c;
-            c=*(cp-*p++);x+=c;y+=c;
-            c=*(cp-*p++);x+=2*c;y+=c;
-            c=*(cp-*p);x+=3*c;y+=c;
-            p+=x_size-5;
-
-            c=*(cp-*p++);x-=2*c;y+=2*c;
-            c=*(cp-*p++);x-=c;y+=2*c;
-            c=*(cp-*p++);y+=2*c;
-            c=*(cp-*p++);x+=c;y+=2*c;
-            c=*(cp-*p);x+=2*c;y+=2*c;
-            p+=x_size-3;
-
-            c=*(cp-*p++);x-=c;y+=3*c;
-            c=*(cp-*p++);y+=3*c;
-            c=*(cp-*p);x+=c;y+=3*c;
-
-            xx=x*x;
-            yy=y*y;
-            sq=xx+yy;
-            if ( sq > ((n*n)/2) )
-            {
-              if(yy<xx) {
-                divide=(float)y/(float)abs(x);
-                sq=abs(x)/x;
-                sq=*(cp-in[(i+FTOI(divide))*x_size+j+sq]) +
-                   *(cp-in[(i+FTOI(2*divide))*x_size+j+2*sq]) +
-                   *(cp-in[(i+FTOI(3*divide))*x_size+j+3*sq]);}
-              else {
-                divide=(float)x/(float)abs(y);
-                sq=abs(y)/y;
-                sq=*(cp-in[(i+sq)*x_size+j+FTOI(divide)]) +
-                   *(cp-in[(i+2*sq)*x_size+j+FTOI(2*divide)]) +
-                   *(cp-in[(i+3*sq)*x_size+j+FTOI(3*divide)]);}
-
-              if(sq>290){
-                r[i*x_size+j] = max_no-n;
-                cgx[i*x_size+j] = (51*x)/n;
-                cgy[i*x_size+j] = (51*y)/n;}
-            }
-	}
-}}}}}}}}}}}}}}}}}}}
-
-  /* to locate the local maxima */
-  n=0;
-  for (i=5;i<y_size-5;i++)
-    for (j=5;j<x_size-5;j++) {
-       x = r[i*x_size+j];
-       if (x>0)  {
-          /* 5x5 mask */
-#ifdef FIVE_SUPP
-          if (
-              (x>r[(i-1)*x_size+j+2]) &&
-              (x>r[(i  )*x_size+j+1]) &&
-              (x>r[(i  )*x_size+j+2]) &&
-              (x>r[(i+1)*x_size+j-1]) &&
-              (x>r[(i+1)*x_size+j  ]) &&
-              (x>r[(i+1)*x_size+j+1]) &&
-              (x>r[(i+1)*x_size+j+2]) &&
-              (x>r[(i+2)*x_size+j-2]) &&
-              (x>r[(i+2)*x_size+j-1]) &&
-              (x>r[(i+2)*x_size+j  ]) &&
-              (x>r[(i+2)*x_size+j+1]) &&
-              (x>r[(i+2)*x_size+j+2]) &&
-              (x>=r[(i-2)*x_size+j-2]) &&
-              (x>=r[(i-2)*x_size+j-1]) &&
-              (x>=r[(i-2)*x_size+j  ]) &&
-              (x>=r[(i-2)*x_size+j+1]) &&
-              (x>=r[(i-2)*x_size+j+2]) &&
-              (x>=r[(i-1)*x_size+j-2]) &&
-              (x>=r[(i-1)*x_size+j-1]) &&
-	      (x>=r[(i-1)*x_size+j  ]) &&
-	      (x>=r[(i-1)*x_size+j+1]) &&
-	      (x>=r[(i  )*x_size+j-2]) &&
-	      (x>=r[(i  )*x_size+j-1]) &&
-	      (x>=r[(i+1)*x_size+j-2]) )
-#endif
-#ifdef SEVEN_SUPP
-          if (
-                (x>r[(i-3)*x_size+j-3]) &&
-                (x>r[(i-3)*x_size+j-2]) &&
-                (x>r[(i-3)*x_size+j-1]) &&
-                (x>r[(i-3)*x_size+j  ]) &&
-                (x>r[(i-3)*x_size+j+1]) &&
-                (x>r[(i-3)*x_size+j+2]) &&
-                (x>r[(i-3)*x_size+j+3]) &&
-
-                (x>r[(i-2)*x_size+j-3]) &&
-                (x>r[(i-2)*x_size+j-2]) &&
-                (x>r[(i-2)*x_size+j-1]) &&
-                (x>r[(i-2)*x_size+j  ]) &&
-                (x>r[(i-2)*x_size+j+1]) &&
-                (x>r[(i-2)*x_size+j+2]) &&
-                (x>r[(i-2)*x_size+j+3]) &&
-
-                (x>r[(i-1)*x_size+j-3]) &&
-                (x>r[(i-1)*x_size+j-2]) &&
-                (x>r[(i-1)*x_size+j-1]) &&
-                (x>r[(i-1)*x_size+j  ]) &&
-                (x>r[(i-1)*x_size+j+1]) &&
-                (x>r[(i-1)*x_size+j+2]) &&
-                (x>r[(i-1)*x_size+j+3]) &&
-
-                (x>r[(i)*x_size+j-3]) &&
-                (x>r[(i)*x_size+j-2]) &&
-                (x>r[(i)*x_size+j-1]) &&
-                (x>=r[(i)*x_size+j+1]) &&
-                (x>=r[(i)*x_size+j+2]) &&
-                (x>=r[(i)*x_size+j+3]) &&
-
-                (x>=r[(i+1)*x_size+j-3]) &&
-                (x>=r[(i+1)*x_size+j-2]) &&
-                (x>=r[(i+1)*x_size+j-1]) &&
-                (x>=r[(i+1)*x_size+j  ]) &&
-                (x>=r[(i+1)*x_size+j+1]) &&
-                (x>=r[(i+1)*x_size+j+2]) &&
-                (x>=r[(i+1)*x_size+j+3]) &&
-
-                (x>=r[(i+2)*x_size+j-3]) &&
-                (x>=r[(i+2)*x_size+j-2]) &&
-                (x>=r[(i+2)*x_size+j-1]) &&
-                (x>=r[(i+2)*x_size+j  ]) &&
-                (x>=r[(i+2)*x_size+j+1]) &&
-                (x>=r[(i+2)*x_size+j+2]) &&
-                (x>=r[(i+2)*x_size+j+3]) &&
-
-                (x>=r[(i+3)*x_size+j-3]) &&
-                (x>=r[(i+3)*x_size+j-2]) &&
-                (x>=r[(i+3)*x_size+j-1]) &&
-                (x>=r[(i+3)*x_size+j  ]) &&
-                (x>=r[(i+3)*x_size+j+1]) &&
-                (x>=r[(i+3)*x_size+j+2]) &&
-                (x>=r[(i+3)*x_size+j+3]) )
-#endif
-{
-corner_list[n].info=0;
-corner_list[n].x=j;
-corner_list[n].y=i;
-corner_list[n].dx=cgx[i*x_size+j];
-corner_list[n].dy=cgy[i*x_size+j];
-corner_list[n].I=in[i*x_size+j];
-n++;
-if(n==MAX_CORNERS){
-      fprintf(stderr,"Too many corners.\n");
-      exit(1);
-         }}}}
-corner_list[n].info=7;
-
-free(cgx);
-free(cgy);
-
-}
-
-/* }}} */
-/* {{{ susan_quick(in,r,sf,max_no,corner_list) */
-
-susan_corners_quick(in,r,bp,max_no,corner_list,x_size,y_size)
-  uchar       *in, *bp;
-  int         *r, max_no, x_size, y_size;
-  CORNER_LIST corner_list;
-{
-int   n,x,y,i,j;
-uchar *p,*cp;
-
-  memset (r,0,x_size * y_size * sizeof(int));
-
-  for (i=7;i<y_size-7;i++)
-    for (j=7;j<x_size-7;j++) {
-        n=100;
-        p=in + (i-3)*x_size + j - 1;
-        cp=bp + in[i*x_size+j];
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-        n+=*(cp-*p++);
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=2;
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-6;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-5;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-      if (n<max_no){
-        p+=x_size-3;
-
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p++);
-      if (n<max_no){
-        n+=*(cp-*p);
-
-        if (n<max_no)
-          r[i*x_size+j] = max_no-n;
-}}}}}}}}}}}}}}}}}}}
-
-  /* to locate the local maxima */
-  n=0;
-  for (i=7;i<y_size-7;i++)
-    for (j=7;j<x_size-7;j++) {
-       x = r[i*x_size+j];
-       if (x>0)  {
-          /* 5x5 mask */
-#ifdef FIVE_SUPP
-          if (
-              (x>r[(i-1)*x_size+j+2]) &&
-              (x>r[(i  )*x_size+j+1]) &&
-              (x>r[(i  )*x_size+j+2]) &&
-              (x>r[(i+1)*x_size+j-1]) &&
-              (x>r[(i+1)*x_size+j  ]) &&
-              (x>r[(i+1)*x_size+j+1]) &&
-              (x>r[(i+1)*x_size+j+2]) &&
-              (x>r[(i+2)*x_size+j-2]) &&
-              (x>r[(i+2)*x_size+j-1]) &&
-              (x>r[(i+2)*x_size+j  ]) &&
-              (x>r[(i+2)*x_size+j+1]) &&
-              (x>r[(i+2)*x_size+j+2]) &&
-              (x>=r[(i-2)*x_size+j-2]) &&
-              (x>=r[(i-2)*x_size+j-1]) &&
-              (x>=r[(i-2)*x_size+j  ]) &&
-              (x>=r[(i-2)*x_size+j+1]) &&
-              (x>=r[(i-2)*x_size+j+2]) &&
-              (x>=r[(i-1)*x_size+j-2]) &&
-              (x>=r[(i-1)*x_size+j-1]) &&
-	      (x>=r[(i-1)*x_size+j  ]) &&
-	      (x>=r[(i-1)*x_size+j+1]) &&
-	      (x>=r[(i  )*x_size+j-2]) &&
-	      (x>=r[(i  )*x_size+j-1]) &&
-	      (x>=r[(i+1)*x_size+j-2]) )
-#endif
-#ifdef SEVEN_SUPP
-          if (
-                (x>r[(i-3)*x_size+j-3]) &&
-                (x>r[(i-3)*x_size+j-2]) &&
-                (x>r[(i-3)*x_size+j-1]) &&
-                (x>r[(i-3)*x_size+j  ]) &&
-                (x>r[(i-3)*x_size+j+1]) &&
-                (x>r[(i-3)*x_size+j+2]) &&
-                (x>r[(i-3)*x_size+j+3]) &&
-
-                (x>r[(i-2)*x_size+j-3]) &&
-                (x>r[(i-2)*x_size+j-2]) &&
-                (x>r[(i-2)*x_size+j-1]) &&
-                (x>r[(i-2)*x_size+j  ]) &&
-                (x>r[(i-2)*x_size+j+1]) &&
-                (x>r[(i-2)*x_size+j+2]) &&
-                (x>r[(i-2)*x_size+j+3]) &&
-
-                (x>r[(i-1)*x_size+j-3]) &&
-                (x>r[(i-1)*x_size+j-2]) &&
-                (x>r[(i-1)*x_size+j-1]) &&
-                (x>r[(i-1)*x_size+j  ]) &&
-                (x>r[(i-1)*x_size+j+1]) &&
-                (x>r[(i-1)*x_size+j+2]) &&
-                (x>r[(i-1)*x_size+j+3]) &&
-
-                (x>r[(i)*x_size+j-3]) &&
-                (x>r[(i)*x_size+j-2]) &&
-                (x>r[(i)*x_size+j-1]) &&
-                (x>=r[(i)*x_size+j+1]) &&
-                (x>=r[(i)*x_size+j+2]) &&
-                (x>=r[(i)*x_size+j+3]) &&
-
-                (x>=r[(i+1)*x_size+j-3]) &&
-                (x>=r[(i+1)*x_size+j-2]) &&
-                (x>=r[(i+1)*x_size+j-1]) &&
-                (x>=r[(i+1)*x_size+j  ]) &&
-                (x>=r[(i+1)*x_size+j+1]) &&
-                (x>=r[(i+1)*x_size+j+2]) &&
-                (x>=r[(i+1)*x_size+j+3]) &&
-
-                (x>=r[(i+2)*x_size+j-3]) &&
-                (x>=r[(i+2)*x_size+j-2]) &&
-                (x>=r[(i+2)*x_size+j-1]) &&
-                (x>=r[(i+2)*x_size+j  ]) &&
-                (x>=r[(i+2)*x_size+j+1]) &&
-                (x>=r[(i+2)*x_size+j+2]) &&
-                (x>=r[(i+2)*x_size+j+3]) &&
-
-                (x>=r[(i+3)*x_size+j-3]) &&
-                (x>=r[(i+3)*x_size+j-2]) &&
-                (x>=r[(i+3)*x_size+j-1]) &&
-                (x>=r[(i+3)*x_size+j  ]) &&
-                (x>=r[(i+3)*x_size+j+1]) &&
-                (x>=r[(i+3)*x_size+j+2]) &&
-                (x>=r[(i+3)*x_size+j+3]) )
-#endif
-{
-corner_list[n].info=0;
-corner_list[n].x=j;
-corner_list[n].y=i;
-x = in[(i-2)*x_size+j-2] + in[(i-2)*x_size+j-1] + in[(i-2)*x_size+j] + in[(i-2)*x_size+j+1] + in[(i-2)*x_size+j+2] +
-    in[(i-1)*x_size+j-2] + in[(i-1)*x_size+j-1] + in[(i-1)*x_size+j] + in[(i-1)*x_size+j+1] + in[(i-1)*x_size+j+2] +
-    in[(i  )*x_size+j-2] + in[(i  )*x_size+j-1] + in[(i  )*x_size+j] + in[(i  )*x_size+j+1] + in[(i  )*x_size+j+2] +
-    in[(i+1)*x_size+j-2] + in[(i+1)*x_size+j-1] + in[(i+1)*x_size+j] + in[(i+1)*x_size+j+1] + in[(i+1)*x_size+j+2] +
-    in[(i+2)*x_size+j-2] + in[(i+2)*x_size+j-1] + in[(i+2)*x_size+j] + in[(i+2)*x_size+j+1] + in[(i+2)*x_size+j+2];
-
-corner_list[n].I=x/25;
-/*corner_list[n].I=in[i*x_size+j];*/
-x = in[(i-2)*x_size+j+2] + in[(i-1)*x_size+j+2] + in[(i)*x_size+j+2] + in[(i+1)*x_size+j+2] + in[(i+2)*x_size+j+2] -
-   (in[(i-2)*x_size+j-2] + in[(i-1)*x_size+j-2] + in[(i)*x_size+j-2] + in[(i+1)*x_size+j-2] + in[(i+2)*x_size+j-2]);
-x += x + in[(i-2)*x_size+j+1] + in[(i-1)*x_size+j+1] + in[(i)*x_size+j+1] + in[(i+1)*x_size+j+1] + in[(i+2)*x_size+j+1] -
-        (in[(i-2)*x_size+j-1] + in[(i-1)*x_size+j-1] + in[(i)*x_size+j-1] + in[(i+1)*x_size+j-1] + in[(i+2)*x_size+j-1]);
-
-y = in[(i+2)*x_size+j-2] + in[(i+2)*x_size+j-1] + in[(i+2)*x_size+j] + in[(i+2)*x_size+j+1] + in[(i+2)*x_size+j+2] -
-   (in[(i-2)*x_size+j-2] + in[(i-2)*x_size+j-1] + in[(i-2)*x_size+j] + in[(i-2)*x_size+j+1] + in[(i-2)*x_size+j+2]);
-y += y + in[(i+1)*x_size+j-2] + in[(i+1)*x_size+j-1] + in[(i+1)*x_size+j] + in[(i+1)*x_size+j+1] + in[(i+1)*x_size+j+2] -
-        (in[(i-1)*x_size+j-2] + in[(i-1)*x_size+j-1] + in[(i-1)*x_size+j] + in[(i-1)*x_size+j+1] + in[(i-1)*x_size+j+2]);
-corner_list[n].dx=x/15;
-corner_list[n].dy=y/15;
-n++;
-if(n==MAX_CORNERS){
-      fprintf(stderr,"Too many corners.\n");
-      exit(1);
-         }}}}
-corner_list[n].info=7;
-}
-
-/* }}} */
-
-/* }}} */
-/* {{{ main(argc, argv) */
-
-CORNER_LIST corner_list;
-main(argc, argv)
-  int   argc;
-  char  *argv [];
-{
-/* {{{ vars */
-
-FILE   *ofp;
-char   filename [80],
-       *tcp;
-uchar  *in, *bp, *mid;
-float  dt=4.0;
-int    *r,
-       argindex=3,
-       bt=20,
-       principle=0,
-       thin_post_proc=1,
-       three_by_three=0,
-       drawing_mode=0,
-       susan_quick=0,
-       max_no_corners=1850,
-       max_no_edges=2650,
-       mode = 0, i,
-       x_size, y_size;
-
-/* }}} */
-
-  if (argc<3)
-    usage();
-
-printf("before get_image\n");
-
-  get_image(argv[1],&in,&x_size,&y_size);
-
-printf("look at options\n");
-
-  /* {{{ look at options */
-
-  while (argindex < argc)
-  {
-    tcp = argv[argindex];
-    if (*tcp == '-')
-      switch (*++tcp)
-      {
-        case 's': /* smoothing */
-          mode=0;
-	  break;
-        case 'e': /* edges */
-          mode=1;
-	  break;
-        case 'c': /* corners */
-          mode=2;
-	  break;
-        case 'p': /* principle */
-          principle=1;
-	  break;
-        case 'n': /* thinning post processing */
-          thin_post_proc=0;
-	  break;
-        case 'b': /* simple drawing mode */
-          drawing_mode=1;
-	  break;
-        case '3': /* 3x3 flat mask */
-          three_by_three=1;
-	  break;
-        case 'q': /* quick susan mask */
-          susan_quick=1;
-	  break;
-	case 'd': /* distance threshold */
-          if (++argindex >= argc){
-	    printf ("No argument following -d\n");
-	    exit(0);}
-	  dt=atof(argv[argindex]);
-          if (dt<0) three_by_three=1;
-	  break;
-	case 't': /* brightness threshold */
-          if (++argindex >= argc){
-	    printf ("No argument following -t\n");
-	    exit(0);}
-	  bt=atoi(argv[argindex]);
-	  break;
-      }
-      else
-        usage();
-    argindex++;
-  }
-
-  if ( (principle==1) && (mode==0) )
-    mode=1;
-printf("begin main processing\n");
-/* }}} */
-  /* {{{ main processing */
-
-  switch (mode)
-  {
-    case 0:
-      /* {{{ smoothing */
-
-      setup_brightness_lut(&bp,bt,2);
-      susan_smoothing(three_by_three,in,dt,x_size,y_size,bp);
-      break;
-
-/* }}} */
-    case 1:
-      /* {{{ edges */
-
-      r   = (int *) malloc(x_size * y_size * sizeof(int));
-      setup_brightness_lut(&bp,bt,6);
-
-      if (principle)
-      {
-        if (three_by_three)
-          susan_principle_small(in,r,bp,max_no_edges,x_size,y_size);
-        else
-          susan_principle(in,r,bp,max_no_edges,x_size,y_size);
-        int_to_uchar(r,in,x_size*y_size);
-      }
-      else
-      {
-        mid = (uchar *)malloc(x_size*y_size);
-        memset (mid,100,x_size * y_size); /* note not set to zero */
-
-        if (three_by_three)
-          susan_edges_small(in,r,mid,bp,max_no_edges,x_size,y_size);
-        else
-          susan_edges(in,r,mid,bp,max_no_edges,x_size,y_size);
-        if(thin_post_proc)
-          susan_thin(r,mid,x_size,y_size);
-        edge_draw(in,mid,x_size,y_size,drawing_mode);
-      }
-
-      break;
-
-/* }}} */
-    case 2:
-      /* {{{ corners */
-
-      r   = (int *) malloc(x_size * y_size * sizeof(int));
-      setup_brightness_lut(&bp,bt,6);
-
-      if (principle)
-      {
-        susan_principle(in,r,bp,max_no_corners,x_size,y_size);
-        int_to_uchar(r,in,x_size*y_size);
-      }
-      else
-      {
-        if(susan_quick)
-          susan_corners_quick(in,r,bp,max_no_corners,corner_list,x_size,y_size);
-        else
-          susan_corners(in,r,bp,max_no_corners,corner_list,x_size,y_size);
-        corner_draw(in,corner_list,x_size,drawing_mode);
-      }
-
-      break;
-
-/* }}} */
-  }
-
-/* }}} */
-
-  put_image(argv[2],in,x_size,y_size);
-}
-
-/* }}} */
-
-rtems_task Init(
-  rtems_task_argument ignored
-)
-{
-
-
-  char in_file[20] = "/input_small.pgm";
-
-  printf("Unpacking tar filesystem\nThis may take awhile...\n");
-  if(Untar_FromMemory(FileSystemImage, FileSystemImage_size) != 0) {
-    printf("Can't unpack tar filesystem\n");
-    exit(1);
-  }
-
-
-  printf( "\n\n*** susan_edges benchmark ***\n" );
-
-  char * argv[] = {"susan_edges","/input_small.pgm", "/susan_edges.pgm","-e"};
-  main(4,argv);
-
-  printf( "*** end of susan_edges benchmark ***\n" );
-  exit( 0 );
-}
-
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_edges/LICENSE rtems-hwpq-dev/testsuites/mibench/susan_edges/LICENSE
--- rtems-base/testsuites/mibench/susan_edges/LICENSE	2011-01-30 18:51:08.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_edges/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-This code is issued for research purposes only and remains the
-property of the UK Secretary of State for Defence. This code must
-not be passed on without this header information being kept
-intact. This code must not be sold.
-
-A UK patent has been granted: "Method for digitally processing
-images to determine the position of edges and/or corners therein for
-guidance of unmanned vehicle", UK Patent 2272285. Proprietor:
-Secretary of State for Defence, UK. 15 January 1997
-
-
-Source Code obtained from:
-
-http://www.fmrib.ox.ac.uk/~steve/susan/index.html
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_edges/Makefile.am rtems-hwpq-dev/testsuites/mibench/susan_edges/Makefile.am
--- rtems-base/testsuites/mibench/susan_edges/Makefile.am	2011-01-30 13:55:21.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_edges/Makefile.am	2011-01-10 12:53:36.000000000 -0500
@@ -15,7 +15,6 @@ include $(top_srcdir)/../automake/compil
 include $(top_srcdir)/../automake/leaf.am
 
 susan_edges_LDADD = $(MANAGERS_NOT_WANTED:%=$(PROJECT_LIB)/no-%.rel)
-susan_edges_LDLIBS = -lm
 
 LINK_OBJS = $(susan_edges_OBJECTS) $(susan_edges_LDADD)
 LINK_LIBS = $(susan_edges_LDLIBS)
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_edges/system.h rtems-hwpq-dev/testsuites/mibench/susan_edges/system.h
--- rtems-base/testsuites/mibench/susan_edges/system.h	2011-01-30 16:39:47.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_edges/system.h	2011-01-10 12:53:36.000000000 -0500
@@ -39,6 +39,7 @@ rtems_task Init(
 #define CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS 40
 #define CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK 512
 
+
 /* tasks */
 #define CONFIGURE_MAXIMUM_TASKS             4
 #define CONFIGURE_RTEMS_INIT_TASKS_TABLE
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_smoothing/init.c rtems-hwpq-dev/testsuites/mibench/susan_smoothing/init.c
--- rtems-base/testsuites/mibench/susan_smoothing/init.c	2011-02-01 15:05:48.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_smoothing/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -351,7 +351,7 @@ int getint(fd)
   {
     if (c=='#')    /* if we're at a comment, read to end of line */
       //fgets(dummy,9000,fd);
-      while(c != '\n' && i<100)
+      while(c != "\n" && i<56)
       	{
 			c = getc(fd);
 			//printf("%d",i);
@@ -438,7 +438,7 @@ FILE  *fd;
   if ((fd=fopen(filename,"w")) == NULL)
 #endif
     exit_error("Can't output image%s.\n",filename);
-  
+
   fprintf(fd,"P5\n");
   fprintf(fd,"%d %d\n",x_size,y_size);
   fprintf(fd,"255\n");
@@ -1972,7 +1972,6 @@ corner_list[n].info=7;
 
 /* }}} */
 /* {{{ main(argc, argv) */
-CORNER_LIST corner_list;
 
 main(argc, argv)
   int   argc;
@@ -1997,6 +1996,7 @@ int    *r,
        max_no_edges=2650,
        mode = 0, i,
        x_size, y_size;
+CORNER_LIST corner_list;
 
 /* }}} */
 
diff -X dontdiff -uprN rtems-base/testsuites/mibench/susan_smoothing/LICENSE rtems-hwpq-dev/testsuites/mibench/susan_smoothing/LICENSE
--- rtems-base/testsuites/mibench/susan_smoothing/LICENSE	2011-01-30 18:51:12.000000000 -0500
+++ rtems-hwpq-dev/testsuites/mibench/susan_smoothing/LICENSE	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-This code is issued for research purposes only and remains the
-property of the UK Secretary of State for Defence. This code must
-not be passed on without this header information being kept
-intact. This code must not be sold.
-
-A UK patent has been granted: "Method for digitally processing
-images to determine the position of edges and/or corners therein for
-guidance of unmanned vehicle", UK Patent 2272285. Proprietor:
-Secretary of State for Defence, UK. 15 January 1997
-
-
-Source Code obtained from:
-
-http://www.fmrib.ox.ac.uk/~steve/susan/index.html
diff -X dontdiff -uprN rtems-base/testsuites/samples/hello/init.c rtems-hwpq-dev/testsuites/samples/hello/init.c
--- rtems-base/testsuites/samples/hello/init.c	2010-12-13 17:38:47.000000000 -0500
+++ rtems-hwpq-dev/testsuites/samples/hello/init.c	2011-01-10 12:53:36.000000000 -0500
@@ -29,9 +29,11 @@ rtems_task Init(
   rtems_task_argument ignored
 )
 {
+  asm volatile("break_start_opal:");
   printf( "\n\n*** HELLO WORLD TEST ***\n" );
   printf( "Hello World\n" );
   printf( "*** END OF HELLO WORLD TEST ***\n" );
+  MAGIC_BREAKPOINT;
   exit( 0 );
 }
 
