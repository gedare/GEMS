diff -X dontdiff -uprN gems-2.1.1/common/Makefile.common gems-2.1.1-hwpq-head2/common/Makefile.common
--- gems-2.1.1/common/Makefile.common	2010-09-01 14:06:12.000000000 -0400
+++ gems-2.1.1-hwpq-head2/common/Makefile.common	2012-03-01 11:50:16.000000000 -0500
@@ -56,11 +56,11 @@ ifeq ($(SIMICS_VERSION),2.2.X)
   SIMICS_INCLUDE_ROOT := /dev/null22
 else
 ifeq ($(SIMICS_VERSION),3.0)
-  SIMICS_ROOT := /dev/null30
+  SIMICS_ROOT := $(GEMS_ROOT)/simics
   SIMICS_EXEC_ROOT := $(GEMS_ROOT)/simics
   # NOTE: This variable must be updated to point to the src/include directory
   # of your Simics 3.0 installation
-  SIMICS_INCLUDE_ROOT := $(GEMS_ROOT)/simics/src/include
+  SIMICS_INCLUDE_ROOT := $(SIMICS_INSTALL)/src/include
 else
   SIMICS_ROOT := /dev/blah
   SIMICS_EXEC_ROOT := /dev/foo
@@ -98,7 +98,7 @@ LFLAGS := 
 CC_VERSION=3.4.4
 
 ifeq ($(HOST_TYPE),amd64-linux)
-  CC =  /s/gcc-3.4.4/bin/g++
+  CC =  /usr/bin/g++
   #CC =  /usr/bin/g++
   OPT_FLAGS = -m64 -march=opteron -fPIC
   LDFLAGS += -ggdb -g3 -Wl,-R/s/gcc-3.4.4/lib64 
@@ -106,14 +106,14 @@ ifeq ($(HOST_TYPE),amd64-linux)
 
 else
 ifeq ($(HOST_TYPE),v9-sol8-64)
-  # CC = purify -best-effort -leaks-at-exit=yes -chain-length="15" /s/gcc-3.4.1/bin/g++ -static
+  # CC = purify -best-effort -leaks-at-exit=yes -chain-length="15" /usr/bin/g++ -static
   # CC = /s/gcc-3.4.3/bin/g++ -I/s/getopt-0/include
   CC = g++ -I/s/getopt-0/include
   OPT_FLAGS = -m64 -mcpu=v9 -DUSE_DIRENT
   LDFLAGS += -m64 -L/s/getopt-0/lib -lgetopt
 else
 ifeq ($(HOST_TYPE),x86-linux)
-  CC =  /s/gcc-3.4.1/bin/g++
+  CC =  /usr/bin/g++
   #CC =  /usr/bin/g++
   OPT_FLAGS = -march=i686
   LDFLAGS += -ggdb -g3
diff -X dontdiff -uprN gems-2.1.1/jgraph/opal.py gems-2.1.1-hwpq-head2/jgraph/opal.py
--- gems-2.1.1/jgraph/opal.py	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/jgraph/opal.py	2012-03-01 11:48:29.000000000 -0500
@@ -293,7 +293,7 @@ def generate_indirect_branch_prediction_
 
 jgraph_input = []
 #results_dir = "/p/multifacet/projects/ecperf/multifacet/workloads/ecperf/"
-opal_output_dir = "/p/multifacet/projects/ecperf/multifacet/condor/results/"
+opal_output_dir = "/home/gedare/work/research/gab_papers/dissertation/code/pqbench/"
 
 if len(sys.argv) == 2:
     run_dir = sys.argv[1]
diff -X dontdiff -uprN gems-2.1.1/opal/common/hfacore.h gems-2.1.1-hwpq-head2/opal/common/hfacore.h
--- gems-2.1.1/opal/common/hfacore.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/common/hfacore.h	2012-03-01 11:48:30.000000000 -0500
@@ -112,6 +112,7 @@ typedef struct _predictor_state_t {
 #include "iwindow.h"
 #include "scheduler.h"
 #include "cache.h"
+#include "hwpq.h"
 #include "pseq.h"
 #include "system.h"
 #include "power.h"
diff -X dontdiff -uprN gems-2.1.1/opal/common/hfatypes.h gems-2.1.1-hwpq-head2/opal/common/hfatypes.h
--- gems-2.1.1/opal/common/hfatypes.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/common/hfatypes.h	2012-03-01 11:48:30.000000000 -0500
@@ -142,6 +142,7 @@ enum dyn_execute_type_t {
   DYN_STORE,                 // store
   DYN_PREFETCH,              // prefetch memory operation
   DYN_ATOMIC,                // atomic memory operation (atomic swap, etc)
+  DYN_HWPQ,                  // hardware priority queue
   DYN_NUM_EXECUTE_TYPES
 };
 
@@ -162,6 +163,7 @@ enum fu_type_t {
   FU_FLOATSQRT,            // floating point square root
   FU_RDPORT,               // memory read port
   FU_WRPORT,               // memory write port
+  FU_IMPDEP2,              // impdep2 functional unit
   FU_NUM_FU_TYPES          // total functional unit classes
 };
 
diff -X dontdiff -uprN gems-2.1.1/opal/config/alu-standard.txt gems-2.1.1-hwpq-head2/opal/config/alu-standard.txt
--- gems-2.1.1/opal/config/alu-standard.txt	2010-09-01 14:06:14.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/config/alu-standard.txt	2012-03-01 11:48:30.000000000 -0500
@@ -1,14 +1,33 @@
 
+CONFIG_ALU_MAPPING: (
+    0, // FU_NONE,                 // inst does not use a functional unit
+    1, // FU_INTALU,               // integer ALU
+    1, // FU_INTMULT,              // integer multiplier
+    2, // FU_INTDIV,               // integer divider
+    3, // FU_BRANCH,               // compare / branch units
+    4, // FU_FLOATADD,             // floating point adder/subtractor
+    4, // FU_FLOATCMP,             // floating point comparator
+    4, // FU_FLOATCVT,             // floating point<->integer converter
+    5, // FU_FLOATMULT,            // floating point multiplier
+    6, // FU_FLOATDIV,             // floating point divider
+    6, // FU_FLOATSQRT,            // floating point square root
+    7, // FU_RDPORT,               // memory read port
+    8,  // FU_WRPORT,               // memory write port
+    9 // FU_IMPDEP2,               // implementation dependent FU
+       // FU_NUM_FU_TYPES          // total functional unit classes
+)
+
 CONFIG_NUM_ALUS: (
-  127, // inst does not use a functional unit
-    4, // integer ALU (fused multiply/add)
-    2, // integer divisor
-    4, // integer branch
-    4, // FP ALU
-    2, // FP multiply
-    2, // FP divisor / square-root
-    4, // load unit (memory read)
-    4, // store unit (memory write)
+  127, // inst does not use a functional unit (0)
+    4, // integer ALU (fused multiply/add)    (1)
+    2, // integer divisor                     (2)
+    2, // compare branch units                (3)
+    4, // FP ALU                              (4)
+    2, // FP multiply                         (5)
+    2, // FP divisor / square-root            (6)
+    10, // load unit (memory read)            (7)
+    10, // store unit (memory write)          (8)
+    1, // impdep2                             (9)
     0,
     0,
     0,
@@ -20,7 +39,7 @@ CONFIG_ALU_LATENCY: (
     1, // FU_INTALU,               // integer ALU
     4, // FU_INTMULT,              // integer multiplier
    20, // FU_INTDIV,               // integer divider
-    1, // FU_BRANCH,               // branch
+    1, // FU_BRANCH,               // compare / branch units
     2, // FU_FLOATADD,             // floating point adder/subtractor
     2, // FU_FLOATCMP,             // floating point comparator
     2, // FU_FLOATCVT,             // floating point<->integer converter
@@ -28,7 +47,8 @@ CONFIG_ALU_LATENCY: (
    12, // FU_FLOATDIV,             // floating point divider
    24, // FU_FLOATSQRT,            // floating point square root
     1, // FU_RDPORT,               // memory read port
-    1  // FU_WRPORT,               // memory write port
+    1,  // FU_WRPORT,               // memory write port
+    1  // FU_IMPDEP2,               // implementation dependent FU
        // FU_NUM_FU_TYPES          // total functional unit classes
 )
 
diff -X dontdiff -uprN gems-2.1.1/opal/config/config.defaults gems-2.1.1-hwpq-head2/opal/config/config.defaults
--- gems-2.1.1/opal/config/config.defaults	2010-09-01 14:06:14.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/config/config.defaults	2012-03-01 11:48:30.000000000 -0500
@@ -3,7 +3,7 @@
 // specifies number of logical processors per physical processor
 CONFIG_LOGICAL_PER_PHY_PROC:  1
 // specifies how many threads to fetch from in each cycle
-CONFIG_FETCH_THREADS_PER_CYCLE:  2
+CONFIG_FETCH_THREADS_PER_CYCLE:  1
 
 //
 // Processor "Width" (issue, decode, retire width)
@@ -48,20 +48,22 @@ CONFIG_ALU_MAPPING: (
     6, // FU_FLOATDIV,             // floating point divider
     6, // FU_FLOATSQRT,            // floating point square root
     7, // FU_RDPORT,               // memory read port
-    8  // FU_WRPORT,               // memory write port
+    8,  // FU_WRPORT,               // memory write port
+    9 // FU_IMPDEP2,               // implementation dependent FU
        // FU_NUM_FU_TYPES          // total functional unit classes
 )
 
 CONFIG_NUM_ALUS: (
-  127, // inst does not use a functional unit
-    4, // integer ALU (fused multiply/add)
-    2, // integer divisor
-    2, // compare branch units
-    4, // FP ALU
-    2, // FP multiply
-    2, // FP divisor / square-root
-    10, // load unit (memory read)
-    10, // store unit (memory write)
+  127, // inst does not use a functional unit (0)
+    4, // integer ALU (fused multiply/add)    (1)
+    2, // integer divisor                     (2)
+    2, // compare branch units                (3)
+    4, // FP ALU                              (4)
+    2, // FP multiply                         (5)
+    2, // FP divisor / square-root            (6)
+    10, // load unit (memory read)            (7)
+    10, // store unit (memory write)          (8)
+    1, // impdep2                             (9)
     0,
     0,
     0,
@@ -81,7 +83,8 @@ CONFIG_ALU_LATENCY: (
    12, // FU_FLOATDIV,             // floating point divider
    24, // FU_FLOATSQRT,            // floating point square root
     1, // FU_RDPORT,               // memory read port
-    1  // FU_WRPORT,               // memory write port
+    1,  // FU_WRPORT,               // memory write port
+    1  // FU_IMPDEP2,               // implementation dependent FU
        // FU_NUM_FU_TYPES          // total functional unit classes
 )
 
@@ -123,6 +126,16 @@ L2_BLOCK_BITS: 6         // 64 byte cach
 L2_MSHR_ENTRIES: 128
 L2_STREAM_BUFFERS: 0
 
+// GAB: HWDS
+// L1 hwds cache
+HL1_IDEAL: 0              // 1 -> ideal H cache
+HL1_ASSOC: 2              // direct mapped
+HL1_SET_BITS: 8           // 256 sets
+HL1_BLOCK_BITS: 6         // 64  byte L1 cache line
+HL1_MSHR_ENTRIES: 256
+HL1_STREAM_BUFFERS: 0
+CONFIG_NUM_HWPQS: 10
+
 // supported TLB sizes
 TLB_NUM_ENTRIES: 64
 TLB_NUM_PAGE_SIZES: 4
diff -X dontdiff -uprN gems-2.1.1/opal/config/HWPQ-std.txt gems-2.1.1-hwpq-head2/opal/config/HWPQ-std.txt
--- gems-2.1.1/opal/config/HWPQ-std.txt	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/opal/config/HWPQ-std.txt	2012-03-01 11:48:30.000000000 -0500
@@ -0,0 +1,11 @@
+// GAB: HWDS
+// L1 hwds cache
+HL1_IDEAL: 0              // 1 -> ideal H cache
+HL1_ASSOC: 2              // direct mapped
+HL1_SET_BITS: 8           // 256 sets
+HL1_BLOCK_BITS: 6         // 64  byte L1 cache line
+HL1_MSHR_ENTRIES: 256
+HL1_STREAM_BUFFERS: 0
+CONFIG_NUM_HWPQS: 10
+
+
diff -X dontdiff -uprN gems-2.1.1/opal/config/memconf-standard.txt gems-2.1.1-hwpq-head2/opal/config/memconf-standard.txt
--- gems-2.1.1/opal/config/memconf-standard.txt	2010-09-01 14:06:14.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/config/memconf-standard.txt	2012-03-01 11:48:30.000000000 -0500
@@ -1,4 +1,6 @@
 
+#include ./config/HWPQ-std.txt
+
 // Memory latency
 RUBY_CLOCK_DIVISOR: 1
 L2_LATENCY: 6
diff -X dontdiff -uprN gems-2.1.1/opal/Makefile gems-2.1.1-hwpq-head2/opal/Makefile
--- gems-2.1.1/opal/Makefile	2010-09-01 14:06:15.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/Makefile	2012-03-01 11:48:30.000000000 -0500
@@ -61,6 +61,9 @@ DEBUG_FLAGS += -DDEBUG_FILTER
 
 #    defines a lot of verbosity in pseq
 #DEBUG_FLAGS += -DDEBUG_PSEQ
+#DEBUG_FLAGS += -DDEBUG_FETCH
+#DEBUG_FLAGS += -DDEBUG_DECODE
+#DEBUG_FLAGS += -DDEBUG_SCHEDULE
 #    defines debugging of the ruby interface
 #DEBUG_FLAGS += -DDEBUG_RUBY
 #    defines a lot of verbosity in the cache
@@ -180,6 +183,7 @@ SRC_CPP := \
 	flow.C \
 	flatarf.C \
 	gshare.C \
+	hwpq.C \
 	igshare.C \
 	hfa.C \
 	histogram.C \
diff -X dontdiff -uprN gems-2.1.1/opal/system/cache.C gems-2.1.1-hwpq-head2/opal/system/cache.C
--- gems-2.1.1/opal/system/cache.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/cache.C	2012-03-01 11:48:30.000000000 -0500
@@ -94,6 +94,12 @@ cache_t::cache_t(const char *n, mshr_t *
   mshr = m;
   m_eventQueue = eventQueue;
 
+  resetStats();
+}
+
+//**************************************************************************
+void cache_t::resetStats( )
+{
   /* initialize stats to zeros */
   reads = 0;
   read_hit = 0;
@@ -105,7 +111,6 @@ cache_t::cache_t(const char *n, mshr_t *
   replacements = 0;
   writebacks = 0;
 }
-
 //**************************************************************************
 void cache_t::printStats( pseq_t *pseq )
 {
@@ -188,39 +193,6 @@ generic_cache_template<BlockType>::~gene
 
 //**************************************************************************
 template <class BlockType>
-bool generic_cache_template<BlockType>::TagSearch(pa_t a, bool setMRU, bool setDirty,
-    BlockType** block_ptr, uint32 *way) {
-
-  uint32 index = Set(a);
-  pa_t   ba = BlockAddress(a);
-  bool   cachehit = false;
-  ASSERT(index < n_sets);
-
-  /* search all sets until we find a match */
-  BlockType *set = &cache[index * m_assoc];
-  for (uint32 i = 0 ; i < m_assoc ; i ++) {
-    // if it is found in the cache ...
-    if ( (IsValid(set[i]) && getBlockAddress(set[i]) == ba) ) {
-      if(setMRU)
-        set[i].last_access = m_eventQueue->getCycle();
-      if(setDirty)
-        set[i].address_state |= CACHE_BLK_DIRTY;
-      cachehit = true;
-      if(block_ptr) *block_ptr = &set[i];
-      if(way) *way = i;
-      break;
-    }
-  }
-  
-#ifdef DEBUG_CACHE
-  DEBUG_OUT( "%s TagSearch 0x%0llx (TagSearch: index: 0x%0x) ... %d\n",
-             name, a, index, cachehit);
-#endif
-  return cachehit;
-}
-
-//**************************************************************************
-template <class BlockType>
 void generic_cache_template<BlockType>::DoBeforeReplace(BlockType *b, uint32 way) {
   /* update stats */
   if(IsValid(*b)) {
@@ -360,57 +332,6 @@ pa_t generic_cache_template<BlockType>::
 
 #endif
 
-//**************************************************************************
-template <class BlockType>
-void generic_cache_template<BlockType>::Warmup(pa_t a) {
-
-  uint32 index = Set(a);
-  pa_t ba = BlockAddress(a);
-  ASSERT(index < n_sets);
-
-  /* search all sets until we find a match */
-  BlockType *set = &cache[index * m_assoc];
-  for (uint32 i = 0 ; i < m_assoc ; i ++) {
-    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
-    if (hit) { 
-      return;
-    }
-  }
-  int replace_set = random() % m_assoc;
-  /* write new block into the cache */
-  set[replace_set].address_state = ba | CACHE_BLK_VALID;
-}
-
-//**************************************************************************
-template <class BlockType>
-void generic_cache_template<BlockType>::OracleAccess(pa_t a) {
-  /* used when we want the execution of a particular load or store to
-   * be prefetched perfectly.
-   */
-  uint32 index = Set(a);
-  pa_t ba = BlockAddress(a);
-  ASSERT(index < n_sets);
-  STAT_INC(reads);
-
-  /* search all sets until we find a match */
-  BlockType *set = &cache[index * m_assoc];
-  int replace_set = 0;
-  for (uint32 i = 0 ; i < m_assoc ; i ++) {
-    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
-    if (hit) { 
-      STAT_INC(read_hit);
-      return;
-    } 
-    if (set[i].last_access < set[replace_set].last_access) {
-      replace_set = i;
-    }
-  }
-
-  /* write new block into the cache */
-  STAT_INC(read_miss);
-  set[replace_set].address_state = ba | CACHE_BLK_VALID;
-  set[replace_set].last_access = m_eventQueue->getCycle();
-}
 
 //**************************************************************************
 /* this function is called when a store is retired.  If the address
@@ -568,18 +489,6 @@ set_error_t generic_cache_template<Block
   return Sim_Set_Ok;
 }
 
-//**************************************************************************
-template <class BlockType>
-int generic_cache_template<BlockType>::registerCheckpoint( confio_t *conf )
-{
-  int rc;
-
-  rc = conf->register_attribute( name,
-                                 generic_cache_template<BlockType>::get_cache_data, (void *) this,
-                                 generic_cache_template<BlockType>::set_cache_data, (void *) this );
-  return rc;
-}
-
 /*------------------------------------------------------------------------*/
 /* Accessor(s) / mutator(s)                                               */
 /*------------------------------------------------------------------------*/
diff -X dontdiff -uprN gems-2.1.1/opal/system/cache.C.rej gems-2.1.1-hwpq-head2/opal/system/cache.C.rej
--- gems-2.1.1/opal/system/cache.C.rej	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/opal/system/cache.C.rej	2012-03-01 11:50:20.000000000 -0500
@@ -0,0 +1,79 @@
+--- opal/system/cache.C	2010-09-01 14:06:13.000000000 -0400
++++ opal/system/cache.C	2010-09-01 16:46:58.000000000 -0400
+@@ -360,57 +360,6 @@
+ 
+ #endif
+ 
+-//**************************************************************************
+-template <class BlockType>
+-void generic_cache_template<BlockType>::Warmup(pa_t a) {
+-
+-  uint32 index = Set(a);
+-  pa_t ba = BlockAddress(a);
+-  ASSERT(index < n_sets);
+-
+-  /* search all sets until we find a match */
+-  BlockType *set = &cache[index * m_assoc];
+-  for (uint32 i = 0 ; i < m_assoc ; i ++) {
+-    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
+-    if (hit) { 
+-      return;
+-    }
+-  }
+-  int replace_set = random() % m_assoc;
+-  /* write new block into the cache */
+-  set[replace_set].address_state = ba | CACHE_BLK_VALID;
+-}
+-
+-//**************************************************************************
+-template <class BlockType>
+-void generic_cache_template<BlockType>::OracleAccess(pa_t a) {
+-  /* used when we want the execution of a particular load or store to
+-   * be prefetched perfectly.
+-   */
+-  uint32 index = Set(a);
+-  pa_t ba = BlockAddress(a);
+-  ASSERT(index < n_sets);
+-  STAT_INC(reads);
+-
+-  /* search all sets until we find a match */
+-  BlockType *set = &cache[index * m_assoc];
+-  int replace_set = 0;
+-  for (uint32 i = 0 ; i < m_assoc ; i ++) {
+-    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
+-    if (hit) { 
+-      STAT_INC(read_hit);
+-      return;
+-    } 
+-    if (set[i].last_access < set[replace_set].last_access) {
+-      replace_set = i;
+-    }
+-  }
+-
+-  /* write new block into the cache */
+-  STAT_INC(read_miss);
+-  set[replace_set].address_state = ba | CACHE_BLK_VALID;
+-  set[replace_set].last_access = m_eventQueue->getCycle();
+-}
+ 
+ //**************************************************************************
+ /* this function is called when a store is retired.  If the address
+@@ -568,18 +517,6 @@
+   return Sim_Set_Ok;
+ }
+ 
+-//**************************************************************************
+-template <class BlockType>
+-int generic_cache_template<BlockType>::registerCheckpoint( confio_t *conf )
+-{
+-  int rc;
+-
+-  rc = conf->register_attribute( name,
+-                                 generic_cache_template<BlockType>::get_cache_data, (void *) this,
+-                                 generic_cache_template<BlockType>::set_cache_data, (void *) this );
+-  return rc;
+-}
+-
+ /*------------------------------------------------------------------------*/
+ /* Accessor(s) / mutator(s)                                               */
+ /*------------------------------------------------------------------------*/
diff -X dontdiff -uprN gems-2.1.1/opal/system/cache.h gems-2.1.1-hwpq-head2/opal/system/cache.h
--- gems-2.1.1/opal/system/cache.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/cache.h	2012-03-01 11:48:30.000000000 -0500
@@ -59,6 +59,7 @@
 
 #include "mshr.h"
 #include "scheduler.h"
+#include "confio.h"
 
 /*------------------------------------------------------------------------*/
 /* Macro declarations                                                     */
@@ -106,6 +107,9 @@ public:
   /// Prefetch data (request from processor)
   virtual void Prefetch(pa_t a) = 0;
 
+  /// reset statistics
+  virtual void resetStats( void );
+
   /// print out statistics
   virtual void printStats( pseq_t *pseq );
 
@@ -473,4 +477,105 @@ protected:
 /* Global functions                                                       */
 /*------------------------------------------------------------------------*/
 
+/* workaround see: https://lists.cs.wisc.edu/archive/gems-users/2009-March/msg00116.shtml */
+//**************************************************************************
+template <class BlockType>
+int generic_cache_template<BlockType>::registerCheckpoint( confio_t *conf )
+{
+  int rc;
+
+  rc = conf->register_attribute( name,
+                                 generic_cache_template<BlockType>::get_cache_data, (void *) this,
+                                 generic_cache_template<BlockType>::set_cache_data, (void *) this );
+  return rc;
+}
+
+//**************************************************************************
+template <class BlockType>
+void generic_cache_template<BlockType>::OracleAccess(pa_t a) {
+  /* used when we want the execution of a particular load or store to
+   * be prefetched perfectly.
+   */
+  uint32 index = Set(a);
+  pa_t ba = BlockAddress(a);
+  ASSERT(index < n_sets);
+  STAT_INC(reads);
+
+  /* search all sets until we find a match */
+  BlockType *set = &cache[index * m_assoc];
+  int replace_set = 0;
+  for (uint32 i = 0 ; i < m_assoc ; i ++) {
+    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
+    if (hit) { 
+      STAT_INC(read_hit);
+      return;
+    } 
+    if (set[i].last_access < set[replace_set].last_access) {
+      replace_set = i;
+    }
+  }
+
+  /* write new block into the cache */
+  STAT_INC(read_miss);
+  set[replace_set].address_state = ba | CACHE_BLK_VALID;
+  set[replace_set].last_access = m_eventQueue->getCycle();
+}
+
+//**************************************************************************
+template <class BlockType>
+void generic_cache_template<BlockType>::Warmup(pa_t a) {
+
+  uint32 index = Set(a);
+  pa_t ba = BlockAddress(a);
+  ASSERT(index < n_sets);
+
+  /* search all sets until we find a match */
+  BlockType *set = &cache[index * m_assoc];
+  for (uint32 i = 0 ; i < m_assoc ; i ++) {
+    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
+    if (hit) { 
+      return;
+    }
+  }
+  int replace_set = random() % m_assoc;
+  /* write new block into the cache */
+  set[replace_set].address_state = ba | CACHE_BLK_VALID;
+}
+
+//**************************************************************************
+template <class BlockType>
+bool generic_cache_template<BlockType>::TagSearch(pa_t a, bool setMRU, bool setDirty,
+    BlockType** block_ptr, uint32 *way) {
+
+  uint32 index = Set(a);
+  pa_t   ba = BlockAddress(a);
+  bool   cachehit = false;
+  ASSERT(index < n_sets);
+
+  /* search all sets until we find a match */
+  BlockType *set = &cache[index * m_assoc];
+  for (uint32 i = 0 ; i < m_assoc ; i ++) {
+    // if it is found in the cache ...
+    if ( (IsValid(set[i]) && getBlockAddress(set[i]) == ba) ) {
+      if(setMRU)
+        set[i].last_access = m_eventQueue->getCycle();
+      if(setDirty)
+        set[i].address_state |= CACHE_BLK_DIRTY;
+      cachehit = true;
+      if(block_ptr) *block_ptr = &set[i];
+      if(way) *way = i;
+      break;
+    }
+  }
+  
+#ifdef DEBUG_CACHE
+  DEBUG_OUT( "%s TagSearch 0x%0llx (TagSearch: index: 0x%0x) ... %d\n",
+             name, a, index, cachehit);
+#endif
+  return cachehit;
+}
+
+
+
+
 #endif  /* _CACHE_H_ */
diff -X dontdiff -uprN gems-2.1.1/opal/system/cache.h.rej gems-2.1.1-hwpq-head2/opal/system/cache.h.rej
--- gems-2.1.1/opal/system/cache.h.rej	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/opal/system/cache.h.rej	2012-03-01 11:50:21.000000000 -0500
@@ -0,0 +1,83 @@
+--- opal/system/cache.h	2010-09-01 14:06:13.000000000 -0400
++++ opal/system/cache.h	2010-09-01 16:46:58.000000000 -0400
+@@ -59,6 +59,7 @@
+ 
+ #include "mshr.h"
+ #include "scheduler.h"
++#include "confio.h"
+ 
+ /*------------------------------------------------------------------------*/
+ /* Macro declarations                                                     */
+@@ -473,4 +474,72 @@
+ /* Global functions                                                       */
+ /*------------------------------------------------------------------------*/
+ 
++/* workaround see: https://lists.cs.wisc.edu/archive/gems-users/2009-March/msg00116.shtml */
++//**************************************************************************
++template <class BlockType>
++int generic_cache_template<BlockType>::registerCheckpoint( confio_t *conf )
++{
++  int rc;
++
++  rc = conf->register_attribute( name,
++                                 generic_cache_template<BlockType>::get_cache_data, (void *) this,
++                                 generic_cache_template<BlockType>::set_cache_data, (void *) this );
++  return rc;
++}
++
++//**************************************************************************
++template <class BlockType>
++void generic_cache_template<BlockType>::OracleAccess(pa_t a) {
++  /* used when we want the execution of a particular load or store to
++   * be prefetched perfectly.
++   */
++  uint32 index = Set(a);
++  pa_t ba = BlockAddress(a);
++  ASSERT(index < n_sets);
++  STAT_INC(reads);
++
++  /* search all sets until we find a match */
++  BlockType *set = &cache[index * m_assoc];
++  int replace_set = 0;
++  for (uint32 i = 0 ; i < m_assoc ; i ++) {
++    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
++    if (hit) { 
++      STAT_INC(read_hit);
++      return;
++    } 
++    if (set[i].last_access < set[replace_set].last_access) {
++      replace_set = i;
++    }
++  }
++
++  /* write new block into the cache */
++  STAT_INC(read_miss);
++  set[replace_set].address_state = ba | CACHE_BLK_VALID;
++  set[replace_set].last_access = m_eventQueue->getCycle();
++}
++
++//**************************************************************************
++template <class BlockType>
++void generic_cache_template<BlockType>::Warmup(pa_t a) {
++
++  uint32 index = Set(a);
++  pa_t ba = BlockAddress(a);
++  ASSERT(index < n_sets);
++
++  /* search all sets until we find a match */
++  BlockType *set = &cache[index * m_assoc];
++  for (uint32 i = 0 ; i < m_assoc ; i ++) {
++    bool hit = IsValid(set[i]) && (getBlockAddress(set[i]) == ba);
++    if (hit) { 
++      return;
++    }
++  }
++  int replace_set = random() % m_assoc;
++  /* write new block into the cache */
++  set[replace_set].address_state = ba | CACHE_BLK_VALID;
++}
++
++
++
++
+ #endif  /* _CACHE_H_ */
diff -X dontdiff -uprN gems-2.1.1/opal/system/config.include gems-2.1.1-hwpq-head2/opal/system/config.include
--- gems-2.1.1/opal/system/config.include	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/config.include	2012-03-01 11:48:30.000000000 -0500
@@ -90,6 +90,18 @@ PARAM_UINT( L2_STREAM_BUFFERS );
 PARAM_UINT( L2_LATENCY );
 PARAM_UINT( L2_IDEAL );
 
+// GAB: HWDS
+// L1 hwds cache
+PARAM_UINT( HL1_ASSOC );
+PARAM_UINT( HL1_SET_BITS );
+PARAM_UINT( HL1_BLOCK_BITS );
+PARAM_UINT( HL1_MSHR_ENTRIES );
+PARAM_UINT( HL1_STREAM_BUFFERS );
+PARAM_UINT( HL1_IDEAL );
+
+// Number of configured priority queues
+PARAM_UINT( CONFIG_NUM_HWPQS );
+
 // Memory Latency
 PARAM_UINT( MEMORY_DRAM_LATENCY );
 PARAM_UINT( MEMORY_OUTSTANDING_REQUESTS );
diff -X dontdiff -uprN gems-2.1.1/opal/system/controlop.C gems-2.1.1-hwpq-head2/opal/system/controlop.C
--- gems-2.1.1/opal/system/controlop.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/controlop.C	2012-03-01 11:48:30.000000000 -0500
@@ -148,9 +148,9 @@ control_inst_t::Execute()
   if (true) {
 
      #ifdef DEBUG_DYNAMIC
-        char buf[128];
+        //char buf[128];
         s->printDisassemble(buf);
-        DEBUG_OUT("[ %d ] control_inst_t: EXECUTE %s NAV[ %d ] seqnum[ %lld ] fetched[ %lld ] cycle[ %lld ]", m_pseq->getID(), buf, getInstrNAV(), seq_num, m_fetch_cycle, m_pseq->getLocalCycle());
+        //DEBUG_OUT("[ %d ] control_inst_t: EXECUTE %s NAV[ %d ] seqnum[ %lld ] fetched[ %lld ] cycle[ %lld ]", m_pseq->getID(), buf, getInstrNAV(), seq_num, m_fetch_cycle, m_pseq->getLocalCycle());
         //print source and dest regs
         DEBUG_OUT(" SOURCES: ");
         for(int i=0; i < SI_MAX_SOURCE; ++i){
@@ -194,9 +194,9 @@ control_inst_t::Execute()
   SetStage(COMPLETE_STAGE);
 
   #ifdef DEBUG_DYNAMIC
-     char buf[128];
+     //char buf[128];
      s->printDisassemble(buf);
-     DEBUG_OUT("control_inst_t: AFTER Execute %s NAV[ %d ] seqnum[ %lld ] fetched[ %lld ] cycle[ %lld ] PredPC[ 0x%llx ] ActualPC[ 0x%llx ] PredNPC[ 0x%llx ] ActualNPC[ 0x%llx ] PredCWP[ 0x%x ] ActualCWP[ 0x%x ] PredTL[ 0x%x ] ActualTL[ 0x%x ] PredPstate[ 0x%x ] ActualPstate[ 0x%x ]\n", buf, getInstrNAV(), seq_num, m_fetch_cycle, m_pseq->getLocalCycle(), m_predicted.pc, m_actual.pc, m_predicted.npc, m_actual.npc, m_predicted.cwp, m_actual.cwp, m_predicted.tl, m_actual.tl, m_predicted.pstate, m_actual.pstate);
+     //DEBUG_OUT("control_inst_t: AFTER Execute %s NAV[ %d ] seqnum[ %lld ] fetched[ %lld ] cycle[ %lld ] PredPC[ 0x%llx ] ActualPC[ 0x%llx ] PredNPC[ 0x%llx ] ActualNPC[ 0x%llx ] PredCWP[ 0x%x ] ActualCWP[ 0x%x ] PredTL[ 0x%x ] ActualTL[ 0x%x ] PredPstate[ 0x%x ] ActualPstate[ 0x%x ]\n", buf, getInstrNAV(), seq_num, m_fetch_cycle, m_pseq->getLocalCycle(), m_predicted.pc, m_actual.pc, m_predicted.npc, m_actual.npc, m_predicted.cwp, m_actual.cwp, m_predicted.tl, m_actual.tl, m_predicted.pstate, m_actual.pstate);
   #endif
 
       
@@ -213,7 +213,7 @@ control_inst_t::Execute()
      #ifdef DEBUG_DYNAMIC
          char buf[128];
          s->printDisassemble(buf);
-         DEBUG_OUT("[ %d ] control_inst_t: MISPREDICT %s NAV[ %d ] seqnum[ %lld ] fetched[ %lld ] cycle[ %lld ] PredPC[ 0x%llx ] ActualPC[ 0x%llx ] PredNPC[ 0x%llx ] ActualNPC[ 0x%llx ] PredCWP[ 0x%x ] ActualCWP[ 0x%x ] PredTL[ 0x%x ] ActualTL[ 0x%x ] PredPstate[ 0x%x ] ActualPstate[ 0x%x ]\n", m_pseq->getID(), buf, getInstrNAV(), seq_num, m_fetch_cycle, m_pseq->getLocalCycle(), m_predicted.pc, m_actual.pc, m_predicted.npc, m_actual.npc, m_predicted.cwp, m_actual.cwp, m_predicted.tl, m_actual.tl, m_predicted.pstate, m_actual.pstate);
+         //DEBUG_OUT("[ %d ] control_inst_t: MISPREDICT %s NAV[ %d ] seqnum[ %lld ] fetched[ %lld ] cycle[ %lld ] PredPC[ 0x%llx ] ActualPC[ 0x%llx ] PredNPC[ 0x%llx ] ActualNPC[ 0x%llx ] PredCWP[ 0x%x ] ActualCWP[ 0x%x ] PredTL[ 0x%x ] ActualTL[ 0x%x ] PredPstate[ 0x%x ] ActualPstate[ 0x%x ]\n", m_pseq->getID(), buf, getInstrNAV(), seq_num, m_fetch_cycle, m_pseq->getLocalCycle(), m_predicted.pc, m_actual.pc, m_predicted.npc, m_actual.npc, m_predicted.cwp, m_actual.cwp, m_predicted.tl, m_actual.tl, m_predicted.pstate, m_actual.pstate);
      #endif
 
     // This preformatted debugging information is left for your convenience
diff -X dontdiff -uprN gems-2.1.1/opal/system/decode.C gems-2.1.1-hwpq-head2/opal/system/decode.C
--- gems-2.1.1/opal/system/decode.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/decode.C	2012-03-01 11:48:30.000000000 -0500
@@ -63,7 +63,6 @@ const uint64  DECODE_DEFAULT_MIN_LATENCY
 //***************************************************************************
 decode_stat_t::decode_stat_t()
 {
-  m_num_unmatched = 0;
   m_op_seen = (uint64 *) malloc( sizeof(uint64) * (i_maxcount + 1) );
   m_op_succ = (uint64 *) malloc( sizeof(uint64) * (i_maxcount + 1) );
   m_op_functional = (uint64 *) malloc( sizeof(uint64) * (i_maxcount + 1) );
@@ -108,55 +107,7 @@ decode_stat_t::decode_stat_t()
   m_op_trap_atomic_l2miss = new uint64[TRAP_NUM_TRAP_TYPES];
   m_op_trap_l2instrmiss =  new uint64[TRAP_NUM_TRAP_TYPES];
   m_op_trap_seen =  new uint64[TRAP_NUM_TRAP_TYPES];
-
-  for(int i=0; i < TRAP_NUM_TRAP_TYPES; ++i){
-    m_op_trap_load[i] = 0;
-    m_op_trap_store[i] = 0;
-    m_op_trap_atomic[i] = 0;
-    m_op_trap_load_l2miss[i] = 0;
-    m_op_trap_store_l2miss[i] = 0;
-    m_op_trap_atomic_l2miss[i] = 0;
-    m_op_trap_l2instrmiss[i] = 0;
-    m_op_trap_seen[i] = 0;
-  }
-
-  for ( int i = 0; i < i_maxcount; i++ ) {
-    m_op_seen[i] = 0;
-    m_op_succ[i] = 0;
-    m_op_functional[i] = 0;
-    m_op_squash[i] = 0;
-    m_op_noncompliant[i] = 0;
-    m_op_l2miss[i] = 0;
-    m_op_depl2miss[i] = 0;
-    m_op_l2instrmiss[i] = 0;
-
-    m_op_min_execute[i] = DECODE_DEFAULT_MIN_LATENCY;
-    m_op_max_execute[i] = 0;
-    m_op_total_execute[i] = 0;
-
-    m_op_min_contexecute[i] = DECODE_DEFAULT_MIN_LATENCY;
-    m_op_max_contexecute[i] = 0;
-    m_op_total_contexecute[i] = 0;
-
-    m_op_min_decode[i] = DECODE_DEFAULT_MIN_LATENCY;
-    m_op_max_decode[i] = 0;
-    m_op_total_decode[i] = 0;
-
-    m_op_min_operandsready[i] = DECODE_DEFAULT_MIN_LATENCY;
-    m_op_max_operandsready[i] = 0;
-    m_op_total_operandsready[i] = 0;
-
-    m_op_min_scheduler[i] = DECODE_DEFAULT_MIN_LATENCY;
-    m_op_max_scheduler[i] = 0;
-    m_op_total_scheduler[i] = 0;
-
-    m_op_min_retire[i] = DECODE_DEFAULT_MIN_LATENCY;
-    m_op_max_retire[i] = 0;
-    m_op_total_retire[i] = 0;
-
-    m_op_memory_counter[i] = 0;
-    m_op_memory_latency[i] = 0;
-  }
+  resetStats();
 }
 
 /// destructor
@@ -312,6 +263,61 @@ void decode_stat_t::opRetireLatency( enu
   m_op_total_retire[op] += latency;
 }
 
+/// reset statistics
+//***************************************************************************
+void    decode_stat_t::resetStats( )
+{
+  m_num_unmatched = 0;
+  for(int i=0; i < TRAP_NUM_TRAP_TYPES; ++i){
+    m_op_trap_load[i] = 0;
+    m_op_trap_store[i] = 0;
+    m_op_trap_atomic[i] = 0;
+    m_op_trap_load_l2miss[i] = 0;
+    m_op_trap_store_l2miss[i] = 0;
+    m_op_trap_atomic_l2miss[i] = 0;
+    m_op_trap_l2instrmiss[i] = 0;
+    m_op_trap_seen[i] = 0;
+  }
+
+  for ( int i = 0; i < i_maxcount; i++ ) {
+    m_op_seen[i] = 0;
+    m_op_succ[i] = 0;
+    m_op_functional[i] = 0;
+    m_op_squash[i] = 0;
+    m_op_noncompliant[i] = 0;
+    m_op_l2miss[i] = 0;
+    m_op_depl2miss[i] = 0;
+    m_op_l2instrmiss[i] = 0;
+
+    m_op_min_execute[i] = DECODE_DEFAULT_MIN_LATENCY;
+    m_op_max_execute[i] = 0;
+    m_op_total_execute[i] = 0;
+
+    m_op_min_contexecute[i] = DECODE_DEFAULT_MIN_LATENCY;
+    m_op_max_contexecute[i] = 0;
+    m_op_total_contexecute[i] = 0;
+
+    m_op_min_decode[i] = DECODE_DEFAULT_MIN_LATENCY;
+    m_op_max_decode[i] = 0;
+    m_op_total_decode[i] = 0;
+
+    m_op_min_operandsready[i] = DECODE_DEFAULT_MIN_LATENCY;
+    m_op_max_operandsready[i] = 0;
+    m_op_total_operandsready[i] = 0;
+
+    m_op_min_scheduler[i] = DECODE_DEFAULT_MIN_LATENCY;
+    m_op_max_scheduler[i] = 0;
+    m_op_total_scheduler[i] = 0;
+
+    m_op_min_retire[i] = DECODE_DEFAULT_MIN_LATENCY;
+    m_op_max_retire[i] = 0;
+    m_op_total_retire[i] = 0;
+
+    m_op_memory_counter[i] = 0;
+    m_op_memory_latency[i] = 0;
+  }
+
+}
 /// print out table
 //***************************************************************************
 void    decode_stat_t::print( out_intf_t *io )
diff -X dontdiff -uprN gems-2.1.1/opal/system/decode.h gems-2.1.1-hwpq-head2/opal/system/decode.h
--- gems-2.1.1/opal/system/decode.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/decode.h	2012-03-01 11:48:30.000000000 -0500
@@ -182,6 +182,9 @@ public:
     STAT_INC( m_op_noncompliant[op] );
   }
 
+  /// reset statistics
+  void resetStats( void );
+
   /// print out table
   void    print( out_intf_t *io );
   
diff -X dontdiff -uprN gems-2.1.1/opal/system/dx.C gems-2.1.1-hwpq-head2/opal/system/dx.C
--- gems-2.1.1/opal/system/dx.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/dx.C	2012-03-01 11:48:30.000000000 -0500
@@ -89,6 +89,10 @@
 #define  STORE_OP_TYPE store_inst_t
 #define  STORE_OP_GET  static_cast<store_inst_t *>( this )
 
+//***************************************************************************
+#define  HWDS_OP_TYPE hwpq_inst_t
+#define  HWDS_OP_GET  static_cast<hwpq_inst_t *>( this )
+
 // toggle the floating point status register bit (not implemented currently)
 //***************************************************************************
 #define  UPDATE_FSR
diff -X dontdiff -uprN gems-2.1.1/opal/system/dx.i gems-2.1.1-hwpq-head2/opal/system/dx.i
--- gems-2.1.1/opal/system/dx.i	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/dx.i	2012-03-01 11:48:30.000000000 -0500
@@ -3424,6 +3424,8 @@ DX_RETURNT dx__trap( DX_PLIST ) {
 DX_RETURNT dx_impdep1( DX_PLIST ) {
 }
 
+// GAB: hw priority queue impdep2 instruction
+// This has been moved to hwpq.C
 DX_RETURNT dx_impdep2( DX_PLIST ) {
 }
 
diff -X dontdiff -uprN gems-2.1.1/opal/system/dynamic.C gems-2.1.1-hwpq-head2/opal/system/dynamic.C
--- gems-2.1.1/opal/system/dynamic.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/dynamic.C	2012-03-01 11:48:30.000000000 -0500
@@ -77,7 +77,7 @@
 /*------------------------------------------------------------------------*/
 /* Macro declarations                                                     */
 /*------------------------------------------------------------------------*/
-
+//#define DEBUG_DYNAMIC
 /*------------------------------------------------------------------------*/
 /* Variable declarations                                                  */
 /*------------------------------------------------------------------------*/
@@ -231,7 +231,7 @@ dynamic_inst_t::Decode( uint64 issueTime
 {
   assert(m_proc < CONFIG_LOGICAL_PER_PHY_PROC);
 
-  #ifdef DEBUG_DYNAMIC
+  #ifdef DEBUG_DECODE
       DEBUG_OUT("dynamic_inst_t:Decode issueTime[%d] seqnum[%d] proc[%d]\n",issueTime,
                          seq_num, m_proc);
   #endif
@@ -243,11 +243,11 @@ dynamic_inst_t::Decode( uint64 issueTime
    * for each source, get the mapped register 
    */
   for (int i = 0; i < SI_MAX_SOURCE; i++) {
-   #ifdef DEBUG_DYNAMIC
+   #ifdef DEBUG_DECODE
     //  DEBUG_OUT("\tBefore getSourceReg...\n");
   #endif
     reg_id_t &source = getSourceReg(i);
-  #ifdef DEBUG_DYNAMIC
+  #ifdef DEBUG_DECODE
     //DEBUG_OUT("\tAfter getSourceReg\n");
   #endif
     source.getARF()->readDecodeMap( source, m_proc );    
@@ -271,7 +271,7 @@ dynamic_inst_t::Decode( uint64 issueTime
   SetPriority( issueTime );
   SetStage(DECODE_STAGE);
 
- #ifdef DEBUG_DYNAMIC
+ #ifdef DEBUG_DECODE
      DEBUG_OUT("dynamic_inst_t:Decode END issueTime[%d] proc[%d] seqnum[%d]\n",issueTime,
                          m_proc, seq_num);
   #endif
@@ -393,17 +393,17 @@ dynamic_inst_t::testSourceReadiness() { 
 //**************************************************************************
 void 
 dynamic_inst_t::Schedule() { 
-   #ifdef DEBUG_DYNAMIC
+   #ifdef DEBUG_SCHEDULE
      DEBUG_OUT("dynamic_inst_t:Schedule BEGIN proc[%d] seqnum[%d]\n", m_proc,seq_num);
+    printDetail();  
   #endif
 
      //used to indicate whether to stall scheduler
      bool stall = false;
-
-     #ifdef DEBUG_REG
-       char buf[128];
-       s->printDisassemble(buf);
-     #endif
+#if defined(DEBUG_REG) || defined(DEBUG_SCHEDULE)
+  char buf[128];
+  s->printDisassemble(buf);
+#endif
 
   switch (m_stage) {
   case WAIT_4TH_STAGE:
@@ -601,6 +601,14 @@ dynamic_inst_t::Schedule() { 
         }
       }
     }
+    // GAB: Stall hwpq. It will be woken later when the instruction window
+    // reaches this instruction. This ensures in-order execution semantics
+    if (s->getType() == DYN_HWPQ) {
+      if (!(static_cast<hwpq_inst_t *> (this))->isInOrder()) {
+        stall = true;
+      }
+    }
+
     if(!stall){
       m_pseq->getScheduler()->schedule(this);
     }
@@ -732,6 +740,13 @@ dynamic_inst_t::Schedule() { 
     static_cast<memory_inst_t *> (this)->Complete(); 
     break;
 
+  case HWDS_CACHE_MISS_STAGE:
+    #ifdef DEBUG_SCHEDULE
+      DEBUG_OUT("HWDS_CACHE_MISS_STAGE, cycle[ %lld ] seqnum[ %d ] proc[ %d ] %s\n", m_pseq->getLocalCycle(), seq_num, m_proc, buf);
+    #endif
+    static_cast<hwpq_inst_t *> (this)->Complete();
+    break;
+
   case CACHE_NOTREADY_STAGE:
       #ifdef DEBUG_REG
              DEBUG_OUT("CACHE_NOTREADY_STAGE, cycle[ %lld ] seqnum[ %d ] proc[ %d ] %s\n", m_pseq->getLocalCycle(), seq_num, m_proc, buf);
@@ -794,11 +809,15 @@ dynamic_inst_t::Schedule() { 
     SIM_HALT;
 
   default:
+  #ifdef DEBUG_REG
+    DEBUG_OUT("%s stage (%d), cycle[ %lld ] seqnum[ %d ] proc[ %d ] %s\n", 
+    printStage(m_stage), m_stage, m_pseq->getLocalCycle(), seq_num, m_proc, buf);
+  #endif
     /* should never reach this stage */
     SIM_HALT;
   }
 
- #ifdef DEBUG_DYNAMIC
+ #ifdef DEBUG_SCHEDULE
      DEBUG_OUT("dynamic_inst_t:Schedule END proc[%d] seqnum[%d]\n",m_proc,seq_num);
   #endif
   // DEBUG_OUT("instruction: %s stage: %d\n", print(), m_stage);
@@ -1490,6 +1509,8 @@ const char *dynamic_inst_t::printStage( 
     return ("EARLY_ATOMIC_STAGE");
   case CACHE_MISS_STAGE:
     return ("CACHE_MISS_STAGE");
+  case HWDS_CACHE_MISS_STAGE:
+    return ("HWDS_CACHE_MISS_STAGE");
   case CACHE_NOTREADY_STAGE:
     return ("CACHE_NOTREADY_STAGE");
   case CACHE_MISS_RETIREMENT_STAGE:
@@ -1529,6 +1550,7 @@ const char *dynamic_inst_t::printStageAb
   case EARLY_STORE_STAGE:
   case EARLY_ATOMIC_STAGE:
   case CACHE_MISS_STAGE:
+  case HWDS_CACHE_MISS_STAGE:
   case CACHE_NOTREADY_STAGE:
   case CACHE_MISS_RETIREMENT_STAGE:
   case CACHE_NOTREADY_RETIREMENT_STAGE:
diff -X dontdiff -uprN gems-2.1.1/opal/system/dynamic.h gems-2.1.1-hwpq-head2/opal/system/dynamic.h
--- gems-2.1.1/opal/system/dynamic.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/dynamic.h	2012-03-01 11:48:30.000000000 -0500
@@ -175,6 +175,7 @@ public:
     EARLY_STORE_STAGE,
     EARLY_ATOMIC_STAGE,
     CACHE_MISS_STAGE,
+    HWDS_CACHE_MISS_STAGE,
     CACHE_NOTREADY_STAGE,
     CACHE_MISS_RETIREMENT_STAGE,
     CACHE_NOTREADY_RETIREMENT_STAGE,
diff -X dontdiff -uprN gems-2.1.1/opal/system/hfa.C gems-2.1.1-hwpq-head2/opal/system/hfa.C
--- gems-2.1.1/opal/system/hfa.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/hfa.C	2012-03-01 11:48:30.000000000 -0500
@@ -201,6 +201,9 @@ void hfa_allocate( void )
                                  sizeof(atomic_inst_t), 100 );
   prefetch_inst_t::m_myalloc.init( "prefetch_inst_t",
                                    sizeof(prefetch_inst_t), 100 );
+  /// memory allocator for hwpq instructions (hwpq.C)
+  hwpq_inst_t::m_myalloc.init( "hwpq_inst_t",
+                                  sizeof(hwpq_inst_t), 100 );
   /// memory allocator for branch, etc. instructions (controlop.C)
   control_inst_t::m_myalloc.init( "control_inst_t",
                                   sizeof(control_inst_t), 100 );
diff -X dontdiff -uprN gems-2.1.1/opal/system/hwpq.C gems-2.1.1-hwpq-head2/opal/system/hwpq.C
--- gems-2.1.1/opal/system/hwpq.C	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/opal/system/hwpq.C	2012-03-12 12:37:13.000000000 -0400
@@ -0,0 +1,439 @@
+/*
+ * FileName:  hwpq.C
+ * Synopsis:  Implements a hardware priority queue
+ * Author:    gedare
+ * Version:   $Id$
+ */
+
+/*------------------------------------------------------------------------*/
+/* Includes                                                               */
+/*------------------------------------------------------------------------*/
+
+#include "hfa.h"
+#include "hfacore.h"
+
+#include "hwpq.h"
+#include <stdio.h>
+#include <vector>
+
+#define M_PSTATE \
+  system_t::inst->m_state[insn->m_pseq->getID()/CONFIG_LOGICAL_PER_PHY_PROC]
+
+/// memory allocator for hwpq.C
+listalloc_t hwpq_inst_t::m_myalloc;
+
+void hwpq_t::fill(hwpq_node_t* node) {
+  // insert node to hwpq
+  insert(node);
+
+  // update count
+  --m_spill_count;
+
+  // TODO: fix valid bits (should be done while inserting, but this is easy)
+
+  // TODO: handle special case for when fill last element from SW spill area.
+  if (!m_spill_count) {
+
+  }
+}
+
+uint64 hwpq_t::spill( ) {
+  hwpq_node_t* last;
+  uint64 payload;
+
+  // remove last element from hwpq
+  payload = extract_last();
+
+  // update count
+  if ( payload )
+    ++m_spill_count;
+
+  // TODO: update valid
+
+  return payload;
+}
+
+void hwpq_t::print_queue() {
+  vector<hwpq_node_t *>::iterator i;
+  for (i = m_pq.begin(); i != m_pq.end(); i++ )
+    (*i)->print_node();
+}
+
+hwpq_node_t* hwpq_t::first() {
+#ifdef GAB_DEBUG
+  DEBUG_OUT("pq_first:\n");
+  print_queue();
+#endif
+  // return NULL if the queue is empty
+  if (m_pq.empty()) {
+    return NULL;
+  }
+
+  return m_pq.front();
+}
+
+hwpq_node_t* hwpq_t::last() {
+  hwpq_node_t* node = NULL;
+#ifdef GAB_DEBUG
+  DEBUG_OUT("pq_last:\n");
+  print_queue();
+#endif
+
+  if (!m_pq.empty())
+    node = m_pq.back();
+
+  return node;
+}
+
+// returns the last nodes payload
+uint64 hwpq_t::extract_last( )
+{
+  hwpq_node_t* node = NULL;
+  uint64 payload = 0;
+#ifdef GAB_DEBUG
+  DEBUG_OUT("extract_last:\n");
+  print_queue();
+#endif
+
+  // now pop the least priority element
+  if (!m_pq.empty()) {
+    node = m_pq.back();
+    payload = node->payload;
+    m_pq.pop_back();
+  }
+
+  return payload;
+}
+
+hwpq_node_t* hwpq_t::extract(uint64 data)
+{
+  vector< hwpq_node_t * >::iterator i;
+  hwpq_node_t *node = NULL;
+#ifdef GAB_DEBUG
+  DEBUG_OUT("pq_extract:\n");
+  print_queue();
+#endif
+
+  /* search for data in pq */
+  for ( i = m_pq.begin(); i != m_pq.end(); i++ ) {
+    if ((*i)->payload == data) break;
+  }
+
+  if (i != m_pq.end()) { /* found data */
+    node = *i;
+    m_pq.erase( i );
+  }
+#ifdef GAB_DEBUG
+  DEBUG_OUT("pq_extract:\n");
+  print_queue();
+#endif
+  return node;
+}
+
+void hwpq_t::insert(hwpq_node_t *node) 
+{
+#ifdef GAB_DEBUG
+  DEBUG_OUT("pq_insert:\n");
+  print_queue();
+#endif
+
+  // use stable sort so that the hwpq-decoder and opal construct same hwpq
+  typename vector<hwpq_node_t *>::iterator i;
+  for ( i = m_pq.begin(); i != m_pq.end(); i++ ) {
+    if ( (*i)->priority > node->priority )
+      break;
+  }
+  m_pq.insert(i, node);
+#ifdef GAB_DEBUG
+  DEBUG_OUT("pq_insert\n");
+  print_queue();
+#endif
+}
+
+hwpq_inst_t::hwpq_inst_t( static_inst_t *s_inst,
+      int32 window_index,
+      pseq_t *pseq,
+      abstract_pc_t *at,
+      pa_t physicalPC,
+      trap_type_t trapgroup,
+      uint32 proc) 
+  : dynamic_inst_t( s_inst, window_index, pseq, at, physicalPC, trapgroup, proc) {
+    // default dynamic_inst_t constructor
+#ifdef GAB_DEBUG
+  DEBUG_OUT("hwpq_inst_t()\n");
+#endif
+
+    m_in_order = false;
+}
+
+hwpq_inst_t::~hwpq_inst_t() {
+
+}
+
+void hwpq_inst_t::Squash() {
+  // sanity
+  ASSERT(m_proc < CONFIG_LOGICAL_PER_PHY_PROC);
+  ASSERT( !getEvent( EVENT_FINALIZED ) );
+  ASSERT(m_stage != RETIRE_STAGE);
+
+#ifdef GAB_DEBUG
+  DEBUG_OUT("hwpq_inst_t::Squash()\n");
+#endif
+  // adjust any of the 'soft' state of this instruction
+
+  // generic dynamic_inst_t::Squash() actions
+  if (Waiting())
+    RemoveWaitQueue();
+
+  UnwindRegisters();
+
+  m_pseq->decrementSequenceNumber(m_proc);
+
+  markEvent( EVENT_FINALIZED );
+#ifdef PIPELINE_VIS
+    m_pseq->out_log("squash %d\n", getWindowIndex());
+#endif
+}
+
+void hwpq_inst_t::Retire( abstract_pc_t *a ) {
+#ifdef GAB_DEBUG
+  DEBUG_OUT("hwpq_inst_t()::Retire()\n");
+#endif
+  STAT_INC( m_pseq->m_stat_hwds_retired[m_proc] );
+
+  // generic dynamic_inst_t::Retire() actions
+  // record when execution takes place
+  m_event_times[EVENT_TIME_RETIRE] = m_pseq->getLocalCycle() - m_fetch_cycle;
+
+  ASSERT( !getEvent( EVENT_FINALIZED ) );
+  ASSERT( !s->getFlag( SI_FETCH_BARRIER ) );
+
+  retireRegisters();
+  SetStage(RETIRE_STAGE);
+  nextPC_execute( a );
+  markEvent( EVENT_FINALIZED );
+
+}
+
+void hwpq_inst_t::Execute() {
+#ifdef GAB_DEBUG
+  DEBUG_OUT("hwpq_inst_t()::Execute()\n");
+#endif
+  STAT_INC( m_pseq->m_stat_hwds_exec[m_proc] );
+
+  // generic dynamic_inst_t::Execute() actions
+  // record when execution takes place
+  m_event_times[EVENT_TIME_EXECUTE_DONE] = 
+    m_pseq->getLocalCycle() - m_fetch_cycle;
+
+  // call the appropriate function
+  static_inst_t *si = getStaticInst();
+
+  /**
+   * The next chunk used to be in dx.i, but works better here.
+   */
+
+  // check the immediate bit
+  if (si->getFlag(SI_ISIMMEDIATE)) {
+    // the old hwpq implementation used the immediate insn encoding
+    // the new implementation uses two source registers.
+    DEBUG_OUT("Unimplemented instruction: 0x%0x\n", si->getInst());
+    SetStage(COMPLETE_STAGE);
+    return; // throw exception?
+  }
+
+  hwpq_t *queue = NULL;
+  hwpq_node_t *node;
+  hwpq_node_t *new_node = NULL;
+  uint32 queue_idx = 0;
+  int operation = 0;
+  int value = 0;
+  uint64 pointer = 0;
+  static uint64 context = 0;
+  static uint32 current_queue = 0;
+
+  // dx.i macros
+#define IREGISTER ireg_t
+
+#define SOURCE1    getSourceReg(0).getARF()->readInt64( getSourceReg(0), getProc() )
+
+#define SOURCE2    getSourceReg(1).getARF()->readInt64( getSourceReg(1), getProc() )
+
+#define S2ORI     (getStaticInst()->getFlag(SI_ISIMMEDIATE) ? \
+    getStaticInst()->getImmediate() :   \
+    SOURCE2)
+
+  // slightly modified
+#define WRITE_DEST(A)         \
+  getDestReg(0).getARF()->writeInt64( getDestReg(0), (A), getProc() ); 
+
+  // dx.C
+#define  HWDS_OP_GET  static_cast<hwpq_inst_t *>( this )
+
+  IREGISTER result = 0;
+  
+  queue_idx = maskBits32(S2ORI,31,20);
+//  value = maskBits32(S2ORI,19,4);
+  value = maskBits64(SOURCE1,63,32);
+  operation = maskBits32(S2ORI,3,0);
+
+  if ( operation != 5 ) {
+    // propagates across HWDS calls.
+    context = ((context<<32)|S2ORI);
+  }
+
+  if (queue_idx > CONFIG_NUM_HWPQS) {
+    DEBUG_OUT("Invalid queue_idx: %d\n", queue_idx);
+    DEBUG_OUT("Instruction: 0x%0x\n",
+        getStaticInst()->getInst());
+    return;
+  }
+  queue = &m_pseq->getHardwarePriorityQueue()[queue_idx];
+
+  // TODO: check if requested queue is resident
+
+  // TODO: get the current size and limit of queue
+
+  m_hwpq = queue;
+  m_type = HWDS_INST_UNUSED;
+#ifdef GAB_DEBUG
+  static tick_t cycles_store = 0;
+  tick_t cycles_diff = 0;
+  static uint64 sn_store = 0;
+  uint64 sn_diff = 0;
+#endif
+
+  // Check for exceptions
+  if (operation != 5 /* get_context */ &&
+      operation != 10 /* get_pointer */ &&
+      operation != 11 /* adjust_spill_count */ &&
+      operation != 12 /* get_size */ &&
+      operation != 13 /* set current id */ && 
+      operation != 14 /* get current id */
+     ) {
+    // check if the chosen queue is available
+    if ( queue_idx != current_queue ) {
+       DEBUG_OUT("Op: %d\tCurrent Queue: %d\tNext Queue: %d\n",
+                          operation, current_queue, queue_idx);
+      /* context switch exception raised */
+    } else  if (operation != 7 /* && need_spill */ )  {
+      /* spill exception raised */
+    } else if (operation != 7 && operation != 8 /* && need_fill */ ) {
+      /* fill exception raised */
+    }
+  }
+
+  switch ( operation ) {
+
+    case 1: // first
+      STAT_INC( m_pseq->m_stat_hwds_first_exec[m_proc] );
+      node = queue->first();
+      if (node) {
+        result = node->payload;
+      } else {
+        result = ((IREGISTER)-1);
+      }
+      break;
+
+    case 2: // enqueue
+      STAT_INC( m_pseq->m_stat_hwds_insert_exec[m_proc] );
+      pointer = SOURCE1;
+      new_node = new hwpq_node_t(value, pointer);
+      //        new_node = (pq_node*)malloc(sizeof(pq_node));
+      if (!new_node) {
+        DEBUG_OUT("Unable to allocate space for new pq node\n");
+        break; // should throw exception
+      }
+      queue->insert(new_node);
+      new_node = NULL;
+      break;
+
+    case 3: // extract
+      STAT_INC( m_pseq->m_stat_hwds_extract_exec[m_proc] );
+      pointer = SOURCE1;
+      node = queue->extract(pointer);
+      if (node) {
+        delete node;
+        /* check for underflow condition */
+      } else {
+        /* failed to extract, raise to SW */
+        result = (IREGISTER)-1;
+      }
+      break;
+
+    case 4: // setrange
+      DEBUG_OUT("Unsupported operation: %d\n", operation);
+      break;
+
+    case 5: // get context
+      STAT_INC( m_pseq->m_stat_hwds_get_context_exec[m_proc] );
+      result = context;
+      break;
+
+    case 6: // extract last
+      STAT_INC( m_pseq->m_stat_hwds_extract_last_exec[m_proc] );
+      result = queue->extract_last();
+      break;
+
+    case 7: // spill
+      STAT_INC( m_pseq->m_stat_hwds_spill_exec[m_proc] );
+      result = queue->spill();
+      break;
+
+    case 8: // fill
+      STAT_INC( m_pseq->m_stat_hwds_fill_exec[m_proc] );
+      new_node = new hwpq_node_t(value, SOURCE1);
+      queue->fill(new_node);
+      // check for need_spill
+      if (queue->need_spill())
+        result = 1;
+      break;
+
+    case 9: // last prio
+      node = queue->last();
+      if (node) {
+        result = node->priority;
+      }
+      break;
+
+    case 10: // get pointer
+      result = pointer;
+      break;
+
+    case 11: // adjust_spill_count
+      STAT_INC( m_pseq->m_stat_hwds_adjust_spill_count_exec[m_proc] );
+      queue->dec_spill_count();
+      break;
+
+    case 12: // get size limit
+      // FIXME: Somewhat irrelevant since the hwpq initializes before opal..
+      break;
+
+    case 13: // set current id
+      current_queue = queue_idx;
+      break;
+
+    case 14: // get current id
+      result = current_queue;
+      break;
+
+    default:
+      DEBUG_OUT("Unknown operation: %d\n", operation);
+      break; // should throw exception
+  }
+  WRITE_DEST(result);
+  SetStage(COMPLETE_STAGE);
+}
+
+void hwpq_inst_t::Complete() {
+
+  switch (m_type) {
+    default:
+      DEBUG_OUT("Invalid instruction type at Complete: %d\n", m_type);
+      break;
+  }
+  WRITE_DEST(0);
+  SetStage(COMPLETE_STAGE);
+}
+
+
diff -X dontdiff -uprN gems-2.1.1/opal/system/hwpq.h gems-2.1.1-hwpq-head2/opal/system/hwpq.h
--- gems-2.1.1/opal/system/hwpq.h	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/opal/system/hwpq.h	2012-03-12 12:30:12.000000000 -0400
@@ -0,0 +1,289 @@
+/*
+ * hwpq.h
+ *
+ * A priority queue supporting:
+ *  enqueue
+ *  extract
+ *  first (peek)
+ * For modelling a HW PQ.  
+ */
+
+#ifndef _HWPQ_H_
+#define _HWPQ_H_
+
+/*------------------------------------------------------------------------*/
+/* Includes                                                               */
+/*------------------------------------------------------------------------*/
+
+#include <vector>
+#include <stdio.h>
+
+#include "dynamic.h"
+
+/*------------------------------------------------------------------------*/
+/* Macro declarations                                                     */
+/*------------------------------------------------------------------------*/
+
+//#define GAB_DEBUG
+//#define GAB_HWDS_DEBUG
+
+/*------------------------------------------------------------------------*/
+/* Class declaration(s)                                                   */
+/*------------------------------------------------------------------------*/
+
+class hwpq_t;
+
+// types of hwpq instructions
+enum hwds_inst_type_t {
+  HWDS_INST_UNUSED = 0,
+  HWDS_INST_FIRST,
+  HWDS_INST_ENQUEUE,
+  HWDS_INST_EXTRACT,
+  HWDS_INST_SETRANGE,
+  HWDS_INST_SPILL,
+  HWDS_INST_FILL,
+  HWDS_INST_SPILL_AT,
+  HWDS_INST_FILL_AT
+};
+
+/**
+ * An "in-flight" hwpq instruction in the processor model.
+ * This will probably change to a hwds interface and hwpq implementation.
+ *
+ * @see     dynamic_inst_t, waiter_t
+ * @author  gedare
+ * @version $Id$
+ */
+//**************************************************************************
+class hwpq_inst_t : public dynamic_inst_t {
+  friend class hwpq_t;
+public:
+  /** @name Constructor(s) / Destructor */
+  //@{
+  //  /** Constructor: uses default constructor */
+  hwpq_inst_t( static_inst_t *s_inst,
+      int32 window_index,
+      pseq_t *pseq,
+      abstract_pc_t *at,
+      pa_t physicalPC,
+      trap_type_t trapgroup,
+      uint32 proc
+      );
+
+  /** Destructor: uses default destructor. */
+  ~hwpq_inst_t();
+  //@}
+
+  /** complete a hwds operation that has missed in the cache */
+  void Complete( void );
+
+  /** Allocates object throuh allocator interface */
+  void *operator new( size_t size ) {
+    return ( m_myalloc.memalloc( size ) );
+  }
+  
+  /** frees object through allocator interface */
+  void operator delete( void *obj ) {
+    m_myalloc.memfree( obj );
+  }
+
+  /** dynamic_inst_t virtual functions */
+  /** squash an instruction in the pipe, after it has been renamed.
+   *  As it rolls back the state it is implemented differently by control,
+   *  exec, mem, hwds instrs. */
+  void Squash();
+  /** retire: change the machines in-order architected state according
+   *  to an instruction.
+   *  (implemented differently by control, exec, mem, hwds instrs).
+   *  @param a   The next in-order pc, when this instruction is retired.
+   */
+  void Retire( abstract_pc_t *a );
+
+  /** do the generic execution stuff for hwds operations */
+  void Execute();
+
+  bool isInOrder() { return m_in_order; }
+  void setInOrder() { m_in_order = true; }
+
+  /** @name memory allocation:: */
+  //@{
+  static listalloc_t m_myalloc;
+  //@}
+
+ //TODO: private? // for fill/spill insns, the addr of the slot
+  la_t m_addr;
+private:
+  // flag set true when the hwpq instruction is in order (at least 
+  // wrt other hwpq instructions and branches). This is used to control
+  // when the hwpq fires.
+  bool m_in_order;
+
+  // the hwpq for this instruction
+  hwpq_t *m_hwpq;
+
+  // the type of this instruction
+  hwds_inst_type_t m_type;
+
+};
+ 
+/**
+ *  A simulated hardware priority queue
+ *
+ * @see     hwpq_inst_t
+ * @author  gedare
+ * @version $Id$
+ */
+//**************************************************************************
+
+class hwpq_node_t {
+  public:
+    hwpq_node_t(int priority, uint64 payload) {
+      this->priority = priority;
+      this->payload = payload;
+    }
+
+    /** Print a node */
+    void print_node() { printf("%d\t%llu\n",priority,payload); }
+
+    /**
+     * @name Accessor(s) / mutator(s)
+     */
+    void set_priority(int p) { priority = p; }
+    int get_priority() { return priority; }
+
+    void set_payload(uint64 p) { payload = p; }
+    uint64 get_payload() { return payload; }
+
+    // should be private, but makes comparisons harder.
+    int priority;
+    uint64 payload;
+
+};
+
+/**
+* A priority queue implemented in hardware. It is a heap built with the 
+* vector STL.
+*
+* @see    
+* @author  gedare
+* @version $Id$
+*/
+class hwpq_t {
+public:
+  /**
+   * @name Constructor(s) / destructor
+   */
+  //@{
+
+  /** Constructor */
+  hwpq_t() {
+    m_pq_is_ascending = true;
+    m_spill_count = 0;
+  }
+
+  /**
+   * Constructor: creates object
+   * @param is_ascending true if low priority value means high priority level
+   */
+  hwpq_t(bool is_ascending) {
+    m_pq_is_ascending = is_ascending;    
+  }
+
+  /**
+   * Destructor: frees object.
+   */
+  ~hwpq_t() { ; };
+  //@}
+
+  /**
+   * @name Methods
+   */
+  //@{
+
+  /**
+   * Spill/fill related functions and fields would probably be inherited.
+   */
+  
+  /** Spill the tail of queue to backing store */
+  uint64 spill();
+
+  /** Fill the queue from backing store */
+  void fill(hwpq_node_t*);
+
+  /** Retrieve first (highest priority) element */
+  hwpq_node_t* first();
+
+  /** Retrieve last (lowest priority) element */
+  hwpq_node_t* last();
+  
+  /** Remove the last (lowest priority) element */
+  uint64 extract_last( );
+
+  /** Extract an element with given payload */
+  hwpq_node_t* extract(uint64 payload);
+
+  /** Insert an element with given priority and payload */
+  void insert(hwpq_node_t* node);
+
+  /** Print the queue */
+  void print_queue();
+
+  /** Compare two elements on the queue (used to create a max heap with STL) */
+  class hwpq_node_heap_max_compare {
+    public:
+      bool operator() ( const hwpq_node_t *a, const hwpq_node_t *b ) const {
+        return a->priority < b->priority;
+      }
+  };
+
+  /** Compare two elements on the queue (used to create a min heap with STL) */
+  class hwpq_node_heap_min_compare {
+    public:
+      bool operator() ( const hwpq_node_t *a, const hwpq_node_t *b ) const {
+        return a->priority > b->priority;
+      }
+  };
+
+  bool is_ascending() {
+    return m_pq_is_ascending;
+  }
+
+  bool need_spill() {
+    return m_spill_count > 0;
+  }
+
+  //@}
+
+  /**
+   * @name Accessor(s) / mutator(s)
+   */
+  //@{
+
+  void dec_spill_count() {--m_spill_count;}
+
+private:
+  // priority queue as a heap
+  vector<hwpq_node_t *> m_pq; 
+
+  // true if low priority value means higher priority level
+  bool m_pq_is_ascending;
+
+  // number of spilled nodes
+  int m_spill_count;
+
+  /** pointer to the owning sequencer */
+  pseq_t       *m_pseq;
+};
+ 
+
+
+
+/*------------------------------------------------------------------------*/
+/* Global variables                                                       */
+/*------------------------------------------------------------------------*/
+
+/*------------------------------------------------------------------------*/
+/* Global functions                                                       */
+/*------------------------------------------------------------------------*/
+
+#endif /* _HWPQ_H_ */
diff -X dontdiff -uprN gems-2.1.1/opal/system/iwindow.C gems-2.1.1-hwpq-head2/opal/system/iwindow.C
--- gems-2.1.1/opal/system/iwindow.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/iwindow.C	2012-03-01 11:48:30.000000000 -0500
@@ -232,6 +232,24 @@ dynamic_inst_t *iwindow_t::retireInstruc
   }
   */
 
+  // GAB: Hack to ensure in-order execution (and forward progress) for hwpq instructions
+  if (dinst && dinst->getStaticInst()->getType() == DYN_HWPQ) {
+    // if not already in order, then set in order (and schedule).
+    // if in order is already set, then instruction has already 
+    // been scheduled / executed, so fall through
+    if (!(static_cast<hwpq_inst_t *> (dinst))->isInOrder()) {
+      (static_cast<hwpq_inst_t *> (dinst))->setInOrder();
+      if (!dinst->Waiting()) {
+        if ( dinst->getStage() == dinst->FETCH_STAGE ) {
+          // FIXME
+          dinst->Decode( system_t::inst->m_seq[0]->getLocalCycle() );
+        } else {
+          dinst->Schedule();
+        }
+      }
+    }
+  }
+
   if (dinst && dinst->isRetireReady()) {
     m_last_retired = nextslot;
     m_window[m_last_retired] = NULL;
diff -X dontdiff -uprN gems-2.1.1/opal/system/ix.i gems-2.1.1-hwpq-head2/opal/system/ix.i
--- gems-2.1.1/opal/system/ix.i	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/ix.i	2012-03-01 11:48:30.000000000 -0500
@@ -3426,6 +3426,7 @@ DX_RETURNT dx_impdep1( DX_PLIST ) {
 }
 
 DX_RETURNT dx_impdep2( DX_PLIST ) {
+  DEBUG_OUT("ix:dx_impdep2\n");
 }
 
 DX_RETURNT dx_membar( DX_PLIST ) {
diff -X dontdiff -uprN gems-2.1.1/opal/system/memop.C gems-2.1.1-hwpq-head2/opal/system/memop.C
--- gems-2.1.1/opal/system/memop.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/memop.C	2012-03-01 11:48:30.000000000 -0500
@@ -1049,7 +1049,7 @@ load_inst_t::accessCache( void ) {
       SetStage(CACHE_NOTREADY_STAGE);
 
       #ifdef DEBUG_DYNAMIC
-        char buf[128];
+        //char buf[128];
         s->printDisassemble(buf);
         DEBUG_OUT("load_inst_t::accessCache CACHE_NOTREADY_STAGE %s cycle[ %lld ] proc[ %d] seqnum[ %lld mshr_hit[ %d ]]\n", buf, m_pseq->getLocalCycle(), m_proc, seq_num, mshr_hit);
         rcache->print();
diff -X dontdiff -uprN gems-2.1.1/opal/system/mshr.C gems-2.1.1-hwpq-head2/opal/system/mshr.C
--- gems-2.1.1/opal/system/mshr.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/mshr.C	2012-03-01 11:48:30.000000000 -0500
@@ -553,20 +553,18 @@ mshr_t::mshr_t(const char *n, generic_ca
     m_streams = NULL;
   }
 
-  /* initialize stats to zeros */
-  m_num_active = m_num_queued = m_primary = m_secondary = 0;
-
-  m_prefetch_prefetch  = 0;
-  m_stream_prefetches  = 0;
-  m_partial_prefetches = 0;
-  m_prefetch_hits      = 0;
-  m_victim_hits        = 0;
 
   // init histogram
   m_hist_active = (uint64 *) malloc( sizeof(uint64) * m_max_misses );
+  assert(m_hist_active);
+  
+
+  m_num_active = m_num_queued = m_primary = m_secondary = 0;
   for ( uint32 i = 0; i < m_max_misses; i++ ) {
     m_hist_active[i] = 0;
   }
+  /* initialize stats to zeros */
+  resetStats();
 }
 
 //**************************************************************************
@@ -1061,6 +1059,19 @@ mshr_t::RecentFetch(pa_t block_address) 
 
 //**************************************************************************
 void
+mshr_t::resetStats( )
+{
+
+  m_prefetch_prefetch  = 0;
+  m_stream_prefetches  = 0;
+  m_partial_prefetches = 0;
+  m_prefetch_hits      = 0;
+  m_victim_hits        = 0;
+
+}
+
+//**************************************************************************
+void
 mshr_t::printStats( pseq_t *pseq )
 {
   uint64 total = 0;
diff -X dontdiff -uprN gems-2.1.1/opal/system/mshr.h gems-2.1.1-hwpq-head2/opal/system/mshr.h
--- gems-2.1.1/opal/system/mshr.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/mshr.h	2012-03-01 11:48:30.000000000 -0500
@@ -363,6 +363,9 @@ public:
   /// tick and object
   virtual void Tick();
 
+  /// reset stats
+  virtual void resetStats( void );
+
   /// print MSHR stats
   virtual void printStats( pseq_t *pseq );
   //@}
diff -X dontdiff -uprN gems-2.1.1/opal/system/pseq.C gems-2.1.1-hwpq-head2/opal/system/pseq.C
--- gems-2.1.1/opal/system/pseq.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/pseq.C	2012-03-12 12:32:29.000000000 -0400
@@ -101,6 +101,8 @@
 #include "ptrace.h"
 #include "Vector.h"    
 
+#include "hwpq.h"
+
 #include "pseq.h"
 
 /*------------------------------------------------------------------------*/
@@ -196,7 +198,13 @@ pseq_t::pseq_t( int32 id )
   l1_inst_cache         = NULL;
   l1_data_cache         = NULL;
   m_ruby_cache          = NULL;
-  
+ 
+  // GAB: HWPQ
+  hl1_mshr              = NULL;
+  l1_hwds_cache         = NULL;
+  m_hwpq                = NULL;
+  m_hwpq_count          = 0;
+ 
  /* WATTCH power */
   m_power_stats = NULL;
   if(WATTCH_POWER){
@@ -424,6 +432,10 @@ pseq_t::pseq_t( int32 id )
                           DL1_BLOCK_BITS, L2_LATENCY, L1_FILL_BUS_CYCLES,
                           DL1_MSHR_ENTRIES, DL1_STREAM_BUFFERS);
     
+    hl1_mshr = new mshr_t("HL1.mshr", l2_cache, m_scheduler,
+                          HL1_BLOCK_BITS, L2_LATENCY, L1_FILL_BUS_CYCLES,
+                          HL1_MSHR_ENTRIES, HL1_STREAM_BUFFERS);
+    
     /* first level instruction caches */  
     l1_inst_cache = new generic_cache_template<generic_cache_block_t>(
                       "L1.inst", il1_mshr, m_scheduler, IL1_SET_BITS,
@@ -433,6 +445,11 @@ pseq_t::pseq_t( int32 id )
     l1_data_cache = new generic_cache_template<generic_cache_block_t>(
                       "L1.data", dl1_mshr, m_scheduler, DL1_SET_BITS,
                       DL1_ASSOC, DL1_BLOCK_BITS, (DL1_IDEAL != 0) );
+
+    /* first level hwds caches */  
+    l1_hwds_cache = new generic_cache_template<generic_cache_block_t>(
+                      "L1.hwds", hl1_mshr, m_scheduler, HL1_SET_BITS,
+                      HL1_ASSOC, HL1_BLOCK_BITS, (HL1_IDEAL != 0) );
   } else {
     /* CONFIG_WITH_RUBY  */
     m_ruby_cache = new rubycache_t( m_id, L2_BLOCK_BITS, m_scheduler );
@@ -440,6 +457,9 @@ pseq_t::pseq_t( int32 id )
     m_write_buffer = new writebuffer_t( m_id, L2_BLOCK_BITS, m_scheduler );
   }
 
+  m_hwpq_count = CONFIG_NUM_HWPQS;
+  m_hwpq = new hwpq_t[CONFIG_NUM_HWPQS];
+
   // set MMU related fields
   m_primary_ctx = new context_id_t[CONFIG_LOGICAL_PER_PHY_PROC];
   m_itlb_physical_address = new pa_t[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -614,6 +634,7 @@ pseq_t::pseq_t( int32 id )
   ASSERT( m_arch_bpred->ras_state.TOS      == 0 );
   ASSERT( m_arch_bpred->ras_state.next_free == 1 );
 
+  reset_stats = false;
   #ifdef DEBUG_PSEQ
   DEBUG_OUT("pseq_t:constructor END\n");
   #endif
@@ -777,7 +798,17 @@ pseq_t::~pseq_t() {
     delete dl1_mshr;
   if (l2_mshr)
     delete l2_mshr;
-  
+ 
+  // GAB
+  // free the hwds
+  if (l1_hwds_cache)
+    delete l1_hwds_cache;
+  if (hl1_mshr)
+    delete hl1_mshr;
+
+  if (m_hwpq)
+    delete [] m_hwpq;
+
   for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){
     if(m_imap[k])
       delete m_imap[k];
@@ -984,6 +1015,8 @@ pseq_t::~pseq_t() {
 
   if(m_stat_trace_insn)
     delete [] m_stat_trace_insn;
+  if(m_stat_cycles)
+    delete [] m_stat_cycles;
   if(m_stat_committed)
     delete [] m_stat_committed;
   if(m_stat_total_squash)
@@ -1019,6 +1052,8 @@ pseq_t::~pseq_t() {
     delete [] m_stat_prefetches_retired;
   if(m_stat_control_retired)
     delete [] m_stat_control_retired;
+  if(m_stat_hwds_retired)
+    delete [] m_stat_hwds_retired;
 
   if(m_stat_fetched)
     delete [] m_stat_fetched;
@@ -1039,6 +1074,26 @@ pseq_t::~pseq_t() {
     delete [] m_stat_prefetches_exec;
   if(m_stat_control_exec)
     delete [] m_stat_control_exec;
+  if(m_stat_hwds_exec)
+    delete [] m_stat_hwds_exec;
+  if(m_stat_hwds_extract_exec)
+    delete [] m_stat_hwds_extract_exec;
+  if(m_stat_hwds_extract_last_exec)
+    delete [] m_stat_hwds_extract_last_exec;
+  if(m_stat_hwds_insert_exec)
+    delete [] m_stat_hwds_insert_exec;
+  if(m_stat_hwds_first_exec)
+    delete [] m_stat_hwds_first_exec;
+  if(m_stat_hwds_last_exec)
+    delete [] m_stat_hwds_last_exec;
+  if(m_stat_hwds_spill_exec)
+    delete [] m_stat_hwds_spill_exec;
+  if(m_stat_hwds_fill_exec)
+    delete [] m_stat_hwds_fill_exec;
+  if(m_stat_hwds_get_context_exec)
+    delete [] m_stat_hwds_get_context_exec;
+  if(m_stat_hwds_adjust_spill_count_exec)
+    delete [] m_stat_hwds_adjust_spill_count_exec;
 
   if(m_stat_loads_found)
     delete [] m_stat_loads_found;
@@ -1288,7 +1343,9 @@ void pseq_t::advanceCycle( void )
   }
 #endif
 
-  // I. Fetch instructions
+  /* retire iwindow if stats are reset */
+
+   // I. Fetch instructions
   fetchInstruction();
 
   // II. Decode instructions in the pipe
@@ -1333,8 +1390,21 @@ void pseq_t::advanceCycle( void )
     // then tick L1
     il1_mshr->Tick();
     dl1_mshr->Tick();
+    hl1_mshr->Tick();
   }
 
+#if 0
+  if ( reset_stats ) {
+    DEBUG_OUT("Reset statistics at cycle: %lld\n",m_local_cycles);
+    DEBUG_OUT("Only resetting m_stat_cycles\n");
+    out_info("reset number of cycles %lld\n", m_stat_cycles[0]);
+    m_stat_cycles[0] = 0;
+//    resetStats();
+    reset_stats = false;
+  }
+/* FIXME: need to reset stats but avoid blocking resources that are scheduled to fire. not sure what to do :( */
+#endif
+
   // advance local time one cycle (do this only after all threads have finished going through pipeline)
   localCycleIncrement();               
 
@@ -1371,7 +1441,7 @@ void pseq_t::fetchInstruction( )
 //**************************************************************************
 void pseq_t::fetchInstrSimple( )
 {
- #ifdef DEBUG_PSEQ
+ #ifdef DEBUG_FETCH
           DEBUG_OUT("pseq_t:fetchInstrSimple BEGIN cycle[ %d ]\n",getLocalCycle());
   #endif
 
@@ -1394,7 +1464,7 @@ void pseq_t::fetchInstrSimple( )
     for(uint proc=0; (proc <  CONFIG_LOGICAL_PER_PHY_PROC); ++proc){
       timeout++;
 
-        #ifdef DEBUG_PSEQ
+        #ifdef DEBUG_FETCH
           DEBUG_OUT("pseq_t:fetchInstrSimple BEGIN proc[%d] cycle %d\n",proc, getLocalCycle());
           printPC(m_fetch_at[proc]);
          #endif
@@ -1428,7 +1498,7 @@ void pseq_t::fetchInstrSimple( )
          if (DEBUG_SIMPLE_FE) DEBUG_OUT("fetch is not ready: %s\n", fetch_menomic(m_fetch_status[proc]));
          ASSERT( m_fetch_status[proc] < PSEQ_FETCH_MAX_STATUS );
 
-        #ifdef DEBUG_PSEQ
+        #ifdef DEBUG_FETCH
             DEBUG_OUT("\tfetch not ready, status = %s cycle[ %lld ]\n", fetch_menomic(m_fetch_status[proc]), m_local_cycles);
          #endif
          //set this logical proc's done flag to true:
@@ -1470,7 +1540,7 @@ void pseq_t::fetchInstrSimple( )
                    m_fetch_status[proc] = PSEQ_FETCH_ITLBMISS;
                    done[proc] = true;
            } else {        
-              #ifdef DEBUG_PSEQ
+              #ifdef DEBUG_FETCH
                  //DEBUG_OUT("\tITLB hit, now access cache...\n");
               #endif
     
@@ -1527,11 +1597,11 @@ void pseq_t::fetchInstrSimple( )
              *  This include the case where pc1 == pc2, when last fetch was
              *  a miss and it is then fetched again after woken up.
              */
-           #ifdef DEBUG_PSEQ
+           #ifdef DEBUG_FETCH
                DEBUG_OUT("\tWe hit in the L1-Icache!\n");
            #endif
              if(! l1_inst_cache->same_line(m_last_fetch_physical_address[proc], fetchPhysicalPC)) {
-                  #ifdef DEBUG_PSEQ
+                  #ifdef DEBUG_FETCH
                      DEBUG_OUT("\tUpdating our line buffer...\n");
                    #endif
                      // Modified to take in the logical proc's waiter object:
@@ -1542,7 +1612,7 @@ void pseq_t::fetchInstrSimple( )
                  getPowerStats()->incrementICacheAccess();
                }
 
-                #ifdef DEBUG_PSEQ
+                #ifdef DEBUG_FETCH
                      DEBUG_OUT("\tAfter reading L1Icache, hit[%d]..\n",hit);
                    #endif
                m_last_fetch_physical_address[proc] = fetchPhysicalPC;             //update our line buffer for the new instr addr being read out
@@ -1572,7 +1642,7 @@ void pseq_t::fetchInstrSimple( )
         } // ! ruby cache
      } // !tlbmiss
 
-     #ifdef DEBUG_PSEQ
+     #ifdef DEBUG_FETCH
         DEBUG_OUT("\tAbout to assign old_pc...\n");
       #endif
 
@@ -1602,13 +1672,13 @@ void pseq_t::fetchInstrSimple( )
         getPowerStats()->incrementWindowAccess();
       }
 
-      #ifdef DEBUG_PSEQ
+      #ifdef DEBUG_FETCH
             DEBUG_OUT("\tAfter insertInstruction\n");
        #endif  
       // if this is a barrier-type instruction, stall fetch
       // Need to stall for correctness for ITLB and DTLB - the stxa instruction
       if  (s_instr->getFlag( SI_FETCH_BARRIER )) {
-            #ifdef DEBUG_PSEQ
+            #ifdef DEBUG_FETCH
              //DEBUG_OUT("\tInstruction fetched is a BARRIER...stall fetch!!\n");
             #endif
 
@@ -1651,7 +1721,7 @@ void pseq_t::fetchInstrSimple( )
         *  these instructions become ready in FETCH_STAGES cycles
         */
        
-#ifdef DEBUG_PSEQ
+#ifdef DEBUG_FETCH
          DEBUG_OUT("\tinserting %d instrs to be decoded at cycle[%d] proc[%d] fetch_status[ %s ]\n",num_fetched[proc],
                          getLocalCycle()+FETCH_STAGES,proc, fetch_menomic(m_fetch_status[proc]));
 #endif
@@ -1671,7 +1741,7 @@ void pseq_t::fetchInstrSimple( )
        }
       m_icount[proc] = m_iwin[proc].getNumSlotsTaken();                    //set m_icount for this thread
        
-   #ifdef DEBUG_PSEQ
+   #ifdef DEBUG_FETCH
      printPC(m_fetch_at[proc]);
      DEBUG_OUT("pseq_t:fetchinstrSimple END m_id[%d] proc[%d] cycle[%d]\n",m_id, proc,getLocalCycle());
    #endif
@@ -1701,7 +1771,7 @@ void pseq_t::fetchInstrSimple( )
 
   } //end for all logical procs
        
-#ifdef DEBUG_PSEQ
+#ifdef DEBUG_FETCH
   //out_info("num fetched PC 0x%0llx NPC 0x%0llx %d\n",
   //       m_fetch_at[proc]->pc, m_fetch_at[proc]->npc, num_fetched);
 #endif
@@ -1710,7 +1780,7 @@ void pseq_t::fetchInstrSimple( )
  // record the SMT fetch histogram 
  m_hist_smt_fetch_per_cycle[num_threads_fetched]++;
 
-  #ifdef DEBUG_PSEQ
+  #ifdef DEBUG_FETCH
      DEBUG_OUT("pseq_t:fetchinstrSimple END m_id[%d] cycle[ %d ]\n",m_id, getLocalCycle());
    #endif
 
@@ -2060,6 +2130,16 @@ dynamic_inst_t* pseq_t::createInstructio
        #endif
       break;
 
+    case DYN_HWPQ:
+      #ifdef DEBUG_PSEQ
+        DEBUG_OUT("\tDYN_HWPQ type proc[%d]\n",proc);
+      #endif
+      d_instr = new hwpq_inst_t(s_instr, index, this, fetch_at, physicalPC,  m_last_traptype[proc][m_last_traplevel[proc]], proc);
+      #ifdef DEBUG_PSEQ
+        DEBUG_OUT("\tDYN_HWPQ creation success proc[%d]\n",proc);
+      #endif
+    break;
+
     default:
       ERROR_OUT("error: unimplemented instruction type %d\n", 
                 (int) s_instr->getType());
@@ -2103,7 +2183,7 @@ dynamic_inst_t* pseq_t::createInstructio
 //**************************************************************************
 void pseq_t::decodeInstruction( )
 {
-  #ifdef DEBUG_PSEQ
+  #ifdef DEBUG_DECODE
      DEBUG_OUT("pseq_t:decodeInstruction BEGIN m_id[%d] cycle[ %d ]\n",m_id,getLocalCycle());
      //printPC(&m_ooo.at[proc]);
   #endif
@@ -2127,14 +2207,14 @@ void pseq_t::decodeInstruction( )
 
       timeout++;
 
-      #ifdef DEBUG_PSEQ
+      #ifdef DEBUG_DECODE
          DEBUG_OUT("pseq_t:decodeInstruction BEGIN m_id[%d] proc[%d] cycle %d\n",m_id,proc,getLocalCycle());
          DEBUG_OUT("\ttotal_decoded[%d]\n",total_decoded); 
          //printPC(&m_ooo.at[proc]);
          printPC(m_fetch_at[proc]);
       #endif
 
-#ifdef DEBUG_PSEQ
+#ifdef DEBUG_DECODE
    DEBUG_OUT( "\tDecoding...%d instructions available proc[%d]\n", decode_remaining[proc],proc);
 #endif
    uint32 decoded_this_cycle = 0;
@@ -2161,7 +2241,7 @@ void pseq_t::decodeInstruction( )
      STAT_INC(m_stat_not_enough_registers[proc]);
    }
    
-   #ifdef DEBUG_PSEQ
+   #ifdef DEBUG_DECODE
     DEBUG_OUT("\tTotal decoded = %d\n",total_decoded);
     DEBUG_OUT("\tDecode remaining[%d] = %d\n",proc, decode_remaining[proc]);
    #endif
@@ -2174,7 +2254,7 @@ void pseq_t::decodeInstruction( )
   for(uint proc=0; proc <  CONFIG_LOGICAL_PER_PHY_PROC; ++proc){
     ASSERT(num_decoded[proc] + decode_remaining[proc] == decode_avail[proc]);
     if (num_decoded[proc] < decode_avail[proc]) {
-         #ifdef DEBUG_PSEQ
+         #ifdef DEBUG_DECODE
            DEBUG_OUT("\tthere are leftover instrs avail[%d] decoded[%d] leftover[%d] proc[%d] cycle %d\n", 
           decode_avail[proc], num_decoded[proc], decode_avail[proc]-num_decoded[proc], proc,getLocalCycle());
          #endif
@@ -2187,7 +2267,7 @@ void pseq_t::decodeInstruction( )
           * add leftover number up to that
           */
         uint32 numfetched = m_fetch_per_cycle[proc].peekItem( getLocalCycle(), 1 );
-        #ifdef DEBUG_PSEQ
+        #ifdef DEBUG_DECODE
             DEBUG_OUT("\tinserting leftovers leftovers[%d] proc[%d] in cycle[%d]\n",
                            numfetched+leftover, proc,getLocalCycle()+1);
          #endif
@@ -2208,14 +2288,14 @@ void pseq_t::decodeInstruction( )
     m_hist_decode_per_thread[proc][num_decoded[proc]]++;
 
     // insert the number of instructions not decoded this cycle to next cycle
-    #ifdef DEBUG_PSEQ
+    #ifdef DEBUG_DECODE
         DEBUG_OUT("\tdecode: adding %d instructions to be scheduled at cycle %d\n",num_decoded[proc],
                             getLocalCycle()+DECODE_STAGES);
     #endif
     m_decode_per_cycle[proc].insertItem( getLocalCycle(), DECODE_STAGES,
                                              num_decoded[proc] );
 
-#ifdef DEBUG_PSEQ
+#ifdef DEBUG_DECODE
    DEBUG_OUT("num decoded %d\n", num_decoded[proc]);
 #endif
 
@@ -2224,7 +2304,7 @@ void pseq_t::decodeInstruction( )
   //update per-core decode histogram:
   m_hist_decode_per_cycle[total_decoded]++;
 
- #ifdef DEBUG_PSEQ
+ #ifdef DEBUG_DECODE
   //printPC(&m_ooo.at[proc]);
   DEBUG_OUT("pseq_t:decodeInstruction END m_id[%d] cycle[ %d ]\n",m_id,getLocalCycle());
  #endif
@@ -2243,7 +2323,7 @@ void pseq_t::decodeInstruction( )
 //**************************************************************************
 void pseq_t::scheduleInstruction( )
 {
-  #ifdef DEBUG_PSEQ
+  #ifdef DEBUG_SCHEDULE
     DEBUG_OUT("pseq_t:scheduleInstruction BEGIN m_id[%d] cycle[ %lld ]\n",m_id,m_local_cycles);
     //printPC(&m_ooo.at[proc]);
    #endif
@@ -2268,13 +2348,13 @@ void pseq_t::scheduleInstruction( )
 
       timeout++;
 
-        #ifdef DEBUG_PSEQ
+        #ifdef DEBUG_SCHEDULE
            DEBUG_OUT("pseq_t:scheduleInstruction BEGIN m_id[%d] proc[%d] cycle[ %lld ]\n",m_id,proc, m_local_cycles);
            //printPC(&m_ooo.at[proc]);
            printPC(m_fetch_at[proc]);
        #endif
 
-#ifdef DEBUG_PSEQ  
+#ifdef DEBUG_SCHEDULE  
      DEBUG_OUT("scheduling ...%d  instructions available\n", schedule_avail[proc]);
 #endif
 
@@ -2338,7 +2418,7 @@ void pseq_t::scheduleInstruction( )
    ASSERT( num_scheduled[proc] <= MAX_DISPATCH );
    //ASSERT( total_scheduled <= MAX_DISPATCH*CONFIG_LOGICAL_PER_PHY_PROC);
   
-#ifdef DEBUG_PSEQ
+#ifdef DEBUG_SCHEDULE
     DEBUG_OUT("num scheduled %d\n", num_scheduled[proc]);
 #endif
 
@@ -2349,7 +2429,7 @@ void pseq_t::scheduleInstruction( )
  //record per-core schedule histogram:
  m_hist_schedule_per_cycle[total_scheduled]++;
 
- #ifdef DEBUG_PSEQ
+ #ifdef DEBUG_SCHEDULE
        //printPC(&m_ooo.at[proc]);
         DEBUG_OUT("pseq_t:scheduleInstruction END m_id[%d] cycle[ %lld ]\n",m_id, m_local_cycles);
   #endif
@@ -2507,9 +2587,9 @@ void pseq_t::retireInstruction( )
         //print out memory instructions
         DEBUG_OUT("%s seqnum[ %d ] VPC[ 0x%llx ] PC[ 0x%llx ] virtual_addr[ 0x%llx ] physical_addr[ 0x%llx ] lineaddr[ 0x%llx ] iscacheable[ %d ]", buf,d->getSequenceNumber(), d->getVPC(), d->getPC(), (static_cast<memory_inst_t *>(d)->getAddress()), static_cast<memory_inst_t *>(d)->getPhysicalAddress(), ((static_cast<memory_inst_t *> (d)->getPhysicalAddress()) & ~( (1 << 6) - 1) ), static_cast<memory_inst_t *>(d)->isCacheable() );
         //print out ASI, if this instruction is not NAV
-        if(d->getInstrNAV() == false){
-          DEBUG_OUT(" ASI[ 0x%x ]", static_cast<memory_inst_t *>(d)->getASI());
-        }
+        //if(d->getInstrNAV() == false){
+        //  DEBUG_OUT(" ASI[ 0x%x ]", static_cast<memory_inst_t *>(d)->getASI());
+        //}
         //print out data
         int access_size_8bytes = ( (static_cast<memory_inst_t *>(d)->getAccessSize()) + 7)/8;
         DEBUG_OUT(" Data (%d bytes) [ ", static_cast<memory_inst_t *>(d)->getAccessSize());
@@ -2538,16 +2618,16 @@ void pseq_t::retireInstruction( )
       DEBUG_OUT(" SOURCES: ");
       for(int i=0; i < SI_MAX_SOURCE; ++i){
         reg_id_t & source = d->getSourceReg(i);
-        if(!source.isZero()){
-          DEBUG_OUT("( [%d] V: %d P: %d Arf: %s NAV: %d )", i,source.getVanilla(), source.getPhysical(), source.rid_type_menomic( source.getRtype() ), source.getARF()->getNAV(source, d->getProc()) );
-        }
+        //if(!source.isZero()){
+          //DEBUG_OUT("( [%d] V: %d P: %d Arf: %s NAV: %d )", i,source.getVanilla(), source.getPhysical(), source.rid_type_menomic( source.getRtype() ), source.getARF()->getNAV(source, d->getProc()) );
+        //}
       }
       DEBUG_OUT(" DESTS: ");
       for(int i=0; i < SI_MAX_DEST; ++i){
         reg_id_t & dest = d->getDestReg(i);
-        if(!dest.isZero()){
-          DEBUG_OUT("( [%d] V: %d P: %d Arf: %s NAV: %d )", i,dest.getVanilla(), dest.getPhysical(), dest.rid_type_menomic( dest.getRtype() ), dest.getARF()->getNAV(dest, d->getProc()) );
-        }
+        //if(!dest.isZero()){
+          //DEBUG_OUT("( [%d] V: %d P: %d Arf: %s NAV: %d )", i,dest.getVanilla(), dest.getPhysical(), dest.rid_type_menomic( dest.getRtype() ), dest.getARF()->getNAV(dest, d->getProc()) );
+        //}
       }
       DEBUG_OUT("\n");
       //print out TL, CWP, GSET, PSTATE
@@ -6622,121 +6702,421 @@ void pseq_t::printDebug(){
 }
 
 //***************************************************************************
-void pseq_t::printStats( void )
+void pseq_t::resetStats( void )
 {
+  //WATTCH power: bank num stats
+  for(int i=0; i < 8; ++i){
+    m_l1i_banknum_accesses[i] = 0;
+    m_l1d_banknum_accesses[i] = 0;
+  }
+  for(int i=0; i < 9; ++i){
+    m_l1i_8bank_histogram[i] = 0;
+    m_l1d_8bank_histogram[i] = 0;
+  }
+  for(int i=0; i < 5; ++i){
+    m_l1i_4bank_histogram[i] = 0;
+    m_l1d_4bank_histogram[i] = 0;
+  }
+  for(int i=0; i < 3; ++i){
+    m_l1i_2bank_histogram[i] = 0;
+    m_l1d_2bank_histogram[i] = 0;
+  }
 
-  #ifdef DEBUG_PSEQ
-    DEBUG_OUT("pseq_t:printStats BEGIN\n");
-  #endif
+  for(uint32 proc=0; proc < CONFIG_LOGICAL_PER_PHY_PROC; ++proc){
+    for (int i = 0; i < TRAP_NUM_TRAP_TYPES; i ++) {
+      m_trapstat[proc][i] = 0;
+      m_simtrapstat[proc][i] = 0;
+      m_completed_trapstat[proc][i] = 0;
+    }
+    for(int i=0; i < MAX_SOFTWARE_TRAPS; ++i){
+      m_software_trapstat[proc][i] = 0;
+    }
 
-  // temporarily stop debug filtering-- you asked for the stats right?
-  uint64 filterTime = getDebugTime();
-  setDebugTime( 0 );
+    m_stat_exceed_scheduling_window[proc] = 0;
+    m_stat_not_enough_registers[proc] = 0;
+    m_icount_stats[proc].icount_sum = 0;
+    m_icount_stats[proc].num_samples = 0;
+    m_icount_stats[proc].max_icount = 0;
 
-   char   user_mode = '?';
-   char   buf[80], buf1[80], buf2[80], buf3[80], buf4[80], buf5[80], buf6[80], buf7[80], buf8[80], buf9[80];
-   double total_pct = 0.0;
-   uint64 total_ideal_coverage = 0;
+    m_ifetch_miss_latency[proc].num_misses = 0;
+    m_ifetch_miss_latency[proc].latency_sum =0;
+    m_ifetch_miss_latency[proc].num_fastpath = 0;
+    m_load_miss_latency[proc].num_misses = 0;
+    m_load_miss_latency[proc].latency_sum =0;
+    m_load_miss_latency[proc].num_fastpath = 0;
+    m_store_miss_latency[proc].num_misses = 0;
+    m_store_miss_latency[proc].latency_sum =0;
+    m_store_miss_latency[proc].num_fastpath = 0;
+    m_atomic_miss_latency[proc].num_misses = 0;
+    m_atomic_miss_latency[proc].latency_sum =0;
+    m_atomic_miss_latency[proc].num_fastpath = 0;
+  }
 
- for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
-   if (m_stat_committed[k] > 0) {  
-     out_info("*** Opcode stats [logical proc %d]:\n",k);
-     m_opstat[k].print( this );
-     out_info("\n");
-   }
+  for (uint32 i = 0; i < MAX_NUM_ASI; i ++) {
+    m_asi_rd_stat[i] = 0;
+    m_asi_wr_stat[i] = 0;
+    m_asi_at_stat[i] = 0;
+  }
 
-   if (m_ideal_retire_count[k] > 0) {
-     out_info("*** Ideal opcode stats [logical proc %d]:\n",k);
-    m_ideal_opstat[k].print( this );
-    out_info("\n");
-    out_info("Ideal predictor rating:\n");
-    for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
-      total_ideal_coverage += m_hist_ideal_coverage[i];
+  for (uint32 i = 0; i < MAX_FETCH + 1; i++) {
+    m_hist_fetch_per_cycle[i] = 0;
+  }
+
+  for(uint32 j=0; j < CONFIG_LOGICAL_PER_PHY_PROC; ++j){
+    for (uint32 i = 0; i < MAX_FETCH + 1; i++) {
+      m_hist_fetch_per_thread[j][i] = 0;
     }
-    for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
-      if (total_ideal_coverage == 0)
-        total_pct = 0.0;
-      else
-        total_pct = ((double) m_hist_ideal_coverage[i] / (double) total_ideal_coverage)
-          *100.0;
-      out_info("%-20.20s: %24.24s %6.2lf%%\n",
-               fetch_menomic( (pseq_fetch_status_t) i ),
-               commafmt(m_hist_ideal_coverage[i], buf, 80),
-               total_pct);
+    for (uint32 i = 0; i < MAX_DECODE + 1; i++) {
+      m_hist_decode_per_thread[j][i] = 0;
+    }
+    for (uint32 i = 0; i < MAX_DISPATCH + 1; i++) {
+      m_hist_schedule_per_thread[j][i] = 0;
+    }
+    for (uint32 i = 0; i < MAX_RETIRE + 1; i++) {
+      m_hist_retire_per_thread[j][i] = 0;
     }
-    out_info("\n");
   }
-   out_info("\n");
 
-  out_info("*** Trap   stats [logical proc: %d]:\n",k);
-  out_info("  [Trap#]  Times-Taken Times-Complete Simics-Taken    Name\n");
-  for (int i = 0; i < TRAP_NUM_TRAP_TYPES; i ++) {
-    if ( m_trapstat[k][i] != 0 || m_simtrapstat[k][i] != 0) {
-      out_info("  [%3d] %14lld  %14lld %14lld  %s\n", i, m_trapstat[k][i], m_completed_trapstat[k][i], m_simtrapstat[k][i],
-               pstate_t::trap_num_menomic( (trap_type_t) i ));
+  for (uint32 i = 0; i < m_threads_per_cycle + 1; i++) {
+    m_hist_smt_fetch_per_cycle[i] = 0;
+  }
+  for (uint32 i = 0; i < MAX_DECODE + 1; i++) {
+    m_hist_decode_per_cycle[i] = 0;
+  }
+  for (uint32 i = 0; i < MAX_DISPATCH + 1; i++) {
+    m_hist_schedule_per_cycle[i] = 0;
+  }
+  for (uint32 i = 0; i < MAX_RETIRE + 1; i++) {
+    m_hist_retire_per_cycle[i] = 0;
+  }
+  for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
+    m_hist_fetch_stalls[i] = 0;
+  }
+  for (uint32 i = 0; i < PSEQ_RETIRE_MAX_STATUS; i++) {
+    m_hist_retire_stalls[i] = 0;
+  }
+  for (uint32 i = 0; i < dynamic_inst_t::MAX_INST_STAGE; i++) {
+    for (int32 j = 0; j < IWINDOW_ROB_SIZE; j++) {
+      m_hist_squash_stage[i][j] = 0;
     }
   }
 
-  #if 0
-  //now output software initiated traps (using tcc instr)
-  for(int i=0; i < MAX_SOFTWARE_TRAPS; ++i){
-    if(m_software_trapstat[k][i] != 0){
-      out_info("  [%3d] %14lld %14lld  Software_Trap_%d\n", i+256, m_software_trapstat[k][i], 0, i+256);
-    }
+  for(int i=0; i < dynamic_inst_t::MAX_INST_STAGE; ++i){
+    m_stat_retire_notready_stage[i] = 0;
+  }
+  for (int32 i = 0; i < PSEQ_HIST_DECODE; i++) {
+    m_hist_decode_return[i] = 0;
+  }
+  for (uint32 i = 0; i < PSEQ_MAX_FF_LENGTH; i++) {
+    m_hist_ff_length[i] = 0;
+  }
+  for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
+    m_hist_ideal_coverage[i] = 0;
   }
-  #endif
-  
- }   //end for loop over all logical procs  
 
- out_info("\n");
+  m_stat_no_fetch_taken_branch = 0;
+  m_stat_no_fetch_across_lines = 0;
 
- for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
-   out_info("*** Internal exception stats [logical proc %d]:\n",k);
-   out_info("###: seen    name\n");
-   for (int i = 0; i < EXCEPT_NUM_EXCEPT_TYPES; i ++) {
-     if ( m_exception_stat[k][i] != 0 ) {
-       out_info("  [%3d] %14lld  %s\n", i, m_exception_stat[k][i],
-                pstate_t::async_exception_menomic( (exception_t) i ));
-     }
-   }
-   out_info("\n");
- }  //end for loop over all logical procs
-    
-  out_info("*** ASI    stats:\n");
-  out_info("  ASI     Reads   Writes  Atomics\n");
-  for (uint32 i = 0; i < MAX_NUM_ASI; i ++) {
-    if ( m_asi_rd_stat[i] != 0 ||
-         m_asi_wr_stat[i] != 0 ||
-         m_asi_at_stat[i] != 0 ) {
-      out_info("  0x%02x %8lld %8lld %8lld\n", 
-               i, m_asi_rd_stat[i], m_asi_wr_stat[i], m_asi_at_stat[i] );
-    }
+  for (uint32 i = 0; i < FU_NUM_FU_TYPES; i++) {
+    m_stat_fu_utilization[i] = 0;
+    m_stat_fu_stall[i] = 0;
   }
 
-  out_info("\n");
+  for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
+    for (uint32 i = 0; i < FU_NUM_FU_TYPES; i++) {
+      m_stat_fu_util_retired[k][i] = 0;
+    }
+  }
 
-  uint64 total_pred = 0;
-  uint64 total_seen = 0;
-  uint64 total_right = 0;
-  uint64 total_wrong = 0;
-  double bpaccuracy;
-  out_info("*** Branch   stats: (user, kernel, total)\n");
-  out_info("  Type           Preds      Retired        Right       Wrong       %%Right\n");
   for (uint32 i = 0; i < BRANCH_NUM_BRANCH_TYPES; i++) {
     for (uint32 j = 0; j < TOTAL_INSTR_MODE; j++) {
+      m_branch_pred_stat[i][j]  = 0;
+      m_branch_seen_stat[i][j]  = 0;
+      m_branch_right_stat[i][j] = 0;
+      m_branch_wrong_stat[i][j] = 0;
+    }
+    m_branch_except_stat[i] = 0;
+  }
 
-      // get the mode string
-      switch (j) {
-      case 0:
-        user_mode = 'U';
-        break;
-      case 1:
-        user_mode = 'K';
-        break;
-      case 2:
-        user_mode = 'T';
-        break;
-      default:
+  m_stat_va_out_of_range = 0;
+
+  for(int i=0; i < MAX_NUM_ASI; ++i){
+    m_stat_uncacheable_read_asi[i] = 0;
+    m_stat_uncacheable_write_asi[i] = 0;
+    m_stat_uncacheable_atomic_asi[i] = 0;
+    m_stat_functional_read_asi[i] = 0;
+    m_stat_functional_write_asi[i] = 0;
+    m_stat_functional_atomic_asi[i] = 0;
+  }
+
+  for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){
+    m_exclude_count[k] = 0;
+    m_thread_count[k] = 0;
+    m_thread_count_idle[k] = 0;
+
+    m_stat_early_store_bypass[k] = 0;
+    //    m_branch_wrong_static_stat[k] = 0;
+    m_stat_count_badretire[k] = 0;
+    m_stat_count_functionalretire[k] = 0;
+    m_stat_count_retiresquash[k] = 0;
+
+    m_stat_trace_insn[k] = 0;
+    m_stat_cycles[k] = 0;
+    m_stat_committed[k] = 0;
+    m_stat_commit_squash[k] = 0;
+    m_stat_count_asistoresquash[k] = 0;
+    m_stat_commit_good[k] = 0;
+    m_stat_commit_bad[k] = 0;
+    m_stat_commit_unimplemented[k] = 0;
+    m_stat_count_except[k] = 0;
+    
+    m_stat_loads_retired[k] = 0;
+    m_stat_stores_retired[k] = 0;
+    m_stat_retired_stores_no_permission[k] = 0;
+    m_stat_retired_atomics_no_permission[k] = 0;
+    m_stat_retired_loads_no_permission[k] = 0;
+    m_stat_retired_loads_nomatch[k] = 0;
+    m_stat_atomics_retired[k] = 0;
+    m_stat_prefetches_retired[k] = 0;
+    m_stat_control_retired[k] = 0;
+    m_stat_hwds_retired[k] = 0;
+    m_stat_fetched[k] = 0;
+    m_stat_mini_itlb_misses[k] = 0;
+    m_stat_decoded[k] = 0;
+    m_stat_total_insts[k] = 0;
+
+    m_stat_loads_exec[k] = 0;
+    m_stat_stores_exec[k] = 0;
+    m_stat_atomics_exec[k] = 0;
+    m_stat_prefetches_exec[k] = 0;
+    m_stat_control_exec[k] = 0;
+    m_stat_hwds_exec[k] = 0;
+    m_stat_hwds_extract_exec[k] = 0;
+    m_stat_hwds_extract_last_exec[k] = 0;
+    m_stat_hwds_insert_exec[k] = 0;
+    m_stat_hwds_first_exec[k] = 0;
+    m_stat_hwds_last_exec[k] = 0;
+    m_stat_hwds_spill_exec[k] = 0;
+    m_stat_hwds_fill_exec[k] = 0;
+    m_stat_hwds_get_context_exec[k] = 0;
+    m_stat_hwds_adjust_spill_count_exec[k] = 0;
+
+    m_stat_loads_found[k] = 0;
+    m_stat_loads_notfound[k] = 0;
+    m_stat_total_squash[k] = 0;
+    m_stat_spill[k] = 0;
+    m_stat_fill[k] = 0;
+
+    //main memory stats
+    m_stat_miss_count[k] = 0;
+    m_stat_last_miss_seq[k] = 0;
+    m_stat_last_miss_fetch[k] = 0;
+    m_stat_last_miss_issue[k] = 0;
+    m_stat_last_miss_retire[k] = 0;
+
+    m_stat_miss_effective_ind[k] = 0;
+    m_stat_miss_effective_dep[k] = 0;
+    m_stat_miss_inter_cluster[k] = 0;
+    
+    // lsq stats 
+    m_stat_load_bypasses[k] = 0;
+    m_stat_atomic_bypasses[k] = 0;
+    m_stat_num_early_stores[k] = 0;
+    m_stat_num_early_store_bypasses[k] = 0;
+    m_stat_num_early_atomics[k] = 0;
+    m_stat_load_store_conflicts[k] = 0;
+    m_stat_load_incorrect_store[k] = 0;
+    m_stat_atomic_incorrect_store[k] = 0;
+    m_stat_stale_predictions[k] = 0;
+    m_stat_stale_success[k] = 0;
+    for (uint32 i = 0; i < (log_base_two(MEMOP_MAX_SIZE*8) + 1); i++) {  
+      m_stat_stale_histogram[k][i] = 0;
+    }
+    // StoreSet stats
+    m_stat_storeset_stall_load[k] = 0;
+    m_stat_storeset_stall_atomic[k] = 0;
+
+    // predictation statistics
+    m_pred_count_stat[k] = 0;
+    m_pred_count_taken_stat[k] = 0;
+    m_pred_count_nottaken_stat[k] = 0;
+    m_nonpred_count_stat[k] = 0;
+    m_pred_reg_count_stat[k] = 0;
+    m_pred_reg_taken_stat[k] = 0;
+    m_pred_reg_nottaken_stat[k] = 0;
+    
+    m_pred_retire_count_stat[k] = 0;
+    m_pred_retire_count_taken_stat[k] = 0;
+    m_pred_retire_count_nottaken_stat[k] = 0;
+    m_nonpred_retire_count_stat[k] = 0;
+    m_pred_reg_retire_count_stat[k] = 0;
+    m_pred_reg_retire_taken_stat[k] = 0;
+    m_pred_reg_retire_nottaken_stat[k] = 0;
+    
+    m_reg_stall_count_stat[k] = 0;
+    m_decode_stall_count_stat[k] = 0;
+    m_iwin_stall_count_stat[k] = 0;
+    m_schedule_stall_count_stat[k] = 0;
+
+    m_stat_continue_calls[k] = 0;
+    m_stat_modified_instructions[k] = 0;
+    m_inorder_partial_success[k] = 0;
+
+    for (int i = 0; i < EXCEPT_NUM_EXCEPT_TYPES; i ++) {
+      m_exception_stat[k][i] = 0;
+    }
+  }   //end for all logical procs
+
+  m_branch_wrong_static_stat = 0;  
+
+  for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){
+    m_stat_num_write_buffer_hits[k] = 0;
+    m_stat_num_write_buffer_full[k] = 0;
+
+    m_stat_num_icache_miss[k] = 0;
+    m_stat_num_dcache_miss[k] = 0;
+    m_stat_icache_mshr_hits[k] = 0;
+    m_stat_retired_dcache_miss[k] = 0;
+    m_stat_retired_memory_miss[k] = 0;
+    m_stat_retired_mshr_hits[k] = 0;
+    m_stat_count_io_access[k] = 0;
+    m_num_cache_not_ready[k] = 0;
+  }
+
+  if (!CONFIG_WITH_RUBY) {
+    l2_cache->resetStats(  );
+    l2_mshr->resetStats(  );
+    l1_data_cache->resetStats(  );
+    dl1_mshr->resetStats(  );
+    l1_inst_cache->resetStats(  );
+    il1_mshr->resetStats(  );
+    l1_hwds_cache->resetStats(  );
+    hl1_mshr->resetStats(  );
+  }
+  for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){
+    m_opstat[k].resetStats();
+    if ( m_ideal_retire_count )
+      m_ideal_retire_count[k]     = 0;
+  }
+
+}
+
+//***************************************************************************
+void pseq_t::printStats( void )
+{
+
+  #ifdef DEBUG_PSEQ
+    DEBUG_OUT("pseq_t:printStats BEGIN\n");
+  #endif
+
+  // temporarily stop debug filtering-- you asked for the stats right?
+  uint64 filterTime = getDebugTime();
+  setDebugTime( 0 );
+
+   char   user_mode = '?';
+   char   buf[80], buf1[80], buf2[80], buf3[80], buf4[80], buf5[80], buf6[80], buf7[80], buf8[80], buf9[80];
+   double total_pct = 0.0;
+   uint64 total_ideal_coverage = 0;
+
+ for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
+   if (m_stat_committed[k] > 0) {  
+     out_info("*** Opcode stats [logical proc %d]:\n",k);
+     m_opstat[k].print( this );
+     out_info("\n");
+   }
+
+   if (m_ideal_retire_count[k] > 0) {
+     out_info("*** Ideal opcode stats [logical proc %d]:\n",k);
+    m_ideal_opstat[k].print( this );
+    out_info("\n");
+    out_info("Ideal predictor rating:\n");
+    for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
+      total_ideal_coverage += m_hist_ideal_coverage[i];
+    }
+    for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
+      if (total_ideal_coverage == 0)
+        total_pct = 0.0;
+      else
+        total_pct = ((double) m_hist_ideal_coverage[i] / (double) total_ideal_coverage)
+          *100.0;
+      out_info("%-20.20s: %24.24s %6.2lf%%\n",
+               fetch_menomic( (pseq_fetch_status_t) i ),
+               commafmt(m_hist_ideal_coverage[i], buf, 80),
+               total_pct);
+    }
+    out_info("\n");
+  }
+   out_info("\n");
+
+  out_info("*** Trap   stats [logical proc: %d]:\n",k);
+  out_info("  [Trap#]  Times-Taken Times-Complete Simics-Taken    Name\n");
+  for (int i = 0; i < TRAP_NUM_TRAP_TYPES; i ++) {
+    if ( m_trapstat[k][i] != 0 || m_simtrapstat[k][i] != 0) {
+      out_info("  [%3d] %14lld  %14lld %14lld  %s\n", i, m_trapstat[k][i], m_completed_trapstat[k][i], m_simtrapstat[k][i],
+               pstate_t::trap_num_menomic( (trap_type_t) i ));
+    }
+  }
+
+  #if 0
+  //now output software initiated traps (using tcc instr)
+  for(int i=0; i < MAX_SOFTWARE_TRAPS; ++i){
+    if(m_software_trapstat[k][i] != 0){
+      out_info("  [%3d] %14lld %14lld  Software_Trap_%d\n", i+256, m_software_trapstat[k][i], 0, i+256);
+    }
+  }
+  #endif
+  
+ }   //end for loop over all logical procs  
+
+ out_info("\n");
+
+ for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
+   out_info("*** Internal exception stats [logical proc %d]:\n",k);
+   out_info("###: seen    name\n");
+   for (int i = 0; i < EXCEPT_NUM_EXCEPT_TYPES; i ++) {
+     if ( m_exception_stat[k][i] != 0 ) {
+       out_info("  [%3d] %14lld  %s\n", i, m_exception_stat[k][i],
+                pstate_t::async_exception_menomic( (exception_t) i ));
+     }
+   }
+   out_info("\n");
+ }  //end for loop over all logical procs
+    
+  out_info("*** ASI    stats:\n");
+  out_info("  ASI     Reads   Writes  Atomics\n");
+  for (uint32 i = 0; i < MAX_NUM_ASI; i ++) {
+    if ( m_asi_rd_stat[i] != 0 ||
+         m_asi_wr_stat[i] != 0 ||
+         m_asi_at_stat[i] != 0 ) {
+      out_info("  0x%02x %8lld %8lld %8lld\n", 
+               i, m_asi_rd_stat[i], m_asi_wr_stat[i], m_asi_at_stat[i] );
+    }
+  }
+
+  out_info("\n");
+
+  uint64 total_pred = 0;
+  uint64 total_seen = 0;
+  uint64 total_right = 0;
+  uint64 total_wrong = 0;
+  double bpaccuracy;
+  out_info("*** Branch   stats: (user, kernel, total)\n");
+  out_info("  Type           Preds      Retired        Right       Wrong       %%Right\n");
+  for (uint32 i = 0; i < BRANCH_NUM_BRANCH_TYPES; i++) {
+    for (uint32 j = 0; j < TOTAL_INSTR_MODE; j++) {
+
+      // get the mode string
+      switch (j) {
+      case 0:
+        user_mode = 'U';
+        break;
+      case 1:
+        user_mode = 'K';
+        break;
+      case 2:
+        user_mode = 'T';
+        break;
+      default:
         ERROR_OUT("pseq_t::PrintStats(): unknown branch type=%d\n", j);
         SIM_HALT;
       }
@@ -7121,6 +7501,7 @@ void pseq_t::printStats( void )
   
   /* register baseline stats */
   out_info("  %-50.50s %10llu\n", "number of instructions read from trace:", m_stat_trace_insn[k]);
+  out_info("  %-50.50s %10llu\n", "total number of cycles:", m_stat_cycles[k]);
   out_info("  %-50.50s %10llu\n", "total number of instructions committed:", m_stat_committed[k]);
   out_info("  %-50.50s %10llu\n", "total number of times squash is called:", m_stat_total_squash[k]);
   out_info("  %-50.50s %10llu\n", "total number of times we overwrote next instr:", m_stat_modified_instructions[k]);
@@ -7139,6 +7520,16 @@ void pseq_t::printStats( void )
   out_info("  %-50.50s %10llu\n", "total number of atomics executed:", m_stat_atomics_exec[k]);
   out_info("  %-50.50s %10llu\n", "total number of prefetches executed:", m_stat_prefetches_exec[k]);
   out_info("  %-50.50s %10llu\n", "total number of control insts executed:", m_stat_control_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds insts executed:", m_stat_hwds_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds extract insts executed:", m_stat_hwds_extract_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds extract_last insts executed:", m_stat_hwds_extract_last_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds insert insts executed:", m_stat_hwds_insert_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds first insts executed:", m_stat_hwds_first_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds last insts executed:", m_stat_hwds_last_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds spill insts executed:", m_stat_hwds_spill_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds fill insts executed:", m_stat_hwds_fill_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds get context insts executed:", m_stat_hwds_get_context_exec[k]);
+  out_info("  %-50.50s %10llu\n", "total number of hwds check underflow insts executed:", m_stat_hwds_adjust_spill_count_exec[k]);
 
   out_info("  %-50.50s %10llu\n", "total number of loads retired:",
            m_stat_loads_retired[k]);
@@ -7157,7 +7548,8 @@ void pseq_t::printStats( void )
   out_info("  %-50.50s %10llu\n", "total number of prefetches retired:",
            m_stat_prefetches_retired[k]);
   out_info("  %-50.50s %10llu\n", "total number of control instrs committed:", m_stat_control_retired[k]);
-
+  out_info("  %-50.50s %10llu\n", "total number of hwds instrs committed:", m_stat_hwds_retired[k]);
+  
   out_info("  %-50.50s %10llu\n", "loads with valid data at execute:", m_stat_loads_found[k]);
   out_info("  %-50.50s %10llu\n", "loads with invalid data at execute:", m_stat_loads_notfound[k]);
   out_info("  %-50.50s %10llu\n", "total number of spill traps:", m_stat_spill[k]);
@@ -7335,6 +7727,9 @@ void pseq_t::printStats( void )
     dl1_mshr->printStats( this );
     l1_inst_cache->printStats( this );
     il1_mshr->printStats( this );
+    l1_hwds_cache->printStats( this );
+    hl1_mshr->printStats( this );
+
   }
 
   //print out SMT icount stats
@@ -7400,10 +7795,10 @@ void pseq_t::printStats( void )
   out_info("  %-50.50s %10llu\n", "Total number of instructions",
            m_stat_committed[k] );
   out_info("  %-50.50s %10llu\n", "Total number of cycles",
-           getLocalCycle() );
+           m_stat_cycles[k] );
   out_info("  %-50.50s %10llu\n", "number of continue calls", m_stat_continue_calls[k] );
   out_info("  %-50.50s %g\n", "Instruction per cycle:",
-           (double) m_stat_committed[k] / (double) getLocalCycle() );
+           (double) m_stat_committed[k] / (double) m_stat_cycles[k] );
  } //end for loop over all logical procs
 
   out_info("  %-50.50s %lu sec %lu usec\n", "Total Elapsed Time:",
@@ -7417,7 +7812,7 @@ void pseq_t::printStats( void )
   
   double dsec = (double) sec_expired + ((double) usec_expired / (double) 1000000);
 
-  out_info("  %-50.50s %g\n", "Approximate cycle per sec:",
+  out_info("  %-50.50s %g\n", "Approximate cycle (total) per sec:",
            (double) getLocalCycle() / dsec);
 
  for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
@@ -7580,24 +7975,6 @@ pseq_t::initializeStats(void) {
   DEBUG_OUT("pseq_t:initializeStats BEGIN\n");
   #endif
 
-  //WATTCH power: bank num stats
-  for(int i=0; i < 8; ++i){
-    m_l1i_banknum_accesses[i] = 0;
-    m_l1d_banknum_accesses[i] = 0;
-  }
-  for(int i=0; i < 9; ++i){
-    m_l1i_8bank_histogram[i] = 0;
-    m_l1d_8bank_histogram[i] = 0;
-  }
-  for(int i=0; i < 5; ++i){
-    m_l1i_4bank_histogram[i] = 0;
-    m_l1d_4bank_histogram[i] = 0;
-  }
-  for(int i=0; i < 3; ++i){
-    m_l1i_2bank_histogram[i] = 0;
-    m_l1d_2bank_histogram[i] = 0;
-  }
-
   m_overall_timer = new stopwatch_t *[CONFIG_LOGICAL_PER_PHY_PROC];
   m_thread_timer = new stopwatch_t *[CONFIG_LOGICAL_PER_PHY_PROC];
   m_thread_histogram = new histogram_t *[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -7635,45 +8012,10 @@ pseq_t::initializeStats(void) {
     m_simtrapstat[proc] = new uint64[TRAP_NUM_TRAP_TYPES];
     m_software_trapstat[proc] = new uint64[MAX_SOFTWARE_TRAPS];
     m_completed_trapstat[proc] = new uint64[TRAP_NUM_TRAP_TYPES];
-
-    for (int i = 0; i < TRAP_NUM_TRAP_TYPES; i ++) {
-      m_trapstat[proc][i] = 0;
-      m_simtrapstat[proc][i] = 0;
-      m_completed_trapstat[proc][i] = 0;
-    }
-    for(int i=0; i < MAX_SOFTWARE_TRAPS; ++i){
-      m_software_trapstat[proc][i] = 0;
-    }
-
-    m_stat_exceed_scheduling_window[proc] = 0;
-    m_stat_not_enough_registers[proc] = 0;
-    m_icount_stats[proc].icount_sum = 0;
-    m_icount_stats[proc].num_samples = 0;
-    m_icount_stats[proc].max_icount = 0;
-
-    m_ifetch_miss_latency[proc].num_misses = 0;
-    m_ifetch_miss_latency[proc].latency_sum =0;
-    m_ifetch_miss_latency[proc].num_fastpath = 0;
-    m_load_miss_latency[proc].num_misses = 0;
-    m_load_miss_latency[proc].latency_sum =0;
-    m_load_miss_latency[proc].num_fastpath = 0;
-    m_store_miss_latency[proc].num_misses = 0;
-    m_store_miss_latency[proc].latency_sum =0;
-    m_store_miss_latency[proc].num_fastpath = 0;
-    m_atomic_miss_latency[proc].num_misses = 0;
-    m_atomic_miss_latency[proc].latency_sum =0;
-    m_atomic_miss_latency[proc].num_fastpath = 0;
   }
 
-  for (uint32 i = 0; i < MAX_NUM_ASI; i ++) {
-    m_asi_rd_stat[i] = 0;
-    m_asi_wr_stat[i] = 0;
-    m_asi_at_stat[i] = 0;
-  }
   m_hist_fetch_per_cycle = (uint64 *) malloc( sizeof(uint64) * (MAX_FETCH+1));
-  for (uint32 i = 0; i < MAX_FETCH + 1; i++) {
-    m_hist_fetch_per_cycle[i] = 0;
-  }
+
   //per-thread histogram
   m_hist_fetch_per_thread = new uint64*[CONFIG_LOGICAL_PER_PHY_PROC];
   m_hist_decode_per_thread = new uint64*[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -7685,107 +8027,38 @@ pseq_t::initializeStats(void) {
     m_hist_decode_per_thread[j] = new uint64[MAX_DECODE+1];
     m_hist_schedule_per_thread[j] = new uint64[MAX_DISPATCH+1];
     m_hist_retire_per_thread[j] = new uint64[MAX_RETIRE+1];
-
-    for (uint32 i = 0; i < MAX_FETCH + 1; i++) {
-      m_hist_fetch_per_thread[j][i] = 0;
-    }
-    for (uint32 i = 0; i < MAX_DECODE + 1; i++) {
-      m_hist_decode_per_thread[j][i] = 0;
-    }
-    for (uint32 i = 0; i < MAX_DISPATCH + 1; i++) {
-      m_hist_schedule_per_thread[j][i] = 0;
-    }
-    for (uint32 i = 0; i < MAX_RETIRE + 1; i++) {
-      m_hist_retire_per_thread[j][i] = 0;
-    }
   }
 
  m_hist_smt_fetch_per_cycle = (uint64 *) malloc( sizeof(uint64) * (m_threads_per_cycle+1));
-  for (uint32 i = 0; i < m_threads_per_cycle + 1; i++) {
-    m_hist_smt_fetch_per_cycle[i] = 0;
-  }
   m_hist_decode_per_cycle = (uint64 *) malloc( sizeof(uint64) * (MAX_DECODE+1) );
-  for (uint32 i = 0; i < MAX_DECODE + 1; i++) {
-    m_hist_decode_per_cycle[i] = 0;
-  }
   m_hist_schedule_per_cycle = (uint64 *) malloc( sizeof(uint64) * (MAX_DISPATCH+1) );
-  for (uint32 i = 0; i < MAX_DISPATCH + 1; i++) {
-    m_hist_schedule_per_cycle[i] = 0;
-  }
   m_hist_retire_per_cycle = (uint64 *) malloc( sizeof(uint64) * (MAX_RETIRE+1) );
-  for (uint32 i = 0; i < MAX_RETIRE + 1; i++) {
-    m_hist_retire_per_cycle[i] = 0;
-  }
-
   m_hist_fetch_stalls = (uint64 *) malloc( sizeof(uint64) * PSEQ_FETCH_MAX_STATUS );
-  for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
-    m_hist_fetch_stalls[i] = 0;
-  }
   m_hist_retire_stalls = (uint64 *) malloc( sizeof(uint64) * PSEQ_RETIRE_MAX_STATUS );
-  for (uint32 i = 0; i < PSEQ_RETIRE_MAX_STATUS; i++) {
-    m_hist_retire_stalls[i] = 0;
-  }
-
   m_hist_squash_stage = (uint64 **) malloc( sizeof(uint64 *) *
                                             (dynamic_inst_t::MAX_INST_STAGE) );
   for (uint32 i = 0; i < dynamic_inst_t::MAX_INST_STAGE; i++) {
     m_hist_squash_stage[i] = (uint64 *) malloc( sizeof(uint64) * (IWINDOW_ROB_SIZE) );
-    for (int32 j = 0; j < IWINDOW_ROB_SIZE; j++) {
-      m_hist_squash_stage[i][j] = 0;
-    }
   }
 
   m_stat_retire_notready_stage = new uint64[dynamic_inst_t::MAX_INST_STAGE];
-  for(int i=0; i < dynamic_inst_t::MAX_INST_STAGE; ++i){
-    m_stat_retire_notready_stage[i] = 0;
-  }
   
   m_hist_decode_return = (uint64 *) malloc( sizeof(uint64) * (PSEQ_HIST_DECODE) );
-  for (int32 i = 0; i < PSEQ_HIST_DECODE; i++) {
-    m_hist_decode_return[i] = 0;
-  }
 
   m_hist_ff_length = (uint64 *) malloc( sizeof(uint64) * PSEQ_MAX_FF_LENGTH );
-  for (uint32 i = 0; i < PSEQ_MAX_FF_LENGTH; i++) {
-    m_hist_ff_length[i] = 0;
-  }
-
   m_hist_ideal_coverage = (uint64 *) malloc( sizeof(uint64) * PSEQ_FETCH_MAX_STATUS );
-  for (uint32 i = 0; i < PSEQ_FETCH_MAX_STATUS; i++) {
-    m_hist_ideal_coverage[i] = 0;
-  }
-
-  m_stat_no_fetch_taken_branch = 0;
-  m_stat_no_fetch_across_lines = 0;
   
   m_stat_fu_utilization = (uint64 *) malloc( sizeof(uint64) * 
                                              FU_NUM_FU_TYPES );
   m_stat_fu_stall = (uint64 *) malloc( sizeof(uint64) * 
                                              FU_NUM_FU_TYPES );
-  for (uint32 i = 0; i < FU_NUM_FU_TYPES; i++) {
-    m_stat_fu_utilization[i] = 0;
-    m_stat_fu_stall[i] = 0;
-  }
 
   m_stat_fu_util_retired = (uint64 **) malloc(sizeof(uint64 *) * CONFIG_LOGICAL_PER_PHY_PROC);
   for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){  
     m_stat_fu_util_retired[k] = (uint64 *) malloc( sizeof(uint64) * 
                                                    FU_NUM_FU_TYPES );
-    for (uint32 i = 0; i < FU_NUM_FU_TYPES; i++) {
-      m_stat_fu_util_retired[k][i] = 0;
-    }
   }
     
-  for (uint32 i = 0; i < BRANCH_NUM_BRANCH_TYPES; i++) {
-    for (uint32 j = 0; j < TOTAL_INSTR_MODE; j++) {
-      m_branch_pred_stat[i][j]  = 0;
-      m_branch_seen_stat[i][j]  = 0;
-      m_branch_right_stat[i][j] = 0;
-      m_branch_wrong_stat[i][j] = 0;
-    }
-    m_branch_except_stat[i] = 0;
-  }
-
   m_stat_memread_exception =  new uint64[CONFIG_LOGICAL_PER_PHY_PROC]; 
   m_last_simexception = new trap_type_t[CONFIG_LOGICAL_PER_PHY_PROC];
   m_last_traptype = new trap_type_t*[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -7802,17 +8075,6 @@ pseq_t::initializeStats(void) {
     }
   }
 
-  m_stat_va_out_of_range = 0;
-
-  for(int i=0; i < MAX_NUM_ASI; ++i){
-    m_stat_uncacheable_read_asi[i] = 0;
-    m_stat_uncacheable_write_asi[i] = 0;
-    m_stat_uncacheable_atomic_asi[i] = 0;
-    m_stat_functional_read_asi[i] = 0;
-    m_stat_functional_write_asi[i] = 0;
-    m_stat_functional_atomic_asi[i] = 0;
-  }
-
   //Used to track start and end of WB stall cycles
   m_wb_stall_start_cycle = 0;
   m_wb_stall_end_cycle = 0;
@@ -7823,6 +8085,7 @@ pseq_t::initializeStats(void) {
   m_stat_count_retiresquash = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   
   m_stat_trace_insn = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_cycles = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_committed = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_commit_squash = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_count_asistoresquash = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -7840,6 +8103,7 @@ pseq_t::initializeStats(void) {
   m_stat_atomics_retired = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_prefetches_retired = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_control_retired = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_retired = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_fetched = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_mini_itlb_misses = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_decoded = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -7850,6 +8114,17 @@ pseq_t::initializeStats(void) {
   m_stat_atomics_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_prefetches_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_control_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_extract_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_extract_last_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_insert_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_first_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_last_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_spill_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_fill_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_get_context_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+  m_stat_hwds_adjust_spill_count_exec = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
+
   m_stat_loads_found = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_loads_notfound = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_stat_total_squash = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
@@ -7918,114 +8193,9 @@ pseq_t::initializeStats(void) {
     m_overall_timer[k] = new stopwatch_t(m_id+k);         
     m_thread_timer[k] = new stopwatch_t(m_id+k);          
     m_thread_histogram[k] = new histogram_t( "ThreadPC", 2048 );
-    m_exclude_count[k] = 0;
-    m_thread_count[k] = 0;
-    m_thread_count_idle[k] = 0;
-
-    m_stat_early_store_bypass[k] = 0;
-    //    m_branch_wrong_static_stat[k] = 0;
-    m_stat_count_badretire[k] = 0;
-    m_stat_count_functionalretire[k] = 0;
-    m_stat_count_retiresquash[k] = 0;
-
-    m_stat_trace_insn[k] = 0;
-    m_stat_committed[k] = 0;
-    m_stat_commit_squash[k] = 0;
-    m_stat_count_asistoresquash[k] = 0;
-    m_stat_commit_good[k] = 0;
-    m_stat_commit_bad[k] = 0;
-    m_stat_commit_unimplemented[k] = 0;
-    m_stat_count_except[k] = 0;
-    
-    m_stat_loads_retired[k] = 0;
-    m_stat_stores_retired[k] = 0;
-    m_stat_retired_stores_no_permission[k] = 0;
-    m_stat_retired_atomics_no_permission[k] = 0;
-    m_stat_retired_loads_no_permission[k] = 0;
-    m_stat_retired_loads_nomatch[k] = 0;
-    m_stat_atomics_retired[k] = 0;
-    m_stat_prefetches_retired[k] = 0;
-    m_stat_control_retired[k] = 0;
-    m_stat_fetched[k] = 0;
-    m_stat_mini_itlb_misses[k] = 0;
-    m_stat_decoded[k] = 0;
-    m_stat_total_insts[k] = 0;
-
-    m_stat_loads_exec[k] = 0;
-    m_stat_stores_exec[k] = 0;
-    m_stat_atomics_exec[k] = 0;
-    m_stat_prefetches_exec[k] = 0;
-    m_stat_control_exec[k] = 0;
-    m_stat_loads_found[k] = 0;
-    m_stat_loads_notfound[k] = 0;
-    m_stat_total_squash[k] = 0;
-    m_stat_spill[k] = 0;
-    m_stat_fill[k] = 0;
-
-    //main memory stats
-    m_stat_miss_count[k] = 0;
-    m_stat_last_miss_seq[k] = 0;
-    m_stat_last_miss_fetch[k] = 0;
-    m_stat_last_miss_issue[k] = 0;
-    m_stat_last_miss_retire[k] = 0;
-
-    m_stat_miss_effective_ind[k] = 0;
-    m_stat_miss_effective_dep[k] = 0;
-    m_stat_miss_inter_cluster[k] = 0;
-    
-    // lsq stats 
-    m_stat_load_bypasses[k] = 0;
-    m_stat_atomic_bypasses[k] = 0;
-    m_stat_num_early_stores[k] = 0;
-    m_stat_num_early_store_bypasses[k] = 0;
-    m_stat_num_early_atomics[k] = 0;
-    m_stat_load_store_conflicts[k] = 0;
-    m_stat_load_incorrect_store[k] = 0;
-    m_stat_atomic_incorrect_store[k] = 0;
-    m_stat_stale_predictions[k] = 0;
-    m_stat_stale_success[k] = 0;
     m_stat_stale_histogram[k] = (uint64 *)malloc( sizeof(uint64)*
                                                   (log_base_two(MEMOP_MAX_SIZE*8)+1) );
-    for (uint32 i = 0; i < (log_base_two(MEMOP_MAX_SIZE*8) + 1); i++) {  
-      m_stat_stale_histogram[k][i] = 0;
-    }
-
-    // StoreSet stats
-    m_stat_storeset_stall_load[k] = 0;
-    m_stat_storeset_stall_atomic[k] = 0;
-
-    // predictation statistics
-    m_pred_count_stat[k] = 0;
-    m_pred_count_taken_stat[k] = 0;
-    m_pred_count_nottaken_stat[k] = 0;
-    m_nonpred_count_stat[k] = 0;
-    m_pred_reg_count_stat[k] = 0;
-    m_pred_reg_taken_stat[k] = 0;
-    m_pred_reg_nottaken_stat[k] = 0;
-    
-    m_pred_retire_count_stat[k] = 0;
-    m_pred_retire_count_taken_stat[k] = 0;
-    m_pred_retire_count_nottaken_stat[k] = 0;
-    m_nonpred_retire_count_stat[k] = 0;
-    m_pred_reg_retire_count_stat[k] = 0;
-    m_pred_reg_retire_taken_stat[k] = 0;
-    m_pred_reg_retire_nottaken_stat[k] = 0;
-    
-    m_reg_stall_count_stat[k] = 0;
-    m_decode_stall_count_stat[k] = 0;
-    m_iwin_stall_count_stat[k] = 0;
-    m_schedule_stall_count_stat[k] = 0;
-
-    m_stat_continue_calls[k] = 0;
-    m_stat_modified_instructions[k] = 0;
-    m_inorder_partial_success[k] = 0;
-
-    for (int i = 0; i < EXCEPT_NUM_EXCEPT_TYPES; i ++) {
-      m_exception_stat[k][i] = 0;
-    }
   }   //end for all logical procs
-
-  m_branch_wrong_static_stat = 0;  
  
 
   /* write buffer stats */
@@ -8042,20 +8212,6 @@ pseq_t::initializeStats(void) {
   m_stat_count_io_access = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
   m_num_cache_not_ready = new uint64[CONFIG_LOGICAL_PER_PHY_PROC];
 
-  for(uint k=0; k <  CONFIG_LOGICAL_PER_PHY_PROC; ++k){
-    m_stat_num_write_buffer_hits[k] = 0;
-    m_stat_num_write_buffer_full[k] = 0;
-
-    m_stat_num_icache_miss[k] = 0;
-    m_stat_num_dcache_miss[k] = 0;
-    m_stat_icache_mshr_hits[k] = 0;
-    m_stat_retired_dcache_miss[k] = 0;
-    m_stat_retired_memory_miss[k] = 0;
-    m_stat_retired_mshr_hits[k] = 0;
-    m_stat_count_io_access[k] = 0;
-    m_num_cache_not_ready[k] = 0;
-  }
-
   m_stat_hist_misses = new histogram_t( "Misses", 1024 );
   m_stat_hist_interarrival = new histogram_t( "Bursts", 4096 );
 
@@ -8064,6 +8220,9 @@ pseq_t::initializeStats(void) {
   m_stat_hist_inter_cluster  = new histogram_t( "IClust", 4096 );
   m_stat_hist_dep_ops        = new histogram_t( "DepOps", 4096 );
 
+  assert(m_stat_hist_dep_ops);
+  resetStats();
+
   #ifdef DEBUG_PSEQ
     DEBUG_OUT("pseq_t:initializeStats END\n");
   #endif
diff -X dontdiff -uprN gems-2.1.1/opal/system/pseq.h gems-2.1.1-hwpq-head2/opal/system/pseq.h
--- gems-2.1.1/opal/system/pseq.h	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/pseq.h	2012-03-12 12:32:27.000000000 -0400
@@ -420,12 +420,20 @@ public:
   cache_t *getInstructionCache( void ) {
     return (l1_inst_cache);
   }
+  /** get the l1 hwds cache interface */
+  cache_t *getHwdsCache( void ) { 
+    return (l1_hwds_cache);
+  }
   /** get the ruby cache interface */
   // for SMT, all logical procs should see same Ruby interface
   rubycache_t *getRubyCache( void ) {
     return (m_ruby_cache);
   }
 
+  hwpq_t *getHardwarePriorityQueue( void ) {
+    return (m_hwpq);
+  }
+
   /* returns the current fetch PC */
   abstract_pc_t * getFetchPC(int proc) {
     return m_fetch_at[proc];
@@ -471,6 +479,7 @@ public:
   /** increment the local cycle counter */
   void         localCycleIncrement() {
     m_local_cycles++;
+    m_stat_cycles[m_id]++;
   }
 
   /** statistics object holding per dynamic instruction stats */
@@ -677,6 +686,8 @@ public:
   void    print( void );
   /** print the in flight instructions */
   void    printInflight( void );
+  /** reset statistics */
+  void    resetStats( void );
   /** print statistics */
   void    printStats( void );
   /** prints debug info */
@@ -831,7 +842,7 @@ public:
   void setTransactionLevel( mf_ruby_api_t * ruby_api );
 
   //**************************************************************************
- 
+
 private:
 
   /**
@@ -1214,24 +1225,7 @@ private:
   /** The pointer to the Write Buffer */
   writebuffer_t * m_write_buffer;
 
-  /** @name Cache support: L1 I/D caches, L2 caches */
-  //@{
-  /// L1 miss status holding register structure
-  mshr_t      *il1_mshr;
-  mshr_t      *dl1_mshr;
 
-  /// L1 instruction cache
-  generic_cache_template<generic_cache_block_t> *l1_inst_cache;
-  /// L1 data cache
-  generic_cache_template<generic_cache_block_t> *l1_data_cache;
-
-  /// L2 miss status holding register structure
-  mshr_t      *l2_mshr;
-  /// L2 (unified) cache
-  generic_cache_template<generic_cache_block_t> *l2_cache;
-  /// alternative to (uniprocessor cache structure): the ruby cache
-  rubycache_t *m_ruby_cache;
-  //@}
 
   /** @name MMU support: I/D-TLB, contexts */
   //@{
@@ -1512,9 +1506,42 @@ private:
   /// Pointer to the WATTCH power stats
   power_t * m_power_stats;
 
+public:
+ /** @name Cache support: L1 I/D caches, L2 caches */
+  //@{
+  /// L1 miss status holding register structure
+  mshr_t      *il1_mshr;
+  mshr_t      *dl1_mshr;
+
+  /// L1 instruction cache
+  generic_cache_template<generic_cache_block_t> *l1_inst_cache;
+  /// L1 data cache
+  generic_cache_template<generic_cache_block_t> *l1_data_cache;
+
+  /// L2 miss status holding register structure
+  mshr_t      *l2_mshr;
+  /// L2 (unified) cache
+  generic_cache_template<generic_cache_block_t> *l2_cache;
+  /// alternative to (uniprocessor cache structure): the ruby cache
+  rubycache_t *m_ruby_cache;
+  //@}
+
+  // GAB:
+  /** @name HWPQ support: HW priority queues, hwpq caches */
+  //@{
+  /// L1 miss status holding register (hwpq)
+  mshr_t      *hl1_mshr;
+  /// L1 hwds cache
+  generic_cache_template<generic_cache_block_t> *l1_hwds_cache;
+
+  /// an array of hardware priority queues
+  hwpq_t      *m_hwpq;
+  /// number of hardware priority queues
+  int          m_hwpq_count;
+
+  //@}
 
 
-public:
   /// per cpu stopwatch counting simulated time
   stopwatch_t      ** m_overall_timer;
   /// per cpu stopwatch for current thread's simulated time
@@ -1790,6 +1817,8 @@ public:
 
   /// number of instructions read from trace
   uint64   * m_stat_trace_insn;
+  /// total number of cycles
+  uint64  *  m_stat_cycles;
   /// total number of instructions committed
   uint64  *  m_stat_committed;
   /// total number of times squash is called (includes branch mispredicts)
@@ -1825,6 +1854,8 @@ public:
   uint64  *  m_stat_prefetches_retired;
   /// total number of control insts committed
   uint64  *  m_stat_control_retired;
+  /// total number of hwds insts committed
+  uint64  *  m_stat_hwds_retired;
 
   /// total number of instructions fetched
   uint64  *  m_stat_fetched;
@@ -1845,6 +1876,20 @@ public:
   uint64   * m_stat_prefetches_exec;
   /// total number of control insts executed
   uint64   * m_stat_control_exec;
+  /// total number of hwds insts executed
+  uint64   * m_stat_hwds_exec;
+
+
+  /// hwds stats
+  uint64  * m_stat_hwds_extract_exec;
+  uint64  * m_stat_hwds_extract_last_exec;
+  uint64  * m_stat_hwds_insert_exec;
+  uint64  * m_stat_hwds_first_exec;
+  uint64  * m_stat_hwds_last_exec;
+  uint64  * m_stat_hwds_spill_exec;
+  uint64  * m_stat_hwds_fill_exec;
+  uint64  * m_stat_hwds_get_context_exec;
+  uint64  * m_stat_hwds_adjust_spill_count_exec;
 
   /// loads which are found in the trace
   uint64   * m_stat_loads_found;
@@ -1950,6 +1995,7 @@ public:
   /// The number of times the ideal processor was not able to reach the end of the window
   uint64  *  m_inorder_partial_success;
   //@}
+  bool reset_stats;
 };
 
 /**
diff -X dontdiff -uprN gems-2.1.1/opal/system/statici.C gems-2.1.1-hwpq-head2/opal/system/statici.C
--- gems-2.1.1/opal/system/statici.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/statici.C	2012-03-01 11:48:30.000000000 -0500
@@ -501,6 +501,7 @@ void   static_inst_t::setNextPC( void )
   case DYN_STORE:
   case DYN_PREFETCH:
   case DYN_ATOMIC:
+  case DYN_HWPQ:
     // now that we're running production, we always want a nextPC function
   case DYN_NONE:
     nextPC = &dynamic_inst_t::nextPC_execute;
@@ -743,6 +744,7 @@ int static_inst_t::printDisassemble( cha
   case DYN_ATOMIC:
     return (printMemoryDis(str));
     break;
+  case DYN_HWPQ:
   default:
     return (printNormalDis(str));
   }
@@ -2869,7 +2871,12 @@ static_inst_t::decodeInstructionInfo( pa
       break;
 
     case 55:  // impdep2
-      m_opcode = i_impdep2;
+      // GAB: Interpret the impdep2 instruction
+      m_type    = DYN_HWPQ;
+      REG_TWO_I( 12 );    // decode two-reg with either rs2 or imm
+      m_futype  = FU_IMPDEP2; // need a function unit to order accesses..
+
+      m_opcode  = i_impdep2;
       break;
 
     case 56:  // jmpl
diff -X dontdiff -uprN gems-2.1.1/opal/system/system.C gems-2.1.1-hwpq-head2/opal/system/system.C
--- gems-2.1.1/opal/system/system.C	2010-09-01 14:06:13.000000000 -0400
+++ gems-2.1.1-hwpq-head2/opal/system/system.C	2012-03-01 11:48:30.000000000 -0500
@@ -183,6 +183,9 @@ static void system_exception_handler( vo
 static void system_exception_tracer( void *obj, conf_object_t *proc,
                                      uint64 exception );
 
+#include <signal.h>
+static void system_signalint(int sig);
+
 // C++ Template: explicit instantiation
 template class map<breakpoint_id_t, breakpoint_action_t *>;
 
@@ -218,6 +221,9 @@ system_t::system_t( const char *configur
   m_sim_status = SIMSTATUS_BREAK;
   sprintf( m_sim_message_buffer, "situation nominal" );
 
+  // register sigint handler
+  signal( SIGINT, system_signalint );
+
   // establish opal ruby api (see ruby/interfaces/mf_api.h & ruby/interfaces/OpalInterface.C)
   m_opal_api = &hfa_ruby_interface;
   m_opal_api->hitCallback    = &system_t::rubyCompletedRequest;
@@ -357,12 +363,18 @@ system_breakpoint( void *data, conf_obje
     */
     //cout << "system_breakpoint called" << endl;
     // MAGIC breakpoints get intercepted here.  Opal currently does not do anything special here
-
-    return;
+    /* GAB: reset statistics on MAGIC(1) */
+    if ( parameter == 1UL) {
+      pseq_t *p = system_t::inst->m_seq[0];
+      p->out_info("reset number of cycles %lld\n", p->m_stat_cycles[0]);
+      //p->reset_stats = true;
+      p->resetStats(); 
+      return;
+    }
   }
- 
+
   //currently IGNORE the system_breakpoint (parameter = 0x4000)...
-  #if 0
+  #if 1
   ERROR_OUT("system_t::system_breakpoint REACHED param[ 0x%x ]\n", parameter);
 
   sprintf( system_t::inst->m_sim_message_buffer,
@@ -373,6 +385,15 @@ system_breakpoint( void *data, conf_obje
 }
 
 //***************************************************************************
+static void
+system_signalint( int sig )
+{
+   signal( sig, SIG_IGN ); //ignore the signal
+   HALT_SIMULATION;
+   signal( SIGINT, system_signalint ); // re-register signal
+}
+
+//***************************************************************************
 void system_t::simulate( uint64 instrCount )
 {
   //  
diff -X dontdiff -uprN gems-2.1.1/ruby/common/Debug.C gems-2.1.1-hwpq-head2/ruby/common/Debug.C
--- gems-2.1.1/ruby/common/Debug.C	2010-09-01 14:06:10.000000000 -0400
+++ gems-2.1.1-hwpq-head2/ruby/common/Debug.C	2012-03-01 11:48:30.000000000 -0500
@@ -66,6 +66,7 @@
 #include "Debug.h"
 #include "EventQueue.h"
 
+#include "string.h"
 class Debug;
 extern Debug* g_debug_ptr;
 std::ostream * debug_cout_ptr;
diff -X dontdiff -uprN gems-2.1.1/ruby/common/Debug.C.rej gems-2.1.1-hwpq-head2/ruby/common/Debug.C.rej
--- gems-2.1.1/ruby/common/Debug.C.rej	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/ruby/common/Debug.C.rej	2012-03-01 11:50:21.000000000 -0500
@@ -0,0 +1,10 @@
+--- ruby/common/Debug.C	2010-09-01 14:06:10.000000000 -0400
++++ ruby/common/Debug.C	2010-09-01 16:32:11.000000000 -0400
+@@ -66,6 +66,7 @@
+ #include "Debug.h"
+ #include "EventQueue.h"
+ 
++#include "string.h"
+ class Debug;
+ extern Debug* g_debug_ptr;
+ std::ostream * debug_cout_ptr;
diff -X dontdiff -uprN gems-2.1.1/ruby/log_tm/LazyTransactionVersionManager.C gems-2.1.1-hwpq-head2/ruby/log_tm/LazyTransactionVersionManager.C
--- gems-2.1.1/ruby/log_tm/LazyTransactionVersionManager.C	2010-09-01 14:06:10.000000000 -0400
+++ gems-2.1.1-hwpq-head2/ruby/log_tm/LazyTransactionVersionManager.C	2012-03-01 11:48:30.000000000 -0500
@@ -280,8 +280,9 @@ void LazyTransactionVersionManager::issu
       should_escape = true;
     }
 
-    CacheMsg storeMsg(Address(request_address),
-                      Address(request_address),
+    Address ad(request_address);
+    CacheMsg storeMsg(ad,
+                      ad,
                       CacheRequestType_ST_XACT,    
                       SIMICS_get_program_counter(getLogicalProcID(thread)),
                       AccessModeType_UserMode,
diff -X dontdiff -uprN gems-2.1.1/ruby/log_tm/LazyTransactionVersionManager.C.rej gems-2.1.1-hwpq-head2/ruby/log_tm/LazyTransactionVersionManager.C.rej
--- gems-2.1.1/ruby/log_tm/LazyTransactionVersionManager.C.rej	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/ruby/log_tm/LazyTransactionVersionManager.C.rej	2012-03-01 11:50:22.000000000 -0500
@@ -0,0 +1,14 @@
+--- ruby/log_tm/LazyTransactionVersionManager.C	2010-09-01 14:06:10.000000000 -0400
++++ ruby/log_tm/LazyTransactionVersionManager.C	2010-09-01 16:31:49.000000000 -0400
+@@ -280,8 +280,9 @@
+       should_escape = true;
+     }
+ 
+-    CacheMsg storeMsg(Address(request_address),
+-                      Address(request_address),
++    Address ad(request_address);
++    CacheMsg storeMsg(ad,
++                      ad,
+                       CacheRequestType_ST_XACT,    
+                       SIMICS_get_program_counter(getLogicalProcID(thread)),
+                       AccessModeType_UserMode,
diff -X dontdiff -uprN gems-2.1.1/ruby/system/CacheMemory.h gems-2.1.1-hwpq-head2/ruby/system/CacheMemory.h
--- gems-2.1.1/ruby/system/CacheMemory.h	2010-09-01 14:06:10.000000000 -0400
+++ gems-2.1.1-hwpq-head2/ruby/system/CacheMemory.h	2012-03-01 11:48:30.000000000 -0500
@@ -78,6 +78,7 @@
 #include "PseudoLRUPolicy.h"
 #include "LRUPolicy.h"
 #include <vector>
+#include "string.h"
 
 template<class ENTRY>
 class CacheMemory {
diff -X dontdiff -uprN gems-2.1.1/ruby/system/CacheMemory.h.rej gems-2.1.1-hwpq-head2/ruby/system/CacheMemory.h.rej
--- gems-2.1.1/ruby/system/CacheMemory.h.rej	1969-12-31 19:00:00.000000000 -0500
+++ gems-2.1.1-hwpq-head2/ruby/system/CacheMemory.h.rej	2012-03-01 11:50:23.000000000 -0500
@@ -0,0 +1,10 @@
+--- ruby/system/CacheMemory.h	2010-09-01 14:06:10.000000000 -0400
++++ ruby/system/CacheMemory.h	2010-09-01 16:30:13.000000000 -0400
+@@ -78,6 +78,7 @@
+ #include "PseudoLRUPolicy.h"
+ #include "LRUPolicy.h"
+ #include <vector>
++#include "string.h"
+ 
+ template<class ENTRY>
+ class CacheMemory {
diff -X dontdiff -uprN gems-2.1.1/scripts/makesymlinks.sh gems-2.1.1-hwpq-head2/scripts/makesymlinks.sh
--- gems-2.1.1/scripts/makesymlinks.sh	2010-09-01 14:06:12.000000000 -0400
+++ gems-2.1.1-hwpq-head2/scripts/makesymlinks.sh	2012-03-01 11:50:16.000000000 -0500
@@ -22,7 +22,7 @@ cd ../..
 # in your Simics 3 install
 echo "Making symlink for import directory..."
 #ln -s /simics-3.0.11/import import
-ln -s /p/multifacet/projects/simics/simics-3.0.11/import import
+ln -s ${SIMICS_INSTALL}/import import
 
 echo "Making symlinks for modules..."
 cd modules
